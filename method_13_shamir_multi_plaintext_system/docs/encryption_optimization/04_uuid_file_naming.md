# UUID を使用したファイル命名規則

## ファイル命名の課題

現在のシステムには以下のファイル命名に関する課題があります。また、過去形式との互換性は考慮せず、設計書の理念に完全準拠した新しい形式のみに対応したファイル命名規則を定義します：

1. **上書きリスク**: 同じ出力ファイル名を指定すると、既存ファイルが上書きされる
2. **関連性の不明確さ**: 複数の暗号化ファイル間の関連性を識別する手段がない
3. **情報漏洩リスク**: ファイル名にタイムスタンプなどの情報を含めると、作業時間帯や作業順序などの情報が第三者に漏洩する可能性がある
4. **ファイル種別の識別**: 設計書では暗号書庫としてファイル A とファイル B が同一の暗号ファイル内に混在保管される仕組みが規定されているが、ファイル名からファイル種別を識別できてしまうと情報漏洩リスクが生じる
5. **ファイルタイプの区別**: 設計書の「統計的区別不可能性」原則に従うと、初期化ファイルと暗号化済みファイルが外部から区別できない必要があるが、現在は区別可能な状態になっている
6. **旧コード関数の存在**: 過去形式に関連するコード関数がシステム内に残されており、セキュリティリスクのある実装が誤って使用される可能性がある

## 提案: UUID を使用したファイル命名

設計書の「統計的区別不可能性」と「メタデータの極小化」原則に基づき、以下の形式でファイル名を自動生成します。初期化するたびに新たな UUID を持つ暗号ファイルが生成され、既存ファイルが上書きされることはありません：

```
encrypted_{UUID}.json
```

例: `encrypted_550da07d-e131-4e5f-9a15-0a8e2f47be35.json`

### 仕様

1. **UUID**:

   - 形式: 標準的な UUID（バージョン 4）- ランダム生成
   - 目的: ファイルの一意性を保証
   - 特徴: 暗号論的に安全な乱数ベースで生成され、予測不可能かつ時間情報を含まない

2. **自動生成ルール**:

   - 出力ファイル名は常に自動生成され、初期化のたびに新たな UUID が付与される
   - 既存ファイルは上書きされず、新しいファイルとして生成される
   - ファイル種別（A/B）をファイル名に表示せず、内部的にのみ区別する

3. **暗号書庫の管理**:

   - 設計書に基づき、ファイル A とファイル B が同一の暗号ファイル内に混在保管される
   - 各ファイル種別の領域はパーティションマップキーから導出され、ファイル名には表示しない
   - ファイル種別の区別は暗号ファイル内でのみ行い、外部からは識別不能

4. **ファイルタイプの区別不能化**:

   - 初期化ファイルと暗号化済みファイルが同一のフォーマットと命名規則を持ち、外部から区別不能
   - ヘッダー情報を最小化（ソルト値のみ）し、両タイプのファイルで完全に同一の構造を採用
   - ファイル内容の統計的特性も同一になるよう完全固定長シリアライズを適用

5. **過去形式コードの完全削除**:

   - 過去形式のファイル名生成関数を完全に削除
   - UUID 命名規則に準拠しない古い関数（例：`generate_timestamp_filename()`）を削除
   - 過去形式をサポートするすべてのコードを削除

## 設計書の原則との整合性

ファイル命名規則は以下の点で設計書の原則と整合しています：

1. **メタデータの極小化**: タイムスタンプを含めないことで、作成時刻に関する情報漏洩リスクを排除
2. **統計的区別不可能性**: UUID のランダム性により、ファイル名からパターンを推測することが困難
3. **直交処理原則**: ファイル名生成プロセスが入力データの特性に左右されず一貫して実行される
4. **一意性の確保**: 上書きリスクの回避とファイルの識別が可能な最小限の情報のみを使用
5. **ファイル種別の隠蔽**: ファイル名からファイル種別（A/B）を推測できないようにする
6. **区別不能性**: 初期化ファイルと暗号化済みファイルをファイル名からも区別できないようにする
7. **コードベースの浄化**: 過去形式のコードを完全に削除し、セキュリティリスクを低減

## タイムスタンプを含めない理由

ファイル名にタイムスタンプを含めると以下のセキュリティリスクが生じます：

1. **作業パターンの漏洩**: 特定の時間帯に作業が集中していることが判明し、使用者の行動パターンが推測される
2. **作成順序の漏洩**: 複数ファイルの作成順序が明らかになり、情報の関連性や重要度が推測される
3. **タイムゾーン情報の漏洩**: 使用者の所在地域が推測される可能性がある
4. **設計書の「メタデータの極小化」原則に反する**: 必要のない情報をファイル名に含めることは設計原則に反する

## ファイル種別を内部でのみ区別する理由

ファイル名の設計においてファイル種別（A/B）を外部から隠蔽する理由：

1. **一貫性の確保**: 設計書の「統計的区別不可能性」理念との一貫性を保ち、システムの内部構造を外部から隠蔽する
2. **情報漏洩防止**: ファイル名からファイル種別が推測できないようにすることで情報漏洩を防止
3. **セキュリティの向上**: ファイルの所有権と管理を明確にし、誤ったファイルアクセスを防止
4. **ファイルパーティション設計との整合**: 設計書の規定通り A/B 用の領域が暗号ファイル内部で区別されるという設計理念との整合性を保つ

## ファイルタイプの区別不能性を実現する理由

初期化ファイルと暗号化済みファイルを区別不能にする理由：

1. **情報漏洩防止**: どのファイルが実データを含んでいるかという情報が漏洩するリスクを排除
2. **攻撃対象の不明確化**: 攻撃者がどのファイルを標的にすべきか判断できないようにする
3. **セキュリティレベルの統一**: 全てのファイルを同等のセキュリティレベルで扱う
4. **設計書の「統計的区別不可能性」原則の徹底**: 設計書の基本原則に完全準拠

## 過去形式コードを完全に削除する理由

過去形式のコード関数を完全に削除する理由：

1. **セキュリティリスクの排除**: 古い脆弱な実装が誤って使用されるリスクを排除
2. **コードベースの単純化**: 不要なコードを削除することでメンテナンス性を向上
3. **一貫性の確保**: 新しい形式のみをサポートすることで実装の一貫性を確保
4. **復活リスクの防止**: 古いコードが将来的に復活して使用されるリスクを防止
5. **設計書のセキュリティ基準の徹底**: 逸脱した実装が混入するリスクを排除

## 実装サンプル

```python
def generate_unique_filename(base_dir='./output', prefix='encrypted', ext='.json'):
    """一意なファイル名を生成する関数
    設計書の「統計的区別不可能性」と「メタデータの極小化」原則に基づき、
    初期化するたびに新しいUUIDを持つファイルを生成

    Args:
        base_dir: 出力ディレクトリパス
        prefix: ファイル名の接頭辞
        ext: ファイル拡張子
    """
    # ディレクトリが存在しない場合は作成
    os.makedirs(base_dir, exist_ok=True)

    # 常に新たなUUIDを生成（既存ファイルは上書きしない）
    # 暗号論的に安全な乱数ベースでUUID生成（バージョン4）
    file_uuid = str(uuid.uuid4())

    # ファイル名を組み立て（ファイル種別は含めない）
    filename = f"{prefix}_{file_uuid}{ext}"

    # 完全なパスを返す
    return os.path.join(base_dir, filename)
```

### コマンドライン引数の改善

コマンドラインインターフェースを変更して、出力ファイル名の自動生成をサポートします：

```python
# 初期化コマンドの例
parser.add_argument('--output-dir', '-o', default='./output',
                    help='出力ディレクトリパス。デフォルトは ./output/')

# 引数処理部分
output_dir = args.output_dir
os.makedirs(output_dir, exist_ok=True)

# 常に新しいUUIDを持つファイルを生成
output_path = generate_unique_filename(base_dir=output_dir)
print(f"暗号ファイルを生成しました: {output_path}")
```

### ヘッダー構造の統一

初期化ファイルと暗号化ファイルの内部構造を完全に統一するため、設計書の「メタデータの極小化」原則に従い、両方のファイルタイプで同一の最小限ヘッダー構造を使用します：

```python
# 両ファイルタイプで同一の最小化ヘッダー構造（ソルト値のみ）
file_header = {
    "salt": salt_base64
}

# 初期化ファイルと暗号化ファイルの両方で同じ構造を使用
file_structure = {
    "header": file_header,
    "values": values_array
}

# 完全固定長シリアライズを適用
serialized_file = fixed_length_serialize(file_structure)
```

### 過去形式コードの削除

過去形式のファイル名生成や処理に関連するコードは完全に削除します：

```python
# 以下のような関数はコードベースから完全に削除します
# これは削除すべき関数の例であり、実際にこのコードを実装してはいけません

# def generate_timestamp_filename():
#     # 時間情報を含むファイル名を生成（削除すべき）
#     ...

# def process_v1_file(filename):
#     # V1形式のファイルを処理（削除すべき）
#     ...

# def process_v2_file(filename):
#     # V2形式のファイルを処理（削除すべき）
#     ...
```

この命名規則により、初期化するたびに新たな UUID を持つ暗号ファイルが生成され、既存ファイルが上書きされることはありません。設計書の「メタデータの極小化」と「統計的区別不可能性」原則に完全に準拠し、ファイル名からも情報漏洩が発生しないよう配慮されています。また、ファイル A とファイル B が同一の暗号ファイル内に混在保管される仕組みをシステムレベルで実装し、ファイル管理の一貫性と安全性を高めています。さらに、初期化ファイルと暗号化済みファイルが外部から区別できないよう、ファイル名とヘッダー構造を統一し、どのファイルに実データが含まれているかという情報漏洩を防止します。

過去形式に関連するすべてのコード関数を完全に削除することで、セキュリティリスクのある古い実装が誤って使用されるリスクを排除し、クリーンで安全なコードベースを確保します。これにより、システム全体のセキュリティが向上し、設計書の理念に完全準拠した実装が実現します。
