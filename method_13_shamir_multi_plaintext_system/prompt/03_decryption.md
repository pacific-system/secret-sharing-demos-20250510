# 復号化モジュール実装ガイド

## 復号化モジュールの目的

このモジュールは暗号化ファイルとパスワードを入力として、対応する JSON 文書を復号します。シャミア秘密分散法を用いた多段 MAP 方式により、異なるパスワードによって異なる文書を復号することができます。

## 主要な機能と要件

### 1. 多段デコードプロセス

暗号ファイルを以下の多段デコードプロセスで処理します：

1. AES-GCM による二次暗号の解除
2. シェアマップの構築
3. 閾値以上のシェアを使って秘密値を復元
4. Base64 デコード
5. Latin-1 から UTF-8 へのデコード

### 2. シャミア秘密分散法によるシェア復元

- 閾値 `t` 以上のシェアから元の秘密値を復元
- ラグランジュ補間法による多項式の復元
- 有限体 GF(p) 上での計算

### 3. シェアトークンとセキュリティモデル

- シェアトークンは `9jfhsyenehgr6hkwhjyhbweey6d` のような単一行の文字列
- 全てのセキュリティはシェアトークンとパスワードの 2 要素に依存
- シェアトークンから占有できる可能性範囲の MAP を生成
- パスワードと組み合わせることで占有領域内のシェアを特定
- 適切な組み合わせのみが正しい文書を復号可能

### 4. 復号プロセスのマッピング

- パスワードとシェアトークンを入力として受け取る
- シェアトークンから占有領域の MAP を生成
- 占有領域内のシェア値を特定
- 閾値を満たすシェアを選択して復号を試行
- マッピングテーブルは一時的にのみ保持し、処理後に安全に削除

## 実装時の制約とガイドライン

### 絶対条件

1. **安全な一時ファイル処理**:

   - 一時ファイルもシャミア秘密分散法で保護
   - 一時ファイルには A 文書と B 文書が混在するデータを含まない
   - ファイル削除前に内容を上書き（0 バイトデータや乱数）して痕跡を残さない
   - メモリ上でも必要最小限のデータのみを保持

2. **処理の公平性**:

   - パスワードが間違っている場合も、処理時間が変わらないように実装
   - 早期リターンを避け、暗号学的にセキュアな比較を使用

3. **エラー処理の工夫**:

   - 正しくないパスワードに対しても同じ量の計算を行い、タイミング攻撃を防止
   - 適切なカナリア値の検証による安全な復号確認
   - エラーメッセージは情報漏洩のリスクを最小限に抑えるよう設計

4. **メモリ管理**:
   - 機密データを含む変数は使用後にゼロで上書き
   - 大きなファイルでもメモリ効率良く処理できるようストリーミング対応
   - ガベージコレクションを考慮した変数スコープの管理

### 主要関数の実装ガイド

#### 1. シャミア秘密分散法のシェア復元

```python
def lagrange_interpolation(shares, x_target, p):
    """
    ラグランジュ補間法を使用して多項式の値を計算

    Args:
        shares: シェアのリスト [(x1, y1), (x2, y2), ...]
        x_target: 計算対象のx座標（通常は0）
        p: 有限体の素数

    Returns:
        int: 補間された多項式の値 f(x_target)
    """
    # ラグランジュ補間法を実装
    # 有限体GF(p)上での計算に注意

def reconstruct_secret(shares, p):
    """
    閾値以上のシェアから秘密値を再構築

    Args:
        shares: 使用するシェアのリスト [(x1, y1), (x2, y2), ...]
        p: 有限体の素数

    Returns:
        int: 再構築された秘密値
    """
    # ラグランジュ補間法で多項式のf(0)を計算
```

#### 2. 復号関数

```python
def decrypt(encrypted_file, password, share_token):
    """
    暗号化ファイルを復号

    Args:
        encrypted_file: 暗号化されたファイルパス
        password: 復号に使用するパスワード
        share_token: 文書に対応するシェアトークン

    Returns:
        str: 復号されたJSON文書、または失敗時はNone
    """
    # 1. 暗号化ファイルを読み込み
    # 2. 二次暗号化を解除
    # 3. シェアトークンから占有領域MAPを構築
    # 4. パスワードから占有領域内のシェアを特定
    # 5. 適切なシェアを選択して秘密値を復元
    # 6. チャンクを元のデータに再構築
    # 7. 多段デコードを実行
    # 8. タイミング攻撃防止のため、全処理を同一時間で実行
```

#### 3. 補助関数

```python
def decrypt_file_data(encrypted_data, master_key):
    """
    暗号化されたファイルデータを復号（二次暗号の解除）

    Args:
        encrypted_data: 暗号化されたデータ
        master_key: 主暗号鍵（パスワードから導出）

    Returns:
        dict: 復号されたメタデータとシェアデータ
    """
    # AES-GCMなどによる認証付き復号を実行
    # 認証タグを検証して改ざんを検出

def build_occupation_map(share_token):
    """
    シェアトークンから占有領域MAPを構築

    Args:
        share_token: 使用するシェアトークン

    Returns:
        dict: 占有領域を示すマッピング
    """
    # シェアトークンから占有領域MAPを生成

def identify_shares(shares_data, occupation_map, password):
    """
    占有領域内のシェアを特定

    Args:
        shares_data: すべてのシェアデータ
        occupation_map: 占有領域マップ
        password: 使用するパスワード

    Returns:
        list: 特定されたシェアのリスト
    """
    # 占有領域内のシェアをパスワードを使って特定

def reconstruct_chunks(chunk_secrets, chunk_count):
    """
    復元された秘密値からチャンクを再構築

    Args:
        chunk_secrets: 各チャンクの復元された秘密値のリスト
        chunk_count: チャンク総数

    Returns:
        bytes: 再構築されたデータ
    """
    # 復元された秘密値からチャンクを再構築
    # チャンクを連結して元のデータを形成

def post_process_data(data):
    """
    データの後処理（多段デコード）

    Args:
        data: 処理対象のデータ

    Returns:
        str: デコード後のJSON文書
    """
    # Base64デコード
    # Latin-1からUTF-8へのデコード
    # JSON文書の検証

def secure_delete_temp_files(temp_file_path):
    """
    一時ファイルを安全に削除

    Args:
        temp_file_path: 削除する一時ファイルのパス

    Returns:
        bool: 削除が成功した場合はTrue
    """
    # 1. ファイルをゼロで上書き
    # 2. 続いてランダムデータで上書き
    # 3. ファイルサイズを0に切り詰め
    # 4. ファイルを削除
    # 各ステップでエラー処理
```

## 復号化プロセスの詳細

### 1. 暗号ファイルの読み込みと検証

```
暗号化ファイル読み込み
↓
ファイルフォーマットの検証（マジック、バージョン）
↓
パスワードから主暗号鍵を導出（KDFパラメータ使用）
↓
二次暗号の解除とデータの整合性検証
```

### 2. シェア特定と秘密値の復元

```
シェアトークンから占有領域MAPを生成
↓
パスワードを使用して占有領域内のシェアを特定
↓
各チャンクに対して:
  閾値以上のシェアを選択
  ↓
  ラグランジュ補間法による秘密値の復元
  ↓
  チャンク秘密値を保存
↓
チャンクを連結して元のデータを再構築
```

### 3. 多段デコードと文書復元

```
再構築されたデータをBase64デコード
↓
Latin-1からUTF-8へのデコード
↓
JSON文書の検証
```

## 実装上の注意点

### 1. セキュリティ考慮事項

- **タイミング攻撃対策**: パスワードが間違っている場合も同じ処理パスを通るよう実装
- **サイドチャネル攻撃対策**: 分岐処理を最小限に抑え、条件付き代入の使用を避ける
- **メモリ保護**: 使用後のメモリをゼロデータで上書き

### 2. 一時ファイル処理

- **シャミア保護**: 一時ファイルもシャミア秘密分散法で保護
- **固有識別子**: 一時ファイルは固有の UUID を使用して名前付け
- **安全な削除**: 使用後はゼロデータや乱数で上書きしてから削除
- **例外処理**: 処理中に例外が発生した場合も確実に一時ファイルを削除

### 3. エラー処理のガイドライン

- **最小情報の原則**: エラーメッセージは最小限の情報のみを提供
- **処理の継続**: 間違ったパスワードでも途中で処理を中断せず、同様の計算を続行
- **安全な比較**: 文字列比較には一定時間比較関数を使用

### 4. メモリ効率と大規模ファイル処理

- **チャンク処理**: 大きなファイルはチャンク単位で処理
- **メモリマッピング**: 必要に応じてメモリマッピングを使用
- **バッファリング**: ファイル操作にはバッファリングを適用

### 5. アップデート用パスワードの活用

- **アップデートマップ**: セキュリティ更新時にアップデート用パスワードと新しいシェアトークンで復号マップを形成
- **パスワードフラグ**: アップデート用パスワードを識別するフラグを設け、別処理を定義

### 6. 一時ファイルの安全な処理のための追加関数

```python
def secure_temporary_file(prefix="temp", suffix=".bin"):
    """
    安全な一時ファイルを作成

    Args:
        prefix: ファイル名の接頭辞
        suffix: ファイル名の接尾辞

    Returns:
        tuple: (file_obj, file_path) - ファイルオブジェクトとパス
    """
    # UUIDを生成
    # 安全なディレクトリパスを構築
    # 一時ファイルを作成
    # カスタムクリーンアップをセット

def secure_overwrite(file_path, passes=3):
    """
    ファイルを安全に上書きして削除

    Args:
        file_path: 削除するファイルのパス
        passes: 上書き回数

    Returns:
        bool: 成功した場合はTrue
    """
    # ファイルサイズを取得
    # 複数回の上書き処理
    # ファイルを切り詰めて削除

def clean_memory_variable(variable):
    """
    メモリ変数を安全にクリア

    Args:
        variable: クリアする変数（バイト列やリスト）
    """
    # 変数タイプに応じてゼロデータで上書き
    # 可能であれば明示的に解放
```

これらの関数を活用して、一時ファイルと機密メモリデータを安全に管理してください。一時ファイルの処理は情報漏洩防止の重要な要素です。
