# 暗号化モジュール実装ガイド

## 暗号化モジュールの目的

このモジュールは一度に一つの JSON 文書（A 文書または B 文書）を暗号化ファイルに変換します。核心となる多段 MAP 方式とシャミア秘密分散法を用いて、異なるパスワードで異なる文書を復号できるようにします。

**重要**: 両方の文書を一度に暗号化する処理は一切実装禁止です。必ず一文書ずつ個別に暗号化してください。

## 主要な機能と要件

### 1. 多段エンコードプロセス

JSON 文書は以下の多段エンコードプロセスを適用します：

1. UTF-8 テキスト（元の JSON）
2. Latin-1 へのエンコード変換
3. Base64 エンコード
4. 常に圧縮（条件判断なし）

### 2. シャミア秘密分散法の実装

- 多項式の次数と閾値：実用的な値として閾値`t=3`～`5`
- 有限体の選択：大きな素数`p`を用いた有限体 GF(p)上での計算
- 推奨： 文書サイズに応じて十分大きい素数を選択（例：2^256-189）

### 3. シェア ID 空間の設計と管理

- A 用と B 用のシェア ID は予め分割し、暗号化時にはそれらを使用するだけ
- 未割当領域には統計的に区別不能なランダムデータを生成
- シェア ID の分布は特定のパターンを形成しないよう設計（交互配置など）

### 4. 暗号化プロセスの全体フロー

```
データの前処理（多段エンコード）
↓
データをチャンクに分割
↓
各チャンクをシャミア秘密分散でシェア化
↓
未割当領域にゴミデータを生成
↓
シェアをシャッフル
↓
メタデータを追加して高度に暗号化されたファイル生成
```

## 実装時の制約とガイドライン

### 絶対条件

1. **識別情報の排除**:

   - どのシェアがどの文書（A または B）に属するかを示す情報を格納しない
   - すべてのメタデータは A/B 区別なく同一形式

2. **シェア値の統計的区別不可能性**:

   - A 文書のシェア、B 文書のシェア、未割当領域のゴミデータが統計的に区別できないこと
   - これは情報理論的安全性のために必須

3. **保存データの最小化と高度暗号化**:

   - シャミア秘密分散法で生成されたシェア値
   - 塩値（再計算不可能な乱数）
   - 復号に必要な最小限のメタデータ（閾値など）
   - シェア ID はユーザー入力として提供されるため保存不要
   - マッピング情報はパスワードとシェア ID から計算で再生成可能なため保存不要
   - 全データはバイナリ形式で高度に暗号化して保存

4. **UUID の使用**:
   - 暗号化ファイル、復号化ファイル、シェアなどには UUID を付与する
   - ファイル名に UUID を含めて重複による上書きを防止（例: `encrypted_{timestamp}_{uuid}.henc`）
   - 一時ファイルやバックアップファイルにも一意の識別子を使用

### 主要関数の実装ガイド

#### 1. シャミア秘密分散法の実装

```python
def generate_polynomial(secret, degree, p):
    """degree次の多項式を生成"""
    # 係数配列を生成（最初の要素は秘密値）
    # 乱数を用いて残りの係数を生成

def evaluate_polynomial(coef, x, p):
    """多項式の評価"""
    # 係数配列と評価点xから多項式の値を計算

def generate_shares(secret, t, n, p):
    """n個のシェアを生成、閾値はt"""
    # 多項式を生成し、各シェアIDに対する値を計算
```

#### 2. 暗号化関数

```python
def encrypt(json_doc, password, share_ids, unassigned_ids, threshold=3):
    """
    単一のJSON文書を暗号化

    Args:
        json_doc: 暗号化するJSON文書（A文書またはB文書の一方のみ）
        password: 文書に対応するパスワード
        share_ids: 文書に対応するシェアIDセット
        unassigned_ids: 未割当のシェアIDリスト
        threshold: シェア復元に必要な閾値

    Returns:
        bytes: 高度に暗号化されたバイナリデータ（UUIDを含む識別子付き）
    """
    # 1. 単一JSON文書のエンコード処理
    # 2. チャンクに分割
    # 3. 各チャンクをシェア化（識別不能に）
    # 4. 未割当領域にゴミデータ生成
    # 5. シェアをシャッフル
    # 6. UUIDを生成しメタデータに含める
    # 7. 全体を二次暗号化して高度なセキュリティを確保
```

#### 3. 補助関数

```python
def preprocess_data(json_doc):
    """JSON文書の前処理（多段エンコード）"""
    # UTF-8 → Latin-1 → Base64の多段エンコード

def split_into_chunks(data, chunk_size=64):
    """データを固定長チャンクに分割"""
    # データをチャンクに分割

def generate_chunk_shares(secret, threshold, share_ids, p):
    """チャンクのシェア生成"""
    # シャミアの多項式を使ってシェアを生成

def generate_garbage_shares(unassigned_ids, num_real_shares, p):
    """未割当領域のゴミデータ生成"""
    # 統計的に区別できないランダムデータ生成

def encrypt_file_data(data, master_key):
    """データを高度に暗号化"""
    # AES-GCMなどの認証付き暗号化を適用
    # ファイルフォーマットを構築

def generate_file_uuid():
    """ファイル用のUUIDを生成"""
    # UUID v4を生成
    # タイムスタンプを組み合わせてファイル識別に使用
    # 書式: {timestamp}_{uuid}の形式
```

### 出力形式

暗号化の結果は高度に暗号化されたバイナリファイル形式で、以下の構造を持ちます：

```
[ファイルマジック (8バイト)] - 固定識別子
[UUID (16バイト)] - ファイル固有識別子
[バージョン (2バイト)] - ファイル形式バージョン
[アルゴリズム識別子 (2バイト)] - 使用暗号化アルゴリズム
[KDFパラメータ (可変長)] - 鍵導出関数のパラメータ
[IV (16バイト)] - 初期化ベクトル
[暗号化メタデータ (可変長)] - 暗号化された復号必須情報
[暗号化シェアデータ (可変長)] - 暗号化されたシェア情報
[認証タグ (16バイト)] - GCMモード認証タグ
```

この暗号化されたメタデータには次の情報が含まれます（暗号化されている）:

```
- 塩値（Salt）
- チャンク総数
- 閾値
- 使用素数
- その他必要な情報（A/B識別情報は含まない）
```

## 実装上の注意点

1. **セキュアな乱数生成**:

   - `secrets`モジュールを使用して暗号学的に安全な乱数を生成

2. **素数の選択**:

   - 有限体演算に使用する素数は十分に大きく選ぶ
   - 素数サイズは扱うデータサイズに合わせて調整

3. **効率性とメモリ使用量**:

   - 大きなファイルでもメモリ効率よく処理できるよう設計
   - 入力サイズの 3-4 倍程度のメモリ使用に抑える

4. **二重暗号化**:

   - データ本体の暗号化に加え、ファイル全体を二次暗号化することで安全性を強化
   - パスワードと乱数ソルトから導出した鍵を使用

5. **カナリア値**:

   - 復号検証用のカナリア値を埋め込み、正しい復号を確認できるようにする
   - カナリア値自体も暗号化して格納

6. **ファイル命名と衝突回避**:
   - 出力ファイル名に UUID とタイムスタンプを含める（例: `encrypted_{timestamp}_{uuid}.henc`）
   - 一時ファイルとバックアップファイルにも異なる UUID を付与
   - UUID 生成には Python の`uuid`モジュールを使用
   - ファイル上書きによる情報漏洩を防止
