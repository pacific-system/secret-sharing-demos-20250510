# 実装計画と優先順位

## 設計理念への準拠を確保する実装手順

設計書の「多段 MAP」と「パーティション空間設計」に厳密に準拠するため、以下の順序で実装します：

1. **セキュリティ準拠の新しい形式実装** - 設計理念に完全準拠した新しいファイル形式を実装（後方互換性は一切考慮しない）
2. **初期化時の暗号化ファイル生成** - 初期化するたびに新たな UUID を持つ暗号ファイルを生成
3. **UUID によるファイル命名** - 利便性改善とセキュリティリスク低減
4. **ファイル A・B の混在保管実装** - 設計理念に忠実なファイル混在保管の明示的実装
5. **過去形式関連コードの完全削除** - 過去形式に関連するコードを完全に削除し、コードベースを浄化

## 過去形式関連コードの完全削除

セキュリティリスクを排除するため、過去形式に関連するコードとその関数は**コードベース内に一切残さない**こととします：

- **削除対象関数の例**:

  - `create_v1_format()`
  - `create_v2_format()`
  - `read_v1_format()`
  - `read_v2_format()`
  - `convert_v1_to_v2()`
  - `is_v1_format()`
  - `is_v2_format()`
  - その他、過去形式に関連するすべてのヘルパー関数

- **新しい形式のみの実装**:
  - 新たに`create_encrypted_format()`、`read_encrypted_format()`などの関数のみを実装
  - 変換関数も一切実装しない
  - 変換機能を要求するエラーが発生した場合はシステム移行手順書を別途用意

過去形式関連コードの一切が残っていないことを確認するため、次のコードレビュー手順を実施します：

```python
# 実装後のコードレビューで確認すべき項目
def code_review_remove_old_formats():
    """
    過去形式に関連するコードが完全に削除されていることを確認する
    """
    # 1. 過去形式の関数が存在しないことを確認
    assert not hasattr(module, "create_v1_format")
    assert not hasattr(module, "create_v2_format")
    assert not hasattr(module, "read_v1_format")
    assert not hasattr(module, "read_v2_format")

    # 2. 過去形式への変換関数が存在しないことを確認
    assert not hasattr(module, "convert_v1_to_v2")
    assert not hasattr(module, "convert_format")

    # 3. インポート文やコメントにも過去形式への言及がないことを確認
    source_code = inspect.getsource(module)
    assert "v1_format" not in source_code
    assert "v2_format" not in source_code

    # 4. 過去形式の識別コードが存在しないことを確認
    assert not hasattr(module, "is_v1_format")
    assert not hasattr(module, "is_v2_format")

    print("成功: すべての過去形式関連コードが完全に削除されています")
```

これにより、コードベース内に過去形式のコードが一切残らず、セキュリティリスクのある実装が混入する可能性を排除します。

## 最小限のヘッダー情報

シェアフォーマットにおいては、必要最小限のヘッダー情報のみを保持します：

1. **salt**: シェア生成に使用したソルト値

以下のメタデータは不要であり、セキュリティリスクとなるため含めません：

- **magic**: 固定値は暗号ファイルの特性を示す手がかりになるため削除
- **created_at**: 作成時刻はファイル解析の手がかりとなるリスクがある
- **share_id_space**: 配列のサイズから計算可能
- **total_chunks**: MAP からの導出または配列サイズで算出可能
- **threshold**: 多段 MAP から取得可能で、内部的にも導出できるため不要
- **file_type**: ファイル種別（A/B）はパーティションキーから導出可能であり、ファイルに含める必要がない
- **version**: 互換性は別の方法で処理するため不要

## 詳細実装手順

### ステップ 1: セキュリティ準拠の新しい形式実装

1. `create_encrypted_format()` 関数を作成し、新しい形式の暗号化ファイルを新規作成する機能を実装
2. `get_share_index()` 関数を作成し、多段 MAP から一次元配列内の位置を算出
3. share_id_space と total_chunks を MAP から取得するロジックを実装
4. 過去形式のファイルに対するエラーハンドリングを追加（変換は行わない）
5. 新しい形式のみをサポートする明確なエラーメッセージを実装
6. 過去形式関連の全コードを完全に削除

### ステップ 2: 初期化時の暗号化ファイル生成

1. `generate_empty_encrypted_file()` 関数を最小限ヘッダーの新しい形式で実装
2. 初期化のたびに新たな UUID を持つ暗号ファイルを生成する仕組みを実装
3. `init` コマンドにこの機能を統合
4. メタデータマネージャーの更新

### ステップ 3: UUID ファイル命名の実装

1. `generate_unique_filename()` 関数を `utils.py` に追加
2. すべてのファイル出力関数（暗号化、更新）にこの関数を適用
3. 時間情報を含まないファイル名形式を実装
4. コマンドライン引数の処理を更新

### ステップ 4: ファイル A・B の混在保管実装

1. `is_share_in_file_partition()` 関数を追加し、ファイル種別に応じたシェア領域をチェック
2. ファイル A とファイル B を同一の暗号ファイル内に混在して保管する機能を実装
3. コマンドラインインターフェースに `--file-type` オプションを追加
4. 暗号ファイル内でのファイル種別に応じたシェア保存機能を実装

### ステップ 5: 過去形式コードの削除確認

1. コードベース全体を検索し、過去形式関連の関数を特定
2. 該当する関数とそれに関連するすべてのコードを削除
3. インポート文やコメントを含め、過去形式への参照をすべて削除
4. 単体テストから過去形式のテストも削除
5. `code_review_remove_old_formats()` を実行して削除完了を確認

## 情報漏洩リスクの低減対策

実装全体を通して、以下の情報漏洩リスク低減対策を徹底します：

1. **ファイル内メタデータの最小化**: 必要最小限のヘッダー情報のみを保持
2. **ファイル名からの情報漏洩防止**: 時間情報を含まない UUID 命名の採用
3. **パーティションキーの非保存**: システム側でパーティションキーを一切保存しない
4. **多段 MAP 実装の徹底**: 全てのシェア位置を MAP から決定論的に導出
5. **ファイル種別の隠蔽**: ファイル名からファイル種別を識別できないようにする
6. **初期化・暗号化ファイルの区別不能**: 外部から初期化ファイルと暗号化済みファイルが区別できないようにする
7. **過去形式コードの完全排除**: コードベース内に過去形式関連コードを一切残さない

## 設計理念との整合性確認

各機能の実装後に以下の確認を行います：

1. **多段 MAP 決定論的生成確認**:

   - パーティションキーとパスワードのみからシェア位置が正確に特定できることを検証
   - 最小限ヘッダーのみで復号が正常に機能することを確認

2. **統計的区別不可能性検証**:

   - 初期化ファイルと実データ含有ファイルの統計的特性を比較
   - ファイル A/B/未割当の区別が統計的に不可能なことを検証

3. **パーティションキー非保存原則とメタデータ最小化**:

   - パーティションキーが一切システムに保存されないことを確認
   - 必要最小限のヘッダー情報のみでシステムが正常に動作することを確認
   - created_at やその他の冗長情報なしで正確にシェア位置が特定できることを検証

4. **ファイル混在保管の確認**:

   - ファイル A とファイル B が同一の暗号ファイル内に混在保管される仕組みが正しく機能することを確認
   - 各ファイル種別に対応するシェア領域が正しくマッピングされていることを検証
   - ファイル名からファイル種別が識別できないことを確認

5. **過去形式排除の確認**:

   - 過去形式のファイルが適切に拒否されることを確認
   - 過去形式から新しい形式への変換が提供されていないことを確認
   - 過去形式についての明確なエラーメッセージが表示されることを確認
   - コードベース内に過去形式関連コードが一切残っていないことを確認

6. **初期化・暗号化ファイル区別不能性の確認**:

   - 外部観察者が初期化ファイルと暗号化済みファイルを統計的・構造的に区別できないことを検証
   - ヘッダー情報のみから両ファイルタイプが識別できないことを確認
   - ファイルサイズや内部構造から区別できないことを検証

## テスト計画

1. **ユニットテスト**:

   - 各新機能に対するユニットテストを作成
   - 新しい形式によるファイル生成と読み取りテスト
   - MAP からの share_id_space と total_chunks 導出を検証
   - ファイル種別に応じたシェア配置の正確性を検証
   - 過去形式ファイルに対する適切なエラー処理の検証
   - 過去形式コードが削除されていることの検証

2. **統合テスト**:

   - 新しい形式のみを使用した暗号化 → 更新 → 復号のフルサイクルテスト
   - セキュリティ理念に準拠した実装テスト
   - 統計的区別不可能性テスト
   - ファイル A とファイル B の混在保管機能テスト
   - 初期化ファイルと暗号化ファイルの区別不能性テスト

3. **セキュリティテスト**:

   - 統計的区別不可能性のテスト
   - ファイルサイズ一貫性の検証
   - サイドチャネル耐性テスト
   - メタデータ最小化による情報漏洩防止効果の検証
   - ファイル名からの情報漏洩リスク検証
   - ファイル種別の隠蔽検証
   - 初期化ファイルと暗号化ファイルの区別不能性検証
   - 過去形式コードが完全に削除されていることの検証

## 成功基準

1. シェアフォーマットのサイズ効率: 新しい形式によるサイズ削減率 40%以上
2. セキュリティ基準への準拠度: 100%
3. 設計理念への準拠度: 100%
4. ユニットテスト成功率: 100%
5. 統計的区別不可能性: 未初期化/A/B/A+B 間の区別が統計的に不可能
6. 最小限ヘッダーのみでの正常動作: 100%
7. ファイル名からの情報漏洩リスク: 0%
8. ファイル混在保管の実装: ファイル A とファイル B が同一の暗号ファイル内に正しく保管されること
9. 過去形式の排除: 完全排除（変換機能なし）
10. 初期化・暗号化ファイルの区別不能性: 外部から両タイプのファイルが完全に区別不能であること
11. 過去形式コードの削除率: 100%（コードベースから完全に削除）

以上の実装により、システムのセキュリティと効率性が大幅に向上し、設計書の理念に完全準拠したシステムが実現します。過去形式との互換性を完全に排除することで、セキュリティ基準から逸脱した実装がシステムに混入することを防ぎます。最小限のメタデータのみを含むことで情報漏洩リスクが低減し、真に安全な暗号化システムが構築されます。また、ファイル A とファイル B が同一の暗号ファイル内に混在して保管される仕組みを明示的に実装することで、設計理念との一貫性を確保し、システムの意図通りの使用を促進します。さらに、初期化するたびに新たな UUID を持つ暗号ファイルが生成される設計により、誤って既存ファイルが上書きされるリスクを排除します。初期化ファイルと暗号化済みファイルが外部から区別できないようにすることで、システムのセキュリティをさらに強化し、どのファイルが実データを含んでいるかという情報漏洩を防止します。コードベース内からすべての過去形式関連コードを完全に削除することで、セキュリティ上の欠陥を含む古い実装が誤って使用されるリスクを排除し、クリーンで安全なコードベースを確保します。
