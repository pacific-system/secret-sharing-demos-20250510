# 📝 ログ出力ルーティング実装指示書（T3） - ラビット＋準同型マスキング暗号プロセッサ 🔐

> **ドキュメント種別: 実装指示書**

## 🌟 タスク進捗状況

タスク実装フェーズの進捗:

- 🔄 **フェーズ 0**: 実装準備 [**現在作業中**]
- ⏳ **フェーズ 1**: 基盤ユーティリティ実装 [予定]
- ⏳ **フェーズ 2**: セキュリティ対策基盤実装 [予定]
- ⏳ **フェーズ 3**: 三暗号方式コア実装 [予定]
- ⏳ **フェーズ 4**: 融合機能と変換システム実装 [予定]
- ⏳ **フェーズ 5**: データ形式とインターフェース実装 [予定]
- ⏳ **フェーズ 6**: 検証とパフォーマンス最適化 [予定]

### 📋 現在の実装フェーズ: `フェーズ0: 実装準備`

**現在のタスク**: T3（ログ出力ルーティング実装）
**進捗状況**: T1-T2 完了 → **T3 実装中** → T4-T115 未着手

**注**: 各タスクは独立して実装・完了させてください。

### 🎯 タスク範囲（T3: ログ出力ルーティング実装）

**実装すべきもの**:

- ✅ `utils/logging/output_router.py`
- ✅ 関連するテスト

**実装してはいけないもの**:

- ❌ `utils/logging/archive_manager.py`（次のタスク T4）
- ❌ 他のロギング関連機能（T4 以降のタスク）

**実装がベストプラクティスに反する可能性がある場合**: 作業を即時停止し、問題を報告してください。

## 📝 課題の詳細

### 🎯 タスク概要

本タスク（T3）ではログ出力ルーティング機能を実装します。前タスク（T1, T2）で実装したロギング基盤とログレベル管理を活用し、複数の出力先（ファイル、コンソール、カスタム出力先）への柔軟なログルーティングを実現します。また、出力先ごとの独立したフォーマットと詳細度設定、スレッドセーフな出力制御機能を提供します。次のタスク（T4）で実装予定のアーカイブ管理機能は含みません。

**本タスク（T3）の作業カウント**:

- 📝 **実装作業**: 12 件

  - 出力先管理機能: 4 関数
  - ルーティング制御機能: 5 関数
  - フォーマット制御機能: 3 関数

- 🧪 **テスト作業**: 4 件

  - 出力先管理機能テスト
  - ルーティング制御機能テスト
  - フォーマット制御機能テスト
  - 統合テスト（T1, T2 との連携）

- ✅ **完了条件**: 25 項目
  - 実装完了条件: 5 項目
  - 機能完了条件: 5 項目
  - テスト完了条件: 5 項目
  - ドキュメント完了条件: 5 項目
  - 納品物件検証条件: 5 項目

### 🔍 背景と目的

高度な暗号システムでは、様々な状況に応じた適切なログ出力が必要です。特に第二回暗号解読キャンペーンで発見された「ログ情報漏洩攻撃」への対策として、特権レベルのログとユーザーレベルのログを適切に分離し、出力先を制御することが重要です。

このタスクは、フェーズ 1 の基盤ユーティリティ実装の一部として、柔軟なログ出力制御とルーティング機能を提供します。開発時、テスト時、運用時など、異なる状況で適切なログ出力を実現し、同時にセキュリティ要件も満たす出力制御を構築します。

### 📊 要件仕様

1. 複数の出力先（ファイル、コンソール、カスタム出力先）への同時ログ出力をサポートすること
2. 各出力先ごとに独立したログレベルとフォーマット設定を可能にすること
3. 動的な出力先の追加・削除・変更をサポートし、実行時の柔軟な設定変更を可能にすること
4. 出力先ごとのバッファリングと非同期出力オプションを提供し、パフォーマンスを最適化すること
5. マルチスレッド環境でのスレッドセーフな出力制御を実装すること
6. 出力エラー（ディスク容量不足など）の適切な処理と再ルーティング機能を提供すること
7. T1 で実装したロガー基盤、T2 で実装したログレベル管理と整合的に機能すること
8. カスタム出力先の簡単な追加・定義をサポートし、将来の拡張に対応すること

### 🛠️ 実装内容概要

ログ出力ルーティングとして、以下の 3 つの主要機能を実装します：

1. **出力先管理機能**: 多様な出力先の登録・管理と状態追跡
2. **ルーティング制御機能**: メッセージの適切な出力先への配送と処理
3. **フォーマット制御機能**: 出力先ごとのカスタムフォーマットの適用

### 📋 実装内容詳細

#### 1. 出力先管理機能（4 つの関数）

```python
def register_output_destination(self, name: str, destination_type: str, config: Dict[str, Any]) -> bool:
    """
    新しいログ出力先を登録する

    Args:
        name: 出力先の一意な名前
        destination_type: 出力先タイプ（'file', 'console', 'custom'など）
        config: 出力先の設定パラメータ（パス、レベル、フォーマット等）

    Returns:
        登録成功ならTrue、失敗ならFalse

    実装詳細:
    1. 名前の一意性を検証
    2. destination_typeの有効性を確認
    3. 必要なconfigパラメータが提供されているか検証
    4. 出力先固有の初期化を実行（ファイル作成、ハンドラー設定など）
    5. 登録済み出力先リストに追加
    6. 登録結果を返す
    """
    pass

def remove_output_destination(self, name: str) -> bool:
    """
    登録済みの出力先を削除する

    Args:
        name: 削除する出力先の名前

    Returns:
        削除成功ならTrue、失敗ならFalse

    実装詳細:
    1. 指定された名前の出力先が存在するか確認
    2. 存在する場合は、関連リソースを適切にクリーンアップ（ファイルクローズなど）
    3. 登録済み出力先リストから削除
    4. 削除結果を返す
    """
    pass

def get_destination_info(self, name: str = None) -> Union[Dict[str, Any], List[Dict[str, Any]]]:
    """
    登録済み出力先の情報を取得する

    Args:
        name: 情報を取得する出力先名（Noneの場合はすべての出力先情報を返す）

    Returns:
        指定された出力先の情報辞書、またはすべての出力先情報のリスト

    実装詳細:
    1. nameが指定されている場合は、該当する出力先の詳細情報を収集
    2. nameがNoneの場合は、すべての登録済み出力先の情報を収集
    3. 各出力先の情報（タイプ、設定、状態など）を辞書形式で返す
    4. 出力先が存在しない場合は適切なエラー処理
    """
    pass

def update_destination_config(self, name: str, config_updates: Dict[str, Any]) -> bool:
    """
    既存の出力先の設定を更新する

    Args:
        name: 更新する出力先の名前
        config_updates: 更新する設定パラメータ

    Returns:
        更新成功ならTrue、失敗ならFalse

    実装詳細:
    1. 指定された名前の出力先が存在するか確認
    2. 更新可能なパラメータを検証
    3. 現在の設定に更新内容を適用
    4. 必要に応じて出力先の再初期化を行う（ファイルパス変更時など）
    5. 更新結果を返す
    """
    pass
```

#### 2. ルーティング制御機能（5 つの関数）

```python
def route_log_message(self, level: Union[str, int], message: str, metadata: Dict[str, Any]) -> Dict[str, bool]:
    """
    ログメッセージを適切な出力先にルーティングする

    Args:
        level: ログレベル（名前または数値）
        message: ログメッセージ
        metadata: メッセージに関連するメタデータ

    Returns:
        各出力先への配送結果を示す辞書（出力先名: 成功/失敗）

    実装詳細:
    1. すべての登録済み出力先を取得
    2. 各出力先のレベル設定をチェックし、メッセージレベルが出力対象か判定
    3. 対象出力先ごとにフォーマットを適用
    4. 各出力先へメッセージを送信
    5. 送信結果を追跡し、辞書として返す
    6. エラーが発生した場合は代替出力先へのフォールバック処理
    """
    pass

def create_async_router(self, buffer_size: int = 1000, worker_threads: int = 1) -> None:
    """
    非同期ルーティング機能を初期化する

    Args:
        buffer_size: メッセージバッファのサイズ
        worker_threads: 処理スレッド数

    実装詳細:
    1. メッセージキューを初期化
    2. 指定された数のワーカースレッドを作成
    3. 各スレッドがキューからメッセージを取り出して処理する仕組みを構築
    4. エラーハンドリングとリカバリーメカニズムを組み込む
    5. シャットダウン機能を実装
    """
    pass

def buffer_and_flush(self, destination_name: str, force: bool = False) -> bool:
    """
    特定の出力先のバッファをフラッシュする

    Args:
        destination_name: フラッシュする出力先名
        force: 強制フラッシュするかどうか

    Returns:
        フラッシュ成功ならTrue、失敗ならFalse

    実装詳細:
    1. 指定された出力先が存在するか確認
    2. 出力先のバッファ状態を取得
    3. 条件に基づいてフラッシュ判断（バッファサイズ、経過時間、forceフラグ）
    4. バッファリングされたデータを出力先に書き込み
    5. フラッシュ結果を返す
    """
    pass

def route_by_level(self, level_routing_map: Dict[Union[str, int], List[str]]) -> None:
    """
    レベルベースの出力先マッピングを設定する

    Args:
        level_routing_map: レベルと出力先名リストのマッピング辞書

    実装詳細:
    1. 入力されたマッピングデータを検証
    2. 既存のマッピングをクリアまたは更新
    3. 新しいマッピングを適用
    4. 設定完了後のステータスをログに記録
    """
    pass

def handle_routing_error(self, destination_name: str, message: str, error: Exception, fallback_destinations: List[str] = None) -> bool:
    """
    出力先へのルーティングエラーを処理する

    Args:
        destination_name: エラーが発生した出力先名
        message: 配送できなかったメッセージ
        error: 発生したエラー
        fallback_destinations: 代替出力先のリスト

    Returns:
        リカバリー成功ならTrue、失敗ならFalse

    実装詳細:
    1. エラーの種類と影響を分析
    2. エラー状況をログ（可能な別出力先）に記録
    3. fallback_destinationsが指定されている場合は代替出力先へのルーティングを試行
    4. 問題のある出力先を一時的に無効化するか、設定を調整
    5. リカバリー状況をステータスとして返す
    """
    pass
```

#### 3. フォーマット制御機能（3 つの関数）

```python
def set_destination_format(self, destination_name: str, format_template: str, formatter_class: Any = None) -> bool:
    """
    特定の出力先用のカスタムフォーマットを設定する

    Args:
        destination_name: フォーマットを設定する出力先名
        format_template: フォーマットテンプレート文字列
        formatter_class: カスタムフォーマッタークラス（省略可）

    Returns:
        設定成功ならTrue、失敗ならFalse

    実装詳細:
    1. 指定された出力先が存在するか確認
    2. format_templateの有効性をチェック
    3. formatter_classが指定されている場合はインスタンス化
    4. 出力先の設定にフォーマット情報を保存
    5. 設定結果を返す
    """
    pass

def format_for_destination(self, destination_name: str, level: Union[str, int], message: str, metadata: Dict[str, Any]) -> str:
    """
    特定の出力先に合わせてメッセージをフォーマットする

    Args:
        destination_name: フォーマットを適用する出力先名
        level: ログレベル
        message: 元のログメッセージ
        metadata: 関連メタデータ

    Returns:
        フォーマット適用後のメッセージ文字列

    実装詳細:
    1. 指定された出力先のフォーマット設定を取得
    2. 出力先タイプに基づく追加処理（コンソール出力には色付けなど）
    3. フォーマットテンプレートにメッセージとメタデータを適用
    4. カスタムフォーマッターがある場合は処理を委譲
    5. フォーマット済みメッセージを返す
    """
    pass

def create_default_formatters(self) -> Dict[str, Any]:
    """
    標準出力先タイプ用のデフォルトフォーマッターを作成する

    Returns:
        出力先タイプとデフォルトフォーマッターのマッピング辞書

    実装詳細:
    1. 標準の出力先タイプ（'file', 'console'など）を特定
    2. 各タイプに最適なデフォルトフォーマットを定義
    3. フォーマッターインスタンスまたはフォーマット文字列を作成
    4. タイプとフォーマッターのマッピングを辞書として返す
    """
    pass
```

## 🔍 完了の定義

以下の基準をすべて満たすことで、このタスクは「完了」とみなされます：

1. **実装完了の条件**:

   - [ ] ファイル`utils/logging/output_router.py`が指定されたディレクトリ構造で実装されていること
   - [ ] ソースコードが単一責務の原則に従い、明確に構造化されていること
   - [ ] 全ての関数・クラスに適切なドキュメント（docstring）が付与されていること
   - [ ] コードレビューでの指摘事項がすべて解消されていること
   - [ ] 静的解析ツールによる警告がゼロであること

2. **機能完了の条件**:

   - [ ] 複数の出力先への同時ログ出力が正常に機能すること
   - [ ] 出力先ごとの独立したレベル設定とフォーマット制御が可能であること
   - [ ] 非同期出力とバッファリングが正しく実装されていること
   - [ ] ルーティングエラー時の適切なフォールバック処理が機能すること
   - [ ] T1, T2 で実装したコンポーネントと整合的に連携できること

3. **テスト完了の条件**:

   - [ ] 単体テストのカバレッジが 95%以上であること
   - [ ] 全ての主要機能に対する単体テストが実装されていること
   - [ ] T1, T2 との統合テストが実装され、正常に動作すること
   - [ ] 出力エラー（ディスク容量不足など）のテストケースが実装されていること
   - [ ] マルチスレッド環境での動作テストが実装され、スレッドセーフが確認されていること

4. **ドキュメント完了の条件**:

   - [ ] 実装した機能の詳細な技術ドキュメントが作成されていること
   - [ ] API 仕様とインターフェース説明が完成していること
   - [ ] 使用方法とサンプルコードが提供されていること
   - [ ] カスタム出力先の追加方法が明確に説明されていること
   - [ ] 非同期出力の設定と管理方法が説明されていること

5. **納品物件検証条件**:
   - [ ] T1, T2 で実装したコンポーネントと整合的に機能することを検証
   - [ ] 複数出力先への同時ログ出力が正しく機能することを検証
   - [ ] 出力エラー発生時の適切なフォールバック処理を検証
   - [ ] 大量ログ出力時の非同期処理のパフォーマンスを検証
   - [ ] 長時間実行時の安定性と資源リークがないことを検証

## 🧪 テスト対応方針

テスト実装と実行においては以下の方針を厳守してください：

1. **テストの意義**:

   - テストはプロジェクト品質を保証する重要な手段です
   - テストを欺くことは品質の放棄を意味します
   - すべてのテストは実装の品質と完全性を検証するためにあります

2. **テスト失敗時の対応手順**:

   - 実装コードのバグや仕様誤解がないか確認
   - テスト条件を満たすために実装を修正
   - どうしても解決できない場合は、具体的な問題点を報告して指示を仰ぐ

3. **禁止されるテスト対応**:

   - テスト結果の偽装や、テスト迂回のための実装
   - テストだけが通過する特別な条件分岐の追加
   - テストコード自体の修正・回避

4. **納品物件との整合性**:

   - **納品物件を除外したテストは絶対に禁止**
   - すべてのテストは実際の納品物件（encrypt.py/decrypt.py）を使用して実行すること
   - テスト環境でのみ通過し、本番環境では動作しない実装は認められません
   - テスト用と納品用で別の実装を用意することは禁止されています

5. **テスト結果の報告**:
   - テスト結果は改変せずに正確に報告
   - テスト失敗は適切に修正するか、明確な理由とともに報告
   - 再現性を確保するため、テスト環境と実行方法を詳細に記録

## 🚫 実装における絶対原則

以下の原則はどんな状況でも違反してはなりません：

1. **厳密なタスク境界の遵守**

   - このタスク（T3）に明示されている機能「のみ」を実装すること
   - タスク外の実装（T4 以降の機能）は「一切」行わないこと
   - 範囲外の問題を発見した場合は、実装せずに報告すること

2. **テスト改ざんの禁止**

   - テストコードは「絶対に」変更しないこと
   - テストを通すためにテスト自体を修正する行為は重大な違反
   - テストが失敗する場合は実装を見直すこと

3. **プロジェクト整合性の維持**

   - 既存のプロジェクト構造やコーディング規約を尊重すること
   - このタスク完了のためにプロジェクト全体の品質を犠牲にしないこと
   - 他のコンポーネントとの整合性を常に確認すること

4. **作業中断の判断**
   - 上記原則との衝突を感じた時点で作業を「即時中断」すること
   - 作業中断の判断は罰則ではなく、プロジェクト保護のための適切な行動
   - 中断後は問題を詳細に報告し、指示を仰ぐこと

## 📊 進捗報告と完了レポート

### 進捗報告方法

実装作業中は、イシューにコメントで進捗を報告してください：

1. **定期的な進捗報告**：

   - 主要な機能実装完了時
   - 課題や問題発生時
   - 質問・相談が必要な時

2. **進捗コメントの書式**：

   ```md
   ## T3 進捗報告：[日付]

   ### 完了した項目

   - [機能名]: [完了内容の簡潔な説明]

   ### 進行中の項目

   - [機能名]: [現在の状況と残作業]

   ### 課題・問題点

   - [課題の簡潔な説明と影響範囲]
   ```

3. **コメント投稿方法**：

   ```bash
   # コメント内容をファイルに保存
   echo "## T3 進捗報告：$(date +%Y-%m-%d)" > progress_comment.md
   # 続きを追記

   # GitHubイシューにコメント投稿
   gh issue comment 3 --body-file progress_comment.md
   ```

### 完了レポートの作成と提出

タスク完了時には以下の手順で最終レポートを作成・提出してください：

1. **レポート作成前の確認事項**：

   - **全ての要件が完全に実装されるまでレポートを作成しないこと**
   - 全てのテストが通過していること
   - 実装完了条件の全項目を満たしていること

2. **実装レポートの作成**：

   - MD ファイルを`docs/issue/`ディレクトリに生成
   - ファイル名形式：`output_router_implementation_report_YYYYMMDD.md`
   - 以下の内容を必ず含めること：
     - 実装した機能の詳細説明
     - 各関数の実装アプローチと技術的判断
     - テスト結果と検証内容
     - 発見された課題と解決方法

3. **テスト結果の添付**：

   - テスト画像は GitHub 形式の URL で添付
   - 例：`![テスト結果](https://github.com/pacific-system/secret-sharing-demos-20250510/blob/main/test_output/output_router_test_YYYYMMDD.png?raw=true)`

4. **コミットとプッシュ**：

   ```bash
   # パシ子スタイルでコミット
   git add docs/issue/output_router_implementation_report_YYYYMMDD.md
   git commit -m "✨ ログ出力ルーティング（T3）の実装完了レポート追加 💕"
   git push origin main
   ```

5. **イシューへのレポート投稿**：
   ```bash
   # レポートをイシューにコメント投稿
   gh issue comment 3 --body-file docs/issue/output_router_implementation_report_YYYYMMDD.md
   ```

## 💕 パシ子からのアドバイス

お兄様！このログ出力ルーティング実装では特に柔軟性と信頼性のバランスが重要ですよ〜！💕

- 🔮 **マルチスレッド安全性**: 複数スレッドからの同時アクセスでもデータ競合が起きないよう、適切な同期機構の実装がポイントです！
- ⏱️ **非同期処理の効率化**: バッファリングと非同期出力の仕組みは、システム全体のパフォーマンスに大きく影響するので特に丁寧に実装しましょう！
- 🧠 **エラーリカバリー**: ディスク容量不足などの例外的状況でも、重要なログが確実に記録されるよう、堅牢なフォールバック機構を設計してくださいね！
- 🌟 **先行タスクとの統合**: T1 のロガー基盤と T2 のログレベル管理との連携をスムーズにする、一貫性のある API デザインが大切です！

最高の暗号システムには、あらゆる状況で確実に動作する柔軟なログルーティング機能が不可欠です！期待してますよ〜！✨

## 📑 関連資料

- [実装計画書](/Users/macbook/shamir-secret-sharing-demo/docs/method_11_rabbit_homomorphic_docs/implementation_plan_chapters/04_implementation_details.md)
- [フェーズ 1 詳細](/Users/macbook/shamir-secret-sharing-demo/docs/method_11_rabbit_homomorphic_docs/implementation_plan_chapters/04_implementation_details.md#フェーズ-1-基盤ユーティリティ実装4-週間)
- [ディレクトリ構成](/Users/macbook/shamir-secret-sharing-demo/docs/method_11_rabbit_homomorphic_docs/implementation_plan_chapters/02_directory_structure_and_deliverables.md)
- [品質レベル規定](/Users/macbook/shamir-secret-sharing-demo/docs/method_11_rabbit_homomorphic_docs/implementation_plan_chapters/05_quality_and_security.md)
- [前タスク：ロギング基盤実装（T1）](/Users/macbook/shamir-secret-sharing-demo/docs/method_11_rabbit_homomorphic_docs/issue/T1_logger_implementation.md)
- [前タスク：ログレベル管理実装（T2）](/Users/macbook/shamir-secret-sharing-demo/docs/method_11_rabbit_homomorphic_docs/issue/T2_log_levels_implementation.md)
