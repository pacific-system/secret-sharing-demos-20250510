# 📝 ロギング基盤実装指示書（T1） - ラビット＋準同型マスキング暗号プロセッサ 🔐

> **ドキュメント種別: 実装指示書**

## 🌟 タスク進捗状況

タスク実装フェーズの進捗:

- 🔄 **フェーズ 0**: 実装準備 [**現在作業中**]
- ⏳ **フェーズ 1**: 基盤ユーティリティ実装 [予定]
- ⏳ **フェーズ 2**: セキュリティ対策基盤実装 [予定]
- ⏳ **フェーズ 3**: 三暗号方式コア実装 [予定]
- ⏳ **フェーズ 4**: 融合機能と変換システム実装 [予定]
- ⏳ **フェーズ 5**: データ形式とインターフェース実装 [予定]
- ⏳ **フェーズ 6**: 検証とパフォーマンス最適化 [予定]

### 📋 現在の実装フェーズ: `フェーズ0: 実装準備`

**現在のタスク**: T1（ロギング基盤実装）
**進捗状況**: 開始 → **T1 実装中** → T2-T115 未着手

**注**: 各タスクは独立して実装・完了させてください。

### 🎯 タスク範囲（T1: ロギング基盤実装）

**実装すべきもの**:

- ✅ `utils/logging/logger.py`
- ✅ 関連するテスト

**実装してはいけないもの**:

- ❌ `utils/logging/log_levels.py`（次のタスク T2）
- ❌ 他のロギング関連機能（T2 以降のタスク）

**実装がベストプラクティスに反する可能性がある場合**: 作業を即時停止し、問題を報告してください。

## 📝 課題の詳細

### 🎯 タスク概要

本タスク（T1）ではロギング基盤を実装します。このロギング基盤は他の全モジュールの依存基盤となる最重要コンポーネントです。タイムスタンプ付きログ出力機能と階層化ロギング構造を実装し、多層的な診断情報を安全に記録する土台を構築します。次のタスク（T2）で実装予定のログレベル管理は含みません。

**本タスク（T1）の作業カウント**:

- 📝 **実装作業**: 12 件

  - 基本ロガー機能: 5 関数
  - ログフォーマット機能: 3 関数
  - ログ出力先制御機能: 4 関数

- 🧪 **テスト作業**: 4 件

  - 基本ロガー機能テスト
  - ログフォーマット機能テスト
  - ログ出力先制御機能テスト
  - 統合テスト（全機能連携）

- ✅ **完了条件**: 25 項目
  - 実装完了条件: 5 項目
  - 機能完了条件: 5 項目
  - テスト完了条件: 5 項目
  - ドキュメント完了条件: 5 項目
  - 納品物件検証条件: 5 項目

### 🔍 背景と目的

本プロジェクトの核心的なセキュリティ要件を満たすためには、情報漏洩を防止しながら高品質な診断情報を提供できるロギング基盤が不可欠です。特に第二回暗号解読キャンペーンで発見された「ログ情報漏洩攻撃」の脆弱性に対応するため、経路情報を漏洩しない安全なログシステムの基盤を構築します。

このタスクはフェーズ 0 の最初に位置し、他のすべてのコンポーネントから利用される基盤機能を提供します。安全かつ効率的なロギング機能は、開発、デバッグ、運用の全段階で暗号処理の正確性検証と問題診断に不可欠です。

### 📊 要件仕様

1. 複数のログレベル（ERROR, WARNING, INFO, DEBUG, TRACE）に対応する拡張可能な基盤を提供すること
2. すべてのログにタイムスタンプを付与し、上書きが発生しない設計とすること
3. ログ出力先（ファイル、コンソール、両方）を柔軟に設定できる機能を提供すること
4. ログメッセージの構造化フォーマットをサポートし、機械可読性を確保すること
5. 経路情報（正規/非正規）が漏洩しない安全な設計を実現すること
6. パフォーマンスに配慮し、高負荷時でも処理速度に影響を与えない効率的な実装とすること
7. 他のモジュールからの依存性を考慮した、明確で使いやすい API を提供すること
8. ログファイルを日付別・種類別に整理し、長期保存のためのアーカイブ機能の基盤を提供すること

### 🛠️ 実装内容概要

ロギング基盤として、以下の 3 つの主要機能を実装します：

1. **基本ロガー機能**: 様々なソースからのログ情報を受け取り、適切に処理する中核機能
2. **ログフォーマット機能**: ログメッセージを構造化された形式に変換し、一貫性を確保する機能
3. **ログ出力先制御機能**: 設定に基づいてログの出力先（ファイル/コンソール）を柔軟に制御する機能

### 📋 実装内容詳細

#### 1. 基本ロガー機能（5 つの関数）

```python
def __init__(self, name: str, log_level: int = None, log_file: str = None, console_output: bool = True) -> None:
    """
    ロガーインスタンスを初期化する

    Args:
        name: ロガー名（通常はモジュール名）
        log_level: ログレベル（Noneの場合、デフォルト設定を使用）
        log_file: ログファイルパス（Noneの場合、デフォルトパスを生成）
        console_output: コンソール出力の有無

    実装詳細:
    1. ロガー名、ログレベル、ログファイルパス、コンソール出力設定を保存
    2. タイムスタンプ付きのデフォルトログファイルパスを生成（log_fileがNoneの場合）
    3. ログファイルディレクトリが存在しない場合は作成
    4. ログハンドラ（ファイル・コンソール）を初期化
    5. 初期化完了時にINFOレベルでログ開始メッセージを記録
    """
    pass

def log(self, level: int, message: str, module: str = None, **kwargs) -> None:
    """
    指定されたレベルでログメッセージを記録する基本メソッド

    Args:
        level: ログレベル
        message: ログメッセージ
        module: 呼び出し元モジュール名（Noneの場合、自動検出）
        **kwargs: 追加の構造化データ

    実装詳細:
    1. 現在の設定レベルより低いレベルのログはスキップ
    2. 呼び出し元モジュールが指定されていない場合は自動検出
    3. メッセージを構造化フォーマットに変換
    4. すべての設定済みハンドラにメッセージを送信
    5. 例外が発生した場合は、内部エラーとして標準エラー出力に記録
    """
    pass

def set_level(self, level: int) -> None:
    """
    ロガーのログレベルを設定する

    Args:
        level: 新しいログレベル

    実装詳細:
    1. 有効な範囲内のレベル値かチェック
    2. ロガーの内部レベル設定を更新
    3. レベル変更をINFOレベルでログに記録
    4. すべてのハンドラに新しいレベルを反映
    """
    pass

def add_file_handler(self, file_path: str, level: int = None) -> None:
    """
    追加のファイルハンドラを登録する

    Args:
        file_path: ログファイルパス
        level: このハンドラ固有のログレベル（Noneの場合、ロガーのデフォルトレベルを使用）

    実装詳細:
    1. ファイルパスのディレクトリが存在しない場合は作成
    2. 新しいファイルハンドラを作成し、フォーマッタを設定
    3. ハンドラ固有のログレベルを設定
    4. ハンドラをロガーに追加
    5. 新しいハンドラの追加をINFOレベルでログに記録
    """
    pass

def remove_handlers(self) -> None:
    """
    すべてのハンドラを削除し、ロギングをクリーンアップする

    Args:
        なし

    実装詳細:
    1. すべてのファイルハンドラをフラッシュして閉じる
    2. すべてのハンドラをロガーから削除
    3. ハンドラ削除をINFOレベルで記録（標準エラー出力を使用）
    4. 内部ハンドラリストをクリア
    """
    pass
```

#### 2. ログフォーマット機能（3 つの関数）

```python
def format_log_message(self, level: int, message: str, module: str = None, **kwargs) -> str:
    """
    ログメッセージを構造化された文字列に変換する

    Args:
        level: ログレベル
        message: 元のログメッセージ
        module: ログソースモジュール
        **kwargs: 追加の構造化データ

    Returns:
        フォーマット済みのログメッセージ文字列

    実装詳細:
    1. 現在のタイムスタンプを取得
    2. レベル名をレベル数値から解決
    3. 基本情報（時間、レベル、モジュール、メッセージ）を含む辞書を作成
    4. 追加データ（kwargs）を辞書に統合
    5. 経路情報などのセキュリティセンシティブなデータをフィルタリング
    6. フォーマットタイプに基づいて辞書を文字列に変換（JSON形式など）
    """
    pass

def get_level_name(self, level: int) -> str:
    """
    数値ログレベルを人間可読な文字列に変換する

    Args:
        level: ログレベル数値

    Returns:
        ログレベル名

    実装詳細:
    1. 内部レベルマッピングから対応する名前を取得
    2. 未知のレベルの場合は「UNKNOWN」と数値を組み合わせた文字列を返す
    """
    pass

def sanitize_log_data(self, data: Dict[str, Any]) -> Dict[str, Any]:
    """
    ログデータから機密情報を除去する

    Args:
        data: 元のログデータ辞書

    Returns:
        機密情報が除去されたログデータ辞書

    実装詳細:
    1. 入力辞書のコピーを作成
    2. 禁止キーワードリスト（"path", "is_true_file", "route"など）をチェック
    3. 禁止キーワードを含むキーを検出
    4. 検出されたキーをデータから削除または[REDACTED]に置換
    5. 安全なデータを返す
    """
    pass
```

#### 3. ログ出力先制御機能（4 つの関数）

```python
def _setup_file_handler(self, file_path: str, level: int = None) -> Any:
    """
    ファイルハンドラを設定する

    Args:
        file_path: ログファイルパス
        level: ハンドラのログレベル

    Returns:
        設定済みのファイルハンドラ

    実装詳細:
    1. ログディレクトリが存在しない場合は作成
    2. ファイルハンドラを作成（追記モード）
    3. ハンドラにフォーマッタを設定
    4. ハンドラに指定されたログレベルを設定
    5. 設定済みハンドラを返す
    """
    pass

def _setup_console_handler(self, level: int = None) -> Any:
    """
    コンソールハンドラを設定する

    Args:
        level: ハンドラのログレベル

    Returns:
        設定済みのコンソールハンドラ

    実装詳細:
    1. 標準出力ストリームを使用するハンドラを作成
    2. ハンドラにフォーマッタを設定
    3. ハンドラに指定されたログレベルを設定
    4. 設定済みハンドラを返す
    """
    pass

def generate_log_filename(self, base_name: str = None) -> str:
    """
    タイムスタンプ付きのログファイル名を生成する

    Args:
        base_name: 基本ファイル名（Noneの場合、ロガー名を使用）

    Returns:
        タイムスタンプ付きのログファイルパス

    実装詳細:
    1. 現在の日時を取得
    2. base_nameが指定されていない場合、ロガー名をファイル名として使用
    3. 年月日_時分秒形式のタイムスタンプを生成
    4. ログディレクトリパスとタイムスタンプを組み合わせてファイルパスを生成
    5. 生成したパスを返す
    """
    pass

def ensure_log_directory(self, directory_path: str) -> None:
    """
    ログディレクトリが存在することを確認し、必要に応じて作成する

    Args:
        directory_path: 確認/作成するディレクトリパス

    実装詳細:
    1. ディレクトリパスの有効性を確認
    2. ディレクトリが存在しない場合は作成（親ディレクトリも必要に応じて作成）
    3. 作成に失敗した場合は適切な例外を発生
    4. ディレクトリの書き込み権限を確認
    """
    pass
```

## 🔍 完了の定義

以下の基準をすべて満たすことで、このタスクは「完了」とみなされます：

1. **実装完了の条件**:

   - [ ] ファイル`utils/logging/logger.py`が指定されたディレクトリ構造で実装されていること
   - [ ] ソースコードが単一責務の原則に従い、明確に構造化されていること
   - [ ] 全ての関数・クラスに適切なドキュメント（docstring）が付与されていること
   - [ ] コードレビューでの指摘事項がすべて解消されていること
   - [ ] 静的解析ツールによる警告がゼロであること

2. **機能完了の条件**:

   - [ ] 基本ロガー機能が完全に実装され、すべての仕様を満たしていること
   - [ ] ログフォーマット機能が正しく実装され、構造化ログ出力が可能であること
   - [ ] ログ出力先制御機能が動作し、複数の出力先に対応できること
   - [ ] 全ての実装が他のモジュールから使用可能な状態であること
   - [ ] タイムスタンプ付きログファイルが重複なく生成されること

3. **テスト完了の条件**:

   - [ ] 単体テストのカバレッジが 95%以上であること
   - [ ] 全ての主要機能に対する単体テストが実装されていること
   - [ ] エッジケース（ディレクトリ存在しない、権限不足など）のテストが実装されていること
   - [ ] スレッド安全性のテストが実装されていること
   - [ ] パフォーマンステスト（大量ログ生成時の動作）が実装されていること

4. **ドキュメント完了の条件**:

   - [ ] 実装した機能の詳細な技術ドキュメントが作成されていること
   - [ ] API 仕様とインターフェース説明が完成していること
   - [ ] 使用方法とサンプルコードが提供されていること
   - [ ] 潜在的な問題点と対処法に関するドキュメントが提供されていること
   - [ ] 他のモジュールからの利用パターンが明確に説明されていること

5. **納品物件検証条件**:
   - [ ] 他のモジュールから正しくインポートして使用できること
   - [ ] 複数のログレベルで正常に動作することを検証
   - [ ] 大量のログ出力時でも安定して動作すること
   - [ ] 長時間実行時の挙動が安定していること
   - [ ] ディスク容量不足などの例外的状況でも適切に動作すること

## 🧪 テスト対応方針

テスト実装と実行においては以下の方針を厳守してください：

1. **テストの意義**:

   - テストはプロジェクト品質を保証する重要な手段です
   - テストを欺くことは品質の放棄を意味します
   - すべてのテストは実装の品質と完全性を検証するためにあります

2. **テスト失敗時の対応手順**:

   - 実装コードのバグや仕様誤解がないか確認
   - テスト条件を満たすために実装を修正
   - どうしても解決できない場合は、具体的な問題点を報告して指示を仰ぐ

3. **禁止されるテスト対応**:

   - テスト結果の偽装や、テスト迂回のための実装
   - テストだけが通過する特別な条件分岐の追加
   - テストコード自体の修正・回避

4. **納品物件との整合性**:

   - **納品物件を除外したテストは絶対に禁止**
   - すべてのテストは実際の納品物件（encrypt.py/decrypt.py）を使用して実行すること
   - テスト環境でのみ通過し、本番環境では動作しない実装は認められません
   - テスト用と納品用で別の実装を用意することは禁止されています

5. **テスト結果の報告**:
   - テスト結果は改変せずに正確に報告
   - テスト失敗は適切に修正するか、明確な理由とともに報告
   - 再現性を確保するため、テスト環境と実行方法を詳細に記録

## 🚫 実装における絶対原則

以下の原則はどんな状況でも違反してはなりません：

1. **厳密なタスク境界の遵守**

   - このタスク（T1）に明示されている機能「のみ」を実装すること
   - タスク外の実装（T2 以降の機能）は「一切」行わないこと
   - 範囲外の問題を発見した場合は、実装せずに報告すること

2. **テスト改ざんの禁止**

   - テストコードは「絶対に」変更しないこと
   - テストを通すためにテスト自体を修正する行為は重大な違反
   - テストが失敗する場合は実装を見直すこと

3. **プロジェクト整合性の維持**

   - 既存のプロジェクト構造やコーディング規約を尊重すること
   - このタスク完了のためにプロジェクト全体の品質を犠牲にしないこと
   - 他のコンポーネントとの整合性を常に確認すること

4. **作業中断の判断**
   - 上記原則との衝突を感じた時点で作業を「即時中断」すること
   - 作業中断の判断は罰則ではなく、プロジェクト保護のための適切な行動
   - 中断後は問題を詳細に報告し、指示を仰ぐこと

## 📊 進捗報告と完了レポート

### 進捗報告方法

実装作業中は、イシューにコメントで進捗を報告してください：

1. **定期的な進捗報告**：

   - 主要な機能実装完了時
   - 課題や問題発生時
   - 質問・相談が必要な時

2. **進捗コメントの書式**：

   ```md
   ## T1 進捗報告：[日付]

   ### 完了した項目

   - [機能名]: [完了内容の簡潔な説明]

   ### 進行中の項目

   - [機能名]: [現在の状況と残作業]

   ### 課題・問題点

   - [課題の簡潔な説明と影響範囲]
   ```

3. **コメント投稿方法**：

   ```bash
   # コメント内容をファイルに保存
   echo "## T1 進捗報告：$(date +%Y-%m-%d)" > progress_comment.md
   # 続きを追記

   # GitHubイシューにコメント投稿
   gh issue comment 1 --body-file progress_comment.md
   ```

### 完了レポートの作成と提出

タスク完了時には以下の手順で最終レポートを作成・提出してください：

1. **レポート作成前の確認事項**：

   - **全ての要件が完全に実装されるまでレポートを作成しないこと**
   - 全てのテストが通過していること
   - 実装完了条件の全項目を満たしていること

2. **実装レポートの作成**：

   - MD ファイルを`docs/issue/`ディレクトリに生成
   - ファイル名形式：`logger_implementation_report_YYYYMMDD.md`
   - 以下の内容を必ず含めること：
     - 実装した機能の詳細説明
     - 各関数の実装アプローチと技術的判断
     - テスト結果と検証内容
     - 発見された課題と解決方法

3. **テスト結果の添付**：

   - テスト画像は GitHub 形式の URL で添付
   - 例：`![テスト結果](https://github.com/pacific-system/secret-sharing-demos-20250510/blob/main/test_output/logger_test_YYYYMMDD.png?raw=true)`

4. **コミットとプッシュ**：

   ```bash
   # パシ子スタイルでコミット
   git add docs/issue/logger_implementation_report_YYYYMMDD.md
   git commit -m "✨ ロギング基盤（T1）の実装完了レポート追加 💕"
   git push origin main
   ```

5. **イシューへのレポート投稿**：
   ```bash
   # レポートをイシューにコメント投稿
   gh issue comment 1 --body-file docs/issue/logger_implementation_report_YYYYMMDD.md
   ```

## 💕 パシ子からのアドバイス

お兄様！このロギング基盤実装では特に安全性とパフォーマンスのバランスが重要ですよ〜！💕

- 🔮 **安全なログ出力**: 経路情報が漏洩しないように、ログデータの sanitize 処理は特に慎重に実装してくださいね！
- ⏱️ **パフォーマンス考慮**: ロギングがボトルネックにならないよう、特に高頻度ログ出力時の効率を考慮した実装がポイントです！
- 🧠 **拡張性確保**: 将来の T2〜T4 タスクとの連携を見据えた柔軟な設計にしましょう！他のモジュールから使いやすい API は大事です！
- 🌟 **タイムスタンプ管理**: ログファイル名の重複を絶対に避け、時系列でのデバッグが容易な仕組みを作りましょう！

世界最高の暗号システムには完璧なロギング基盤が必要です！期待してますよ〜！✨

## 📑 関連資料

- [実装計画書](https://github.com/pacific-system/secret-sharing-demos-20250510/blob/main/docs/method_11_rabbit_homomorphic_docs/implementation_plan_chapters/04_implementation_details.md)
- [フェーズ 1 詳細](https://github.com/pacific-system/secret-sharing-demos-20250510/blob/main/docs/method_11_rabbit_homomorphic_docs/implementation_plan_chapters/04_implementation_details.md#フェーズ-1-基盤ユーティリティ実装4-週間)
- [ディレクトリ構成](https://github.com/pacific-system/secret-sharing-demos-20250510/blob/main/docs/method_11_rabbit_homomorphic_docs/implementation_plan_chapters/02_directory_structure_and_deliverables.md)
- [品質レベル規定](https://github.com/pacific-system/secret-sharing-demos-20250510/blob/main/docs/method_11_rabbit_homomorphic_docs/implementation_plan_chapters/05_quality_and_security.md)
- [システム設計とアーキテクチャ](https://github.com/pacific-system/secret-sharing-demos-20250510/blob/main/docs/method_11_rabbit_homomorphic_docs/implementation_plan_chapters/03_system_design_and_architecture.md)
