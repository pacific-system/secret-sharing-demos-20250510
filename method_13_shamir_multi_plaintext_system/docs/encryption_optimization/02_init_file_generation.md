# 初期化時の暗号化ファイル生成改善

## 初期化時の暗号化ファイル雛形生成

システム初期化時に、ゴミデータで埋められた暗号化ファイルの雛形を自動生成する機能を追加します。設計書の「パーティション空間設計」に厳密に準拠し、統計的区別不可能性を確保します。このシステムは暗号書庫として機能し、ファイル A とファイル B が同一の暗号ファイル内に混在して保管されます。**過去形式との互換性は一切考慮せず、設計書のセキュリティ基準に完全準拠した新しい形式のみを実装します。また、過去形式に関連するコード関数は全て削除し、新しい実装のみをコードベースに残します。**

### 仕様

1. **パーティション空間準拠**:

   - ファイル A 用領域：30-40%
   - ファイル B 用領域：30-40%
   - 未割当領域：20-40%
   - これらが統計的に区別できないよう分散配置

2. **ファイル生成タイミング**:

   - `init` コマンド実行時に自動的に雛形ファイルを生成
   - 初期化するたびに新たな UUID を付与した暗号ファイルが生成される（既存ファイルは上書きされない）

3. **出力パス**:

   - 指定パス: `./output/` ディレクトリ（相対パス）
   - ファイル名: `encrypted_{UUID}.json`
   - 時間情報を含めず、UUID のみで一意性を確保

4. **雛形ファイルの内容**:

   - 全シェア ID 空間をランダムなゴミデータで埋める
   - シェアの値は暗号論的に安全な乱数で生成し、実際のシェアと区別不可能にする
   - シェアの分布は設計書の「分散配置」原則に従い、どの部分を切り取っても識別不可能にする
   - 初期化ファイルと暗号化済みファイルが外部から区別できないようにする

5. **セキュリティ要件**:

   - ゴミデータは暗号論的に安全な乱数で生成
   - ゴミデータの分布は実際のシェアと統計的に区別不可能
   - 不要なメタデータを含まず情報漏洩リスクを最小化
   - ファイル名に時間情報を含めないことで、作業時間帯の漏洩を防止
   - 初期化ファイルと暗号化済みファイルを区別不可能にする

6. **ファイル種別の管理**:

   - ファイル A・ファイル B が同一の暗号ファイル内に混在して保管される
   - それぞれのファイル種別用の領域は区別されず、統計的に区別不可能
   - ファイル種別はパーティションキーから導出され、暗号ファイル内に明示的に保存されない

7. **過去形式コードの完全削除**:

   - 過去形式に関連するすべてのコード関数をコードベースから削除
   - 変換関数も実装せず、削除
   - 過去形式ファイルの読み取り関数も完全に削除
   - セキュリティリスクを排除するため、過去形式のコードは一切残さない

### 完全最小化されたヘッダー情報

実装においては、外部から暗号ファイルと初期化ファイルを完全に区別できないよう、必要最小限のヘッダー情報のみを含めます：

1. **salt**: シェア生成に使用したソルト値（常にランダム生成）

以下のメタデータは含めません：

- **magic**: 固定値は暗号ファイルの特性を示す手がかりになるため、区別不能性を高めるために完全に削除
- **created_at**: 作成時刻はリスクになるため含めない
- **share_id_space**: 配列のサイズから計算可能
- **total_chunks**: MAP からの導出または配列サイズで算出可能
- **threshold**: 多段 MAP から取得可能で、内部的にも導出できるため不要
- **file_type**: ファイル種別（A/B）も含めず、パーティションキーから導出
- **version**: 互換性は別の方法で処理するため不要

### 完全な MAP 依存設計

全てのパラメータを多段 MAP から取得する設計により、以下の利点があります：

1. **決定論的性質の強化**: 全ての重要パラメータが MAP から一意に決まるため、予測可能性が向上
2. **メタデータの完全排除**: ファイル内に保存するメタデータを最小限に抑え、情報漏洩リスクを低減
3. **一貫性の確保**: パラメータの管理を一元化し、整合性を保証
4. **実装の簡素化**: 複数の場所で同じパラメータを管理する必要がなくなり、コードの単純化が可能
5. **ファイル種別の隠蔽**: ファイルの種別（A/B）を暗号ファイル内に明示的に保存しない
6. **区別不可能性**: 初期化ファイルと暗号化済みファイルの区別が統計的に不可能
7. **コードの浄化**: 過去形式のコードを完全に排除し、セキュリティリスクを低減

## 実装アプローチ

```python
def generate_empty_encrypted_file(output_dir='./output'):
    """初期化時にゴミデータで埋められた暗号化ファイルの雛形を生成
    設計書の多段MAP原則に厳密に従う実装。最小限のメタデータのみを含む。
    全てのパラメータはMAPから取得。常に新たなUUIDを付与した暗号ファイルを生成。
    初期化ファイルと暗号化済みファイルが外部から完全に区別できないよう設計。
    """
    # 出力ディレクトリの確認・作成
    os.makedirs(output_dir, exist_ok=True)

    # 常に新たなUUIDを生成（既存ファイルは上書きしない）
    file_uuid = str(uuid.uuid4())
    output_path = os.path.join(output_dir, f"encrypted_{file_uuid}.json")

    # ソルト値を生成
    salt = secrets.token_bytes(16)
    salt_base64 = base64.urlsafe_b64encode(salt).decode('ascii')

    # 多段MAPからパラメータを取得
    share_id_space = get_share_id_space_from_map()
    total_chunks = get_total_chunks_from_map()

    # 全シェアを格納する一次元配列
    total_shares = total_chunks * share_id_space
    all_values = []

    # 全てのシェアに対して暗号論的に安全なランダム値を生成
    for i in range(total_shares):
        # 大きな素数p未満のランダム値を生成
        random_value = str(secrets.randbelow(int(ShamirConstants.PRIME - 1)) + 1)
        all_values.append(random_value)

    # ファイルフォーマットを構築 - 最小限のヘッダー情報のみ
    # magicフィールドを完全に削除し、暗号化ファイルと区別不能に
    empty_file = {
        "header": {
            "salt": salt_base64
        },
        "values": all_values
    }

    # 暗号化ファイルを保存
    with open(output_path, 'w') as f:
        json.dump(empty_file, f)

    return output_path
```

この機能は`init`コマンドに組み込み、パーティションキーの生成と同時に実行されるようにします。実装では最小限のヘッダー情報のみを含むことで、情報漏洩リスクを低減しつつ、多段 MAP 理念に完全準拠した形式となります。全てのパラメータを多段 MAP から決定論的に取得することで、設計理念に忠実なシステムが実現します。また、初期化するたびに新しい UUID を持つ暗号ファイルが生成され、既存ファイルが上書きされることがないよう設計されています。

特に重要なのは、「magic」フィールドを完全に削除することで、外部からファイルの種類を識別する手がかりを与えず、初期化ファイルと暗号化済みファイルが完全に区別不能になる点です。このヘッダー構造は暗号化処理でも完全に同一とし、初期化ファイルと実データを含むファイルの間で構造的・統計的な違いが一切生じないようにします。両ファイルタイプが完全に区別不能であることは、システムのセキュリティを大幅に強化し、どのファイルに実データが含まれているかという情報漏洩を防止します。

また、過去形式に関連するすべてのコード関数をコードベースから完全に削除することで、セキュリティ上の脆弱性を持つ可能性のある古いコードが誤って使用されるリスクを排除し、全体的なシステムのセキュリティを高めます。
