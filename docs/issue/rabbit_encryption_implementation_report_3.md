# 🐰 ラビット暗号化方式 実装【子 Issue #3】：多重鍵ストリーム生成機能の実装レポート

## 💕 実装概要

お兄様！パシ子がラビット暗号化のための多重鍵ストリーム生成機能を実装しましたよ〜✨ この機能により、同一の暗号文から異なる 2 つの平文（正規文書/非正規文書）を復元できるようになりました！ユーザーが持つ鍵によって、表示される内容が変わる素敵な機能です 💖

## 📦 実装内容

### 主要機能

1. **HKDF 鍵導出関数**：RFC 5869 準拠の HMAC-based Key Derivation Function
2. **複数種別の鍵導出**：マスター鍵から正規/非正規の 2 種類の独立したストリーム鍵を導出
3. **鍵種別判定**：入力鍵が正規か非正規かを安全に判別（タイミング攻撃に耐性あり）
4. **StreamSelector クラス**：復号/暗号化に適切なストリームを提供
5. **分布均一性**：ランダム鍵に対して種別判定が統計的に均一に分布

### ファイル構成

```
method_6_rabbit/
├── stream_selector.py  # 今回実装した多重鍵ストリーム生成機能
├── rabbit_stream.py    # Issue #2で実装したRabbitストリーム生成アルゴリズム
├── config.py           # 設定パラメータ
├── __init__.py
├── encrypt.py          # 暗号化スクリプト（今後実装予定）
├── decrypt.py          # 復号スクリプト（今後実装予定）
└── tests/              # テストフォルダ
```

## 💡 主要コンポーネント詳細

### 1. HKDF (HMAC-based Key Derivation Function)

RFC 5869 に準拠した HKDF を実装しました。2 つのステップで構成されます：

1. **抽出フェーズ**：入力鍵材料とソルトから PRK（擬似ランダム鍵）を生成
2. **拡張フェーズ**：PRK からコンテキスト情報を用いて任意長の出力鍵材料を生成

```python
def hkdf_extract(salt: bytes, input_key_material: bytes) -> bytes:
    """HKDF抽出ステップ（RFC 5869）"""
    return hmac.new(salt, input_key_material, HKDF_HASH).digest()

def hkdf_expand(pseudo_random_key: bytes, info: bytes, length: int) -> bytes:
    """HKDF拡張ステップ（RFC 5869）"""
    # 実際の実装（略）
```

### 2. 複数種別の鍵導出

マスター鍵から「正規」と「非正規」の 2 種類の鍵ペア（鍵と IV）を導出します：

```python
def derive_multiple_keys(master_key: bytes, salt: bytes = None):
    """マスター鍵から複数の鍵ペア（鍵とIV）を導出"""
    # PRKを抽出
    prk = hkdf_extract(salt, master_key)

    # 正規ストリーム用の鍵とIVを導出
    true_key_material = hkdf_expand(prk, TRUE_KEY_INFO, RABBIT_KEY_SIZE + RABBIT_IV_SIZE)
    # ...

    # 非正規ストリーム用の鍵とIVを導出
    false_key_material = hkdf_expand(prk, FALSE_KEY_INFO, RABBIT_KEY_SIZE + RABBIT_IV_SIZE)
    # ...
```

この方法では、同一のマスター鍵から数学的に独立した 2 つの鍵セットが生成されるため、一方から他方を推測することはできません。

### 3. 鍵種別判定機能

鍵が正規か非正規かを判定する関数を、タイミング攻撃に耐性を持つよう設計しました：

```python
def determine_key_type_secure(key: Union[str, bytes], salt: bytes) -> str:
    """タイミング攻撃に耐性を持つ鍵種別判定関数"""
    # HMAC計算（タイミング攻撃に耐性あり）
    h = hmac.new(salt, key_bytes, hashlib.sha256).digest()

    # 定数時間で実行される計算
    # 分岐なしのロジックで、実行時間が鍵の内容に依存しないよう設計
    # ...
```

鍵種別判定は、ソースコード解析から保護するために複雑なロジックを使用しています：

- ビット操作や算術演算を組み合わせた複雑な判定条件
- 条件分岐を避け、一定時間で実行される処理
- 複数のビットを使用した判定で、単一ビットよりも安全性を向上

### 4. StreamSelector クラス

鍵に基づいて適切なストリームを選択・提供する機能を実装しました：

```python
class StreamSelector:
    """鍵に基づいて適切なストリームを選択する機能を提供"""

    def get_stream_for_encryption(self, master_key, data_length, key_type):
        """暗号化用のストリームを取得"""
        # 実装詳細（略）

    def get_stream_for_decryption(self, key, data_length):
        """復号用のストリームを取得（鍵種別を自動判定）"""
        # 実装詳細（略）

    def get_streams_for_both_paths(self, master_key, data_length):
        """両方のパス用のストリームを同時に生成（主に暗号化用）"""
        # 実装詳細（略）
```

## 📊 テスト結果

### 1. 鍵種別分布テスト

ランダムな鍵と鍵の種別判定の分布をテストした結果：

```
== 鍵種別分布テスト ==
種別分布（1000回のテスト）:
  TRUE: 489 (48.90%)
  FALSE: 511 (51.10%)
  分布の均一性: 0.957 (1.0が理想)
```

鍵種別判定機能は統計的に均一な分布を示し、ほぼ理想的な動作を確認できました。

### 2. ストリーム生成テスト

```
マスターキー: f3b5ac4034d769e44c1a928cae11236b
ソルト: c10f72d4f66b27172e6a15f634c8fc3e

== 両方のストリーム ==
真のストリーム: 48ba85ddbcd6982f1291b63555b6635844bdbc8babc65c46d29229d17b739458
偽のストリーム: 7d7992e94080baa70caff9fc51a66fcbdce938c33a01a811028423b3f1b603e1
```

同一マスター鍵から、数学的に独立した 2 つの異なるストリームが生成されています。

## 🔐 安全性の考慮

### タイミング攻撃への耐性

鍵種別判定は以下の方法でタイミング攻撃から保護しています：

- 条件分岐を最小限に抑え、常に同じコードパスを実行
- HMAC を使用（HMAC はタイミング攻撃に対する耐性を内蔵）
- 複数のビット操作を使用した複雑な判定条件

### ソースコード解析への耐性

- 鍵の判定ロジックは、第三者がソースコードを解析しても、特定の入力がどの種別と判定されるか予測困難な設計
- 複雑な算術演算とビット操作の組み合わせにより、静的解析を困難に
- 鍵から種別を導出する部分は推測困難な設計（数学的な逆算が不可能）

## 🎯 要件達成状況

| 要件               | 達成状況 | 説明                                                                   |
| ------------------ | -------- | ---------------------------------------------------------------------- |
| 複数ストリーム導出 | ✅ 完了  | マスター鍵から複数の独立したストリームを導出する機能を実装             |
| 安全な鍵種別判定   | ✅ 完了  | ソースコード解析から保護され、タイミング攻撃に耐性のある判定機能を実装 |
| ストリーム選択機能 | ✅ 完了  | 鍵の種類に応じて適切なストリームを選択・提供する機能を実装             |
| 統計的均一性       | ✅ 完了  | ランダム鍵に対して鍵種別が偏りなく分布することを確認                   |
| テスト機能         | ✅ 完了  | 全機能のテストコードと検証機能を実装                                   |

## 🚀 次のステップ

この多重鍵ストリーム機能を使用して、次のステップでは「暗号化機能」と「復号機能」を実装します：

- 暗号化時は両方のストリームを用意し、true.text と false.text を同時に暗号化
- 復号時は提供された鍵から適切なストリームを自動的に選択

## 💬 備考

今回実装した多重鍵ストリーム生成機能により、同一の暗号文から異なる平文を復元する「秘密経路」が実現できました。この機能は数学的に安全で、攻撃者がソースコードを完全に入手しても、どの鍵が「正規」でどの鍵が「非正規」かを判別することは困難になっています。

お兄様、パシ子頑張りました！🐰✨

## 📝 付録：主要インターフェース

```python
# 両方のストリームを生成
streams = selector.get_streams_for_both_paths(master_key, data_length)
true_stream = streams[KEY_TYPE_TRUE]  # 正規ストリーム
false_stream = streams[KEY_TYPE_FALSE]  # 非正規ストリーム

# 復号用のストリームを取得（鍵タイプを自動判定）
decrypt_stream = selector.get_stream_for_decryption(user_key, data_length)

# パスワードから鍵種別を判定
is_true = is_true_password(password, salt)
```
