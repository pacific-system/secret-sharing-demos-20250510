# 暗号化モジュール実装ガイド

## 暗号化モジュールの目的

このモジュールは複数の JSON 文書（通常は A 文書と B 文書）を単一の暗号化ファイルに変換します。核心となる多段 MAP 方式とシャミア秘密分散法を用いて、異なるパスワードで異なる文書を復号できるようにします。

## 主要な機能と要件

### 1. 多段エンコードプロセス

JSON 文書は以下の多段エンコードプロセスを適用します：

1. UTF-8 テキスト（元の JSON）
2. Latin-1 へのエンコード変換
3. Base64 エンコード
4. 常に圧縮（条件判断なし）

### 2. シャミア秘密分散法の実装

- 多項式の次数と閾値：実用的な値として閾値`t=3`～`5`
- 有限体の選択：大きな素数`p`を用いた有限体 GF(p)上での計算
- 推奨： 文書サイズに応じて十分大きい素数を選択（例：2^256-189）

### 3. シェア ID 空間の設計と管理

- A 用と B 用のシェア ID は予め分割し、暗号化時にはそれらを使用するだけ
- 未割当領域には統計的に区別不能なランダムデータを生成
- シェア ID の分布は特定のパターンを形成しないよう設計（交互配置など）

### 4. 暗号化プロセスの全体フロー

```
データの前処理（多段エンコード）
↓
データをチャンクに分割
↓
各チャンクをシャミア秘密分散でシェア化
↓
未割当領域にゴミデータを生成
↓
シェアをシャッフル
↓
メタデータを追加して暗号化ファイル生成
```

## 実装時の制約とガイドライン

### 絶対条件

1. **識別情報の排除**:

   - どのシェアがどの文書（A または B）に属するかを示す情報を格納しない
   - すべてのメタデータは A/B 区別なく同一形式

2. **シェア値の統計的区別不可能性**:

   - A 文書のシェア、B 文書のシェア、未割当領域のゴミデータが統計的に区別できないこと
   - これは情報理論的安全性のために必須

3. **保存データの最小化**:
   - シャミア秘密分散法で生成されたシェア値
   - 塩値（再計算不可能な乱数）
   - 復号に必要な最小限のメタデータ（閾値など）
   - シェア ID はユーザー入力として提供されるため保存不要
   - マッピング情報はパスワードとシェア ID から計算で再生成可能なため保存不要

### 主要関数の実装ガイド

#### 1. シャミア秘密分散法の実装

```python
def generate_polynomial(secret, degree, p):
    """degree次の多項式を生成"""
    # 係数配列を生成（最初の要素は秘密値）
    # 乱数を用いて残りの係数を生成

def evaluate_polynomial(coef, x, p):
    """多項式の評価"""
    # 係数配列と評価点xから多項式の値を計算

def generate_shares(secret, t, n, p):
    """n個のシェアを生成、閾値はt"""
    # 多項式を生成し、各シェアIDに対する値を計算
```

#### 2. 暗号化関数

```python
def encrypt(json_docs, passwords, share_id_sets, unassigned_ids, threshold=3):
    """
    複数のJSON文書を暗号化

    Args:
        json_docs: 文書のリスト [json_doc_A, json_doc_B]
        passwords: パスワードのリスト [password_A, password_B]
        share_id_sets: シェアIDセットのリスト [share_ids_A, share_ids_B]
        unassigned_ids: 未割当のシェアIDリスト
        threshold: シェア復元に必要な閾値

    Returns:
        暗号化されたファイル構造（辞書型）
    """
    # 1. 各JSON文書に対してエンコード処理
    # 2. チャンクに分割
    # 3. 各チャンクをシェア化（識別不能に）
    # 4. 未割当領域にゴミデータ生成
    # 5. シェアをシャッフル
    # 6. メタデータを追加
```

#### 3. 補助関数

```python
def preprocess_data(json_doc):
    """JSON文書の前処理（多段エンコード）"""
    # UTF-8 → Latin-1 → Base64の多段エンコード

def split_into_chunks(data, chunk_size=64):
    """データを固定長チャンクに分割"""
    # データをチャンクに分割

def generate_chunk_shares(secret, threshold, share_ids, p):
    """チャンクのシェア生成"""
    # シャミアの多項式を使ってシェアを生成

def generate_garbage_shares(unassigned_ids, num_real_shares, p):
    """未割当領域のゴミデータ生成"""
    # 統計的に区別できないランダムデータ生成
```

### 出力形式

暗号化の結果は以下の形式の辞書型データとします：

```python
{
    'metadata': {
        'salt': 'ランダム生成された塩値',
        'total_chunks': チャンク数,
        'threshold': 閾値,
        # その他必要な情報（A/B識別情報は含まない）
    },
    'shares': [
        {
            'chunk_index': チャンクインデックス,
            'share_id': シェアID,
            'value': シェア値
        },
        # ... 他のシェア
    ]
}
```

## 実装上の注意点

1. **セキュアな乱数生成**:

   - `secrets`モジュールを使用して暗号学的に安全な乱数を生成

2. **素数の選択**:

   - 有限体演算に使用する素数は十分に大きく選ぶ
   - 素数サイズは扱うデータサイズに合わせて調整

3. **効率性とメモリ使用量**:

   - 大きなファイルでもメモリ効率よく処理できるよう設計
   - 入力サイズの 3-4 倍程度のメモリ使用に抑える

4. **エラー処理**:
   - 例外を投げる場合でも内部状態や部分的な暗号化情報が漏洩しないよう注意
