# ラビット＋準同型マスキング暗号プロセッサ - 実装タスク実行指示

## 📢 タスク実行にあたっての重要指示

### 進行管理

- **全て完了するまでレポートを作成しないでください**。これは非常に重要です。先に報告書を作成し後から実装したり、実装していないことを実装済みと報告することは禁止します。
- 各タスクは独立して 1 つずつ完了させてください。複数のタスクを同時に進行させないでください。
- 問題が発生した場合は、作業を中断し、具体的な問題点を明確に報告してください。

### 実装原則

- ベストプラクティスに反する実装を禁止します。そのようなシナリオになった時は直ちに作業を中断して指示を仰いでください。
- 要件を全て満たした上で実装作業を進めてください。この作業だけを完了させるために既に満たしている要件を犠牲にしたり要件そのものを歪曲しないでください。
- 特定のタスクに明示されている機能「のみ」を実装し、タスク外の機能実装は行わないでください。
- 指定されたディレクトリ構造とファイル名を厳守してください。

### ドキュメント・報告要件

- 問題が発生したら範囲外の事象でもレポートにて報告すること。
- 最終レポートには以下を含めてください：
  - ディレクトリ一覧とファイル配置図（テキスト式）
  - 詳細な実装説明（各機能の動作原理と実装アプローチ）
  - テスト結果と検証内容
  - 発見された課題と解決方法
- デイレクトリ構成、ファイル名、パラメータ名などは完全に全てを記述すること。
- mermaid 記法、markdown 形式の表が利用できます。
- ダークモードで見やすい配色で記述してください。

### 技術的制約

- ファイルの行数が 500 行を超える時は、複数ファイルに分割してください。
- ファイルサイズが大きい時は、複数ファイルに分割してください。
- テストファイルの出力先は'test_output'ディレクトリに用意されています。
- 処理能力を超えてしまうのでひとつのファイルに長大な内容を書き込もうとしないこと。

### 禁止事項

- 問題があったときに問題を隠匿するコードを生成してテストを通過させることは厳格に禁止します。
- 復号が正常に行われないトラブルが発生したときに、緊急対応として鍵の種類に応じて事前定義されたテキストをバイパス出力する不正改造を行うことを禁止します。
- バックドアを設置し、あたかも暗号復号が正確に実装され、true/false のテキストも要件通りスイッチできているように見せかける不正実装を禁止します。
- テストコードの改変は絶対に許可されません。テストが失敗する場合は実装を修正してください。

## 🛠️ 要求の完了方法

1. **実装完了条件**をすべて満たし、すべてのテストが通過してから最終レポートを作成してください。
2. 実装レポートは指定された命名規則に従い docs/issue/ディレクトリに保存してください。
3. テスト結果のスクリーンショットを必ず添付し、結果の正確さを証明してください。
4. 完成後は git コマンドでコミットとプッシュを行ってください。
5. イシューコメントとして実装レポートを投稿してください。

## 💻 開発環境に関する情報

- agentMode は read_file するときと、cli で gh コマンドを実行するときとでは読み込み性能が異なるため、両方の方法を適宜使い分けてください。
- タスク文書は全て読み切れない場合があるため、必要に応じて部分的に読み込みながら実装を進めてください。
- コマンド実行時のエラーは慎重に分析し、原因と対策を明確にしてください。

## 📋 前提となる要件仕様

- どちらのキーが「正規」か「非正規」かはシステム上の区別ではなく、使用者の意図によって決まります。
- 「ハニーポット戦略」が実装可能 - 意図的に「正規」鍵を漏洩させて偽情報を信じ込ませることができます。
- 本当に重要な情報を「非正規」側に隠す「リバーストラップ」も設定可能です。
- 製品版ではないため、極力 common でファイルを共有して効率化を図らないでください。common で依存性が高まると DEMO の実現にコストがかかるので、他の DEMO に気を使うことなく変更ができるように独立させてください。
- 攻撃者は暗号化・復号プログラムのソースコードを完全に入手していると仮定します。
- 攻撃者は復号結果が正規の true.text か非正規の false.text かを判別しようと試みます。
- 攻撃者がスクリプト解析しても生成物が正規か非正規か判別できないようにすること。
- 暗号強度は範囲外とし、方式の特性を実現することが最大の目的です（暗号強度は別のフェーズが責務を負います）。
- 鍵情報以外の部分からは判別材料が得られない強靭な仕組みが要件です。
- スクリプトを変更・改造されても、秘密経路の識別は数学的に不可能な設計が要件です。

## 📥 実装作業の開始方法

各タスク（T1 から T18）は必ず一つずつ順番に実行してください。

1. 現在のタスク（例：T1）の指示書を読み込む
2. 「タスク単体実行プロンプトテンプレート」を利用して実行指示を作成
3. タスクを完全に実装し、すべてのテストが通過したことを確認
4. 完了レポートを作成し、提出
5. 承認を得てから次のタスク（例：T2）に進む

**重要**: 複数のタスクを同時に開始したり、未完了のまま次のタスクに進むことは厳禁です。各タスクは必ず独立して完全に完了させてから次に進んでください。

## 📚 タスク実行時の必須参照文書

タスクを実行する際は、以下の文書を**必ず**参照してください：

1. **実装指示書**: `/Users/macbook/shamir-secret-sharing-demo/docs/method_11_rabbit_homomorphic_docs/issue/T{番号}_{タスク名}.md`
2. **GitHub イシュー**: `https://github.com/pacific-system/secret-sharing-demos-20250510/issues/{イシュー番号}`

### ⚠️ 警告：内容の推測・創作禁止

上記の文書には実装に必要な詳細な要件、制約条件、完了基準が含まれています。これらの参照先を読まずに実装を進めると、以下の問題が発生します：

- 内容の推測と創作による誤った実装
- 要件との不一致
- 必要なセキュリティ対策の欠落
- タスク境界の混同（実装すべきでない機能の実装）

### 🔍 実装手順

1. 指定された**実装指示書**を最初に完全に読み込む
2. **GitHub イシュー**の内容と関連コメントを確認する
3. 実装指示書に記載された要件に厳密に従う
4. タスク範囲を厳守し、指示書に明示されている機能「のみ」を実装する
5. 不明点がある場合は、推測せず質問する

### 📋 具体例：T1 実行の場合

- **実装指示書**: `/Users/macbook/shamir-secret-sharing-demo/docs/method_11_rabbit_homomorphic_docs/issue/T1_logger_implementation.md`
- **GitHub イシュー**: `https://github.com/pacific-system/secret-sharing-demos-20250510/issues/42`

これらの文書には、ロギング基盤実装に関する全ての必要情報が含まれています。文書内に定義された機能のみを実装し、T2 以降の機能（log_levels.py など）は実装しないでください。

## 🔐 暗号システムの絶対要件

本システムの実装において、以下の要件は**絶対に妥協できない核心的要件**です。これらの要件を満たさない実装は、たとえ他の機能が正常に動作していても、根本的に失敗と見なされます：

### 1. 鍵のみによる判別の原則

- **絶対要件**: 復号される文書は「鍵の違いのみ」によって決定されなければならない
- **禁止事項**: `decrypt_type`, `is_true_file`などのフラグや識別子を使用して文書を判別すること
- **理由**: 攻撃者がソースコードを完全に入手していても、鍵なしでは文書を判別できないようにするため

#### 🚫 禁止される実装例：

```python
# 誤った実装 - 絶対に禁止
def decrypt(encrypted_data, key, is_true_file=True):
    # 復号処理...
    if is_true_file:
        return true_content
    else:
        return false_content
```

#### ✅ 求められる実装方針：

```python
# 正しい実装方針
def decrypt(encrypted_data, key):
    # 鍵から導出される情報のみを使用して復号経路を決定
    derived_path = derive_path_from_key_only(key)
    # 鍵に基づいて復号
    return decrypt_with_path(encrypted_data, derived_path)
```

### 2. 鍵の完全独立性の原則

- **絶対要件**: 鍵 A で復号した攻撃者は、鍵 B を入手しない限り鍵 B に紐付く文書を取り出せない
- **禁止事項**: 一方の鍵から他方の鍵またはその鍵に関連する文書が推測・導出可能な実装
- **理由**: 「ハニーポット戦略」「リバーストラップ」を実現するため

#### 🚫 禁止される実装例：

```python
# 誤った実装 - 絶対に禁止
def generate_second_key(first_key):
    # 最初の鍵から2つ目の鍵を生成（推測可能）
    return first_key[::-1]  # 単に逆順にするなど
```

#### ✅ 求められる実装方針：

```python
# 正しい実装方針
# 各鍵は完全に独立して生成
def generate_keys():
    true_key = generate_secure_random_key()
    false_key = generate_secure_random_key()
    # 両方の鍵が独立していることを確認
    verify_key_independence(true_key, false_key)
    return true_key, false_key
```

### ⚠️ これらの要件に関する警告

1. **難易度が高いと感じても要件を放棄しないでください**
2. **要件を満たすことが難しい場合は、実装方法を質問してください**
3. **短期的な解決策のために妥協することは絶対に許可されません**
4. **これらの要件を満たさない実装はすべて拒否され、実装をやり直す必要があります**
5. **要件を満たす方法が分からない場合は、「わからない」と率直に伝えてください。推測による実装は避けてください**

## 🧠 適応的セキュリティ実装論

本プロジェクトでは、橘パシ子の提唱する「適応的セキュリティ実装論」を採用します。この理論は、計画への固執よりも核心的要件の達成を優先し、実装の進行とともに最適なアプローチを柔軟に進化させる考え方です。タスク実行にあたっては、以下の原則を常に意識してください：

### 1. 核心的セキュリティ要件優先の原則

- **実装における最優先事項**：計画の厳密な遵守より、核心的セキュリティ要件の確実な達成を優先する
- **絶対に妥協しない要件**：
  - 鍵のみによる文書区別の原則
  - 鍵の交差推測不可能性
  - ソースコード解析耐性
  - ファイル区画分離回避
- **矛盾発生時の対応**：実装中に要件と計画に矛盾が生じた場合は要件を優先し、計画を柔軟に調整する
- **実装例**：コード効率化よりもセキュリティ要件を優先し、必要であれば冗長性を許容する

### 2. 問題認識とサブタスク挿入の柔軟性

- **新たな課題への対応**：実装過程で発見された脆弱性や課題に対して、計画を修正し適切なサブタスクを挿入する柔軟性を持つ
- **追加要素の導入**：初期計画になかった要素でも、核心的要件達成に必要と判断される場合は積極的に追加する
- **継続的最適化**：実装の進行中に得られた知見に基づき、後続タスクを継続的に最適化する
- **報告の義務**：計画からの逸脱や追加作業が発生した場合は、その理由と影響範囲を明確に文書化する
- **実装例**：タスク実行中に発見した潜在的なセキュリティリスクに対応するための追加サブタスクを提案・実装する

### 3. 理論と実装のギャップの継続的検証

- **ギャップ分析の義務化**：各タスク完了時に「理論と実装のギャップ」分析を必須で実施する
- **即時対応の原則**：発見されたギャップは修正タスクとして即座に対応計画に組み込む
- **ギャップ分析の記録**：分析結果を詳細に記録し、パターンを特定することで将来的なギャップを予測・予防する
- **分析レポートの内容**：理論的安全性と実装安全性の差異、潜在的影響範囲、根本原因分析、対応戦略を含める
- **実装例**：タスク完了レポートに「理論と実装のギャップ分析」セクションを追加し、発見した不一致と対策を文書化する

### 4. 実装計画の適応的最適化

- **経験に基づく最適化**：実装から得られる知見に基づき、後続フェーズの計画を適応的に最適化する
- **核心要件の保護**：最適化の際も核心的セキュリティ要件を損なわないことを絶対条件とする
- **変更の文書化**：計画変更はすべて記録し、変更理由と影響範囲を明確にドキュメント化する
- **継続的な評価**：実装の進行に伴い、定期的に計画の有効性を再評価し、必要に応じて調整する
- **実装例**：タスク完了後に後続タスクへの提案・最適化案を含めた「適応的改善提案」を提出する

## 🧩 適応的セキュリティ実装論の実践方法

タスク実行時に適応的セキュリティ実装論を適用するための具体的なガイドラインです：

### 実装中の継続的な自問自答

- 「この実装は核心的セキュリティ要件を満たしているか？」
- 「ここで見つかった課題は追加のサブタスクを必要としているか？」
- 「理論と実装の間にギャップが存在していないか？」
- 「この経験から後続タスクの計画を最適化できるか？」

### 発見と提案の記録

各タスク完了レポートに以下のセクションを追加してください：

```markdown
## 適応的セキュリティ分析

### 発見したギャップと対応

- [ギャップ 1]: [詳細説明と対応策]
- [ギャップ 2]: [詳細説明と対応策]

### 追加サブタスクの提案

- [提案 1]: [理由と実装案]
- [提案 2]: [理由と実装案]

### 後続タスクへの最適化提案

- [タスク ID]: [最適化提案の詳細]
```

### サブタスク提案の形式

サブタスクの挿入が必要な場合は、以下の形式で提案してください：

```markdown
## サブタスク提案

- **関連タスク**: T[既存 ID]
- **提案サブタスク ID**: T[提案 ID]（例：T10.1）
- **提案理由**: [詳細な説明]
- **影響範囲**: [影響を受けるタスクリスト]
- **優先度**: [高/中/低]
- **実装見積り**: [工数]
```

### タスク間の新たな依存関係の提案

実装経験から新たな依存関係が判明した場合：

```markdown
## 依存関係更新提案

- **影響タスク**: T[ID]
- **新たな依存関係**: T[ID1], T[ID2]...
- **提案理由**: [詳細な説明]
- **リスク評価**: [変更しない場合のリスク]
```

この「適応的セキュリティ実装論」に基づくアプローチにより、プロジェクトの進行とともに最適な実装方法を柔軟に進化させながら、核心的セキュリティ要件を確実に満たすことを目指します。

## 📝 タスク単体実行プロンプトテンプレート

AgentMode でタスクを１つずつ確実に実行するために、以下のテンプレートを使用してください：

```markdown
# T{番号}：{タスク名} 実行指示

## 🎯 実行対象

- 現在のタスク: **T{番号}**（{タスク名}）
- タスク範囲: `/docs/method_11_rabbit_homomorphic_docs/issue/T{番号}_{タスク名}.md` に記載された機能のみ
- 依存関係: {依存タスク番号がある場合は記載}

## 📋 タスク概要と範囲

このタスクでは以下の機能「のみ」を実装します：

- {タスクの具体的な機能・範囲を箇条書きで}

以下は実装「しない」でください：

- {次のタスクや範囲外の機能を箇条書きで}

## 🔍 作業手順

1. まずタスク指示書を詳細に読み込み、要件を完全に理解してください
2. 実装計画を立て、必要なファイル構造とモジュール設計を決定してください
3. 「適応的セキュリティ実装論」の原則に従い、核心的セキュリティ要件を最優先してください
4. 実装を開始し、1 つの機能ごとにテストして進めてください
5. 実装中に発見した課題や脆弱性を記録し、必要に応じてサブタスクを提案してください
6. 理論と実装のギャップを継続的に分析し、対処してください
7. すべての機能実装後、総合テストを実施してください
8. 完了条件をすべて確認してから最終レポートを作成してください

## ⚠️ 制約事項

- **タスク境界の厳守**: このタスク(T{番号})の範囲内の機能「のみ」を実装してください
- **一度に 1 機能**: 複数の機能を同時に実装せず、1 つずつ確実に実装してください
- **テスト改変禁止**: テストが失敗した場合は実装を修正し、テストコードは変更しないでください
- **レポート作成タイミング**: すべての実装と検証が完了してから最終レポートを作成してください
- **適応的セキュリティ原則の遵守**: 計画への固執より核心的セキュリティ要件の達成を優先してください
- **発見事項の報告義務**: 実装中に発見した脆弱性やギャップを明確に文書化してください

## 🚨 問題発生時の対応

問題が発生した場合は：

1. 作業を一時停止してください
2. 具体的な問題点と現在の状況を報告してください
3. 解決策の方針を提案してください
4. 指示を待ってから作業を再開してください

## 📝 完了レポート

すべての実装が完了し、テストが通過した後に以下の形式で報告してください：

1. **実装内容**：機能ごとの実装概要
2. **テスト結果**：実行したテストとその結果
3. **テスト画像**：テスト結果のスクリーンショット
4. **発見した課題と解決策**：実装中に遭遇した問題と解決方法
5. **ディレクトリ構造**：作成・変更したファイル一覧
6. **適応的セキュリティ分析**：
   - 発見したギャップと対応策
   - 追加サブタスクの提案（必要な場合）
   - 後続タスクへの最適化提案

## 🔄 次のステップ

このタスクが完了したら、次のタスク(T{次のタスク番号})に進む前に確認を取ってください。
```
