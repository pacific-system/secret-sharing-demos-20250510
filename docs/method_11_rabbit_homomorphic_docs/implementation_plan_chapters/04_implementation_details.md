## 4. 実装計画と管理 📋

### ⚠️ 実装における絶対禁止事項

以下の実装パターンは、たとえ短期的に機能しても、システムの核心的安全性を損なうため**絶対に禁止**します：

1. `decrypt(encrypted_data, key, is_true_file=True)` のような、鍵以外のパラメータによる復号経路の決定
2. 暗号ファイル内への `"true_section"` や `"false_section"` などの識別子の埋め込み
3. 鍵データ内への経路情報の直接埋め込み（例: `{"key": "...", "type": "true"}` など）
4. 一方の鍵から他方の鍵を導出または推測可能な実装（例: `false_key = true_key[::-1]` など）
5. ソースコード内の明示的な分岐による復号経路の決定
6. 共通鍵導出元（シード値）の使用による関連性のある鍵生成
7. 暗号化時・復号時に経路識別子をパラメータとして受け渡す API 設計
8. ソースコード難読化による安全性の確保（解析耐性は難読化ではなく数学的に保証すること）

上記の禁止事項に違反する実装は、テストに合格しても**即時拒否**され、実装のやり直しが必要となります。真に安全な実装は、鍵の数学的性質のみによって経路を決定し、ソースコードを完全公開しても安全である必要があります。

### 暗号システムの絶対要件

本システムの実装において、以下の要件は絶対に譲れない核心的セキュリティ原則です：

1. **鍵のみによる文書区別の原則**：

   - 暗号文書の区別は鍵の違いのみによって行われなければならない
   - ファイル内のフラグや識別子による区別は絶対に禁止
   - メタデータやヘッダー情報に経路情報を含めてはならない

2. **鍵の交差推測不可能性**：

   - 鍵 A から鍵 B を数学的に導出・推測することが不可能であること
   - 一方の鍵の漏洩が他方の鍵のセキュリティに影響しない設計

3. **ソースコード解析耐性**：

   - ソースコードの完全な解析によっても、鍵なしでの復号が不可能であること
   - ソースコードの難読化に依存しない数学的安全性の保証

4. **ファイル区画分離回避**：
   - 真偽情報を別々のファイル区画に格納する設計の回避
   - 単一の暗号化ストリームに両方の情報を融合して保存する設計

これらの要件は、タスク計画や進捗状況に関わらず常に最優先されるべき原則であり、どのような設計変更や最適化を行う場合でも必ず遵守しなければなりません。

### 適応的セキュリティ実装論

本プロジェクトでは、橘パシ子の提唱する「適応的セキュリティ実装論」を採用します。この理論は、計画への固執よりも核心的要件の達成を優先し、実装の進行とともに最適なアプローチを柔軟に進化させる考え方です。

1. **核心的セキュリティ要件優先の原則**：

   - 計画遵守より核心的セキュリティ要件の達成を常に優先
   - 実装過程で要件と計画に矛盾が生じた場合は要件を優先し計画を調整

2. **問題認識とサブタスク挿入の柔軟性**：

   - 実装過程で発見される新たな課題に対応するためのサブタスク挿入
   - 初期計画になかった要素でも核心的要件達成に必要と判断されれば追加

3. **理論と実装のギャップの継続的検証**：

   - 各フェーズ完了時に理論と実装のギャップ分析を必須実施
   - 発見されたギャップに対応する修正タスクの即時追加

4. **実装計画の適応的最適化**：
   - 実装から得られる知見に基づく後続フェーズ計画の最適化
   - 計画変更の理由と影響範囲の明確なドキュメント化

### 適応的実装フェーズモデル

パシ子の経験に基づき、本プロジェクトは従来の「重厚長大なフェーズ」から、より適応的かつ反復的な「セキュリティ主導型サイクル」に移行します。このアプローチにより、セキュリティ要件の継続的検証と機能実装の並行進行が可能になります。

#### サイクル構造の概要

各実装サイクルは以下の 4 段階で構成されます：

1. **計画・設計（P）**: 核心要件を満たす実装方法の設計
2. **実装・構築（B）**: 小規模かつ完結した機能単位での実装
3. **検証・評価（V）**: セキュリティ特性の検証と品質評価
4. **適応・改善（A）**: 検証結果に基づく改善と次サイクルへの知見反映

この PBVA サイクルを繰り返すことで、各機能はより安全で堅牢なものへと進化します。

### 実装サイクルとタスク構成

機能的にまとまった「サイクル」を基本単位とし、各サイクル内に「タスク群」を配置します。タスク番号は 10000 単位でサイクルを区分し、サイクル内では 100 単位で間隔を設けています。

#### サイクル 1: 基盤ロギングシステム (T10000-T11999)

**目的**: セキュアなログ機能とデバッグ基盤の構築

| ID     | タスク責務               | 担当モジュール                   | 優先度 | 依存関係       | 特記事項                   |
| ------ | ------------------------ | -------------------------------- | ------ | -------------- | -------------------------- |
| T10000 | ロギング基盤実装         | utils/logging/logger.py          | 最高   | なし           | 他の全モジュールの依存基盤 |
| T10100 | ログレベル管理実装       | utils/logging/log_levels.py      | 高     | T10000         | ログシステムの基本機能     |
| T10200 | ログ出力ルーティング実装 | utils/logging/output_router.py   | 高     | T10000, T10100 | 出力先制御機能             |
| T10300 | ログアーカイブ管理実装   | utils/logging/archive_manager.py | 中     | T10000, T10200 | 履歴管理機能               |

**検証ポイント 1.1 (VP1.1)**: ロギングサブシステム完全性検証

- 情報漏洩リスク分析
- マルチスレッド安全性検証
- パフォーマンス評価

#### サイクル 2: 乱数・量子基盤 (T20000-T21999)

**目的**: 暗号学的に安全な乱数源と検証機構の実装

| ID     | タスク責務           | 担当モジュール                          | 優先度 | 依存関係       | 特記事項             |
| ------ | -------------------- | --------------------------------------- | ------ | -------------- | -------------------- |
| T20000 | 量子乱数基本機能実装 | utils/quantum/quantum_random.py         | 最高   | VP1.1          | 真の乱数性確保が核心 |
| T20100 | エントロピー検証実装 | utils/quantum/entropy_verifier.py       | 高     | T20000         | 乱数品質保証         |
| T20200 | 分布均一性保証実装   | utils/quantum/distribution_guarantee.py | 高     | T20000, T20100 | 統計的特性保証       |

**検証ポイント 2.1 (VP2.1)**: 乱数品質・エントロピー検証

- 統計的テストスイート実行
- エントロピー品質評価
- 長期連続生成テスト

#### サイクル 3: テストフレームワーク (T30000-T31999)

**目的**: 自動検証基盤と品質保証システムの構築

| ID     | タスク責務               | 担当モジュール                    | 優先度 | 依存関係     | 特記事項                 |
| ------ | ------------------------ | --------------------------------- | ------ | ------------ | ------------------------ |
| T30000 | テスト基盤構築           | tests/test_framework.py           | 高     | VP1.1, VP2.1 | 通過・失敗が明確なテスト |
| T30100 | テストデータ生成機能実装 | tests/test_utils/generators/\*.py | 中     | T30000       | テスト用入力データ生成   |
| T30200 | テスト結果分析ツール実装 | tests/test_utils/analyzers/\*.py  | 中     | T30000       | テスト結果検証ツール     |
| T30300 | テスト用モック実装       | tests/test_utils/mocks/\*.py      | 中     | T30000       | 外部依存の単体テスト対応 |

**検証ポイント 3.1 (VP3.1)**: テストフレームワーク完全性検証

- カバレッジ測定
- テスト再現性・安定性検証
- エッジケース対応能力評価

#### サイクル 4: バイナリ操作基盤 (T40000-T41999)

**目的**: 低レベルデータ処理の安全実装

| ID     | タスク責務           | 担当モジュール                 | 優先度 | 依存関係 | 特記事項               |
| ------ | -------------------- | ------------------------------ | ------ | -------- | ---------------------- |
| T40000 | バイト操作基盤実装   | utils/byte/byte_array.py       | 高     | VP1.1    | 低レベルデータ操作     |
| T40100 | エンディアン変換実装 | utils/byte/endian_converter.py | 中     | T40000   | プラットフォーム互換性 |
| T40200 | ビット操作実装       | utils/byte/bit_operations.py   | 中     | T40000   | 効率的なビット処理     |

**検証ポイント 4.1 (VP4.1)**: バイナリ操作セキュリティ検証

- サイドチャネル露出分析
- パフォーマンス特性評価
- プラットフォーム互換性テスト

#### サイクル 5: 鍵管理システム (T50000-T51999)

**目的**: 核心的セキュリティ要件を満たす鍵管理の実装

| ID     | タスク責務           | 担当モジュール                | 優先度 | 依存関係               | 特記事項         |
| ------ | -------------------- | ----------------------------- | ------ | ---------------------- | ---------------- |
| T50000 | 鍵管理基本機能実装   | utils/key/key_manager.py      | 最高   | VP1.1, VP2.1, VP4.1    | 鍵管理の中核機能 |
| T50100 | 鍵保存・読込機能実装 | utils/key/key_storage.py      | 高     | T50000                 | 安全な鍵保存     |
| T50200 | 鍵検証・強度評価実装 | utils/key/key_verification.py | 高     | T50000                 | 鍵品質保証       |
| T50300 | 鍵ローテーション実装 | utils/key/key_rotation.py     | 中     | T50000, T50100, T50200 | 鍵の定期的更新   |

**検証ポイント 5.1 (VP5.1)**: 鍵管理セキュリティ検証

- 鍵分離・独立性検証
- 鍵情報漏洩ベクトル分析
- 耐解読性テスト

#### サイクル 6: 核心要件検証 (T60000-T61999)

**目的**: 前サイクルで実装した機能の核心要件適合性の徹底検証

| ID     | タスク責務                 | 担当モジュール                              | 優先度 | 依存関係       | 特記事項                       |
| ------ | -------------------------- | ------------------------------------------- | ------ | -------------- | ------------------------------ |
| T60000 | 核心要件遵守レビュー       | 全モジュール設計書                          | 最高   | VP5.1          | 鍵のみによる判別などの要件検証 |
| T60100 | ソースコード開示耐性分析   | 核心モジュール設計書                        | 最高   | T60000         | ソースコード全公開時の安全性   |
| T60200 | 鍵独立性検証フレームワーク | utils/key/key_independence_verifier.py      | 最高   | T50000, T60000 | 鍵間の数学的独立性検証         |
| T60300 | 暗号ファイル均質性解析     | utils/analysis/file_homogeneity_analyzer.py | 高     | T60000         | 暗号ファイルの統計的均質性     |
| T60400 | 設計全体セキュリティ監査   | docs/audit/security_audit_cycle6.md         | 最高   | T60000-T60300  | 第三者視点でのセキュリティ監査 |
| T60500 | 設計改善および対応策実装   | docs/audit/security_improvements.md         | 高     | T60400         | 監査で発見された問題点の改善   |

**検証ポイント 6.1 (VP6.1)**: 核心要件全体適合性検証

- 理論と実装のギャップ分析
- 核心要件トレーサビリティ確認
- 予想外の相互作用検証

#### サイクル 7: セキュア鍵派生 (T70000-T71999)

**目的**: 経路情報を安全に組み込む鍵派生システム実装

| ID     | タスク責務                   | 担当モジュール                                  | 優先度 | 依存関係            | 特記事項             |
| ------ | ---------------------------- | ----------------------------------------------- | ------ | ------------------- | -------------------- |
| T70000 | 量子乱数ソルト生成実装       | utils/secure_key_derivation/quantum_salt.py     | 最高   | VP2.1, VP5.1, VP6.1 | QKDF 先行実装        |
| T70100 | 量子鍵派生関数(QKDF)実装     | utils/secure_key_derivation/qkdf.py             | 最高   | T70000              | 鍵導出の基盤         |
| T70200 | 経路情報の安全な組み込み実装 | utils/secure_key_derivation/path_integration.py | 高     | T70000, T70100      | 経路情報の安全な扱い |

**検証ポイント 7.1 (VP7.1)**: セキュア鍵派生検証

- 鍵導出過程の分離不可能性検証
- 量子乱数活用効果測定
- 経路情報漏洩リスク分析

以降のサイクルもこの形式で継続します。各サイクルはセキュリティ要件を最優先する小規模な機能単位で構成され、サイクル完了ごとに徹底した検証を行い、結果を次サイクルにフィードバックします。

### 適応的タスク管理

この実装計画では、橘パシ子の「適応的セキュリティ実装論」に基づき、以下の適応的タスク管理アプローチを採用します：

1. **タスク番号の間隔設計**：

   - 各サイクル内でタスク番号に十分な間隔を設け、実装中に発見される新たな要件や課題に対応するサブタスクの挿入を容易にします
   - サイクル 1: T10000〜T11999（間隔 100、最大 100 タスク）
   - サイクル 2: T20000〜T21999（間隔 100、最大 100 タスク）
   - 同様に後続サイクルも 10000 単位で区切り、サイクル内は 100 単位で間隔を確保

2. **サブタスク挿入メカニズム**：

   - 実装中に新たな要件や脆弱性が発見された場合のサブタスク追加手順：
     1. 最も関連性の高い既存タスクを特定
     2. そのタスク番号の直後に適切な番号を割り当て（例：T10050、T70350 など）
     3. 依存関係を適切に更新
     4. タスク追加の理由を明確に文書化
   - サブタスク追加の記録方法：

     ```md
     ## サブタスク追加記録

     - タスク ID: T[新 ID]
     - 追加日: [日付]
     - 関連タスク: T[既存 ID]
     - 検出サイクル: サイクル[N]
     - 追加理由: [理由の詳細説明]
     - セキュリティ影響度: [高/中/低]
     ```

3. **検証ポイントでのフィードバックループ**：

   - 各検証ポイント(VP)では以下のプロセスを実施：
     1. 実装された機能の核心要件適合性を検証
     2. 理論と実装のギャップを分析
     3. 発見された問題に対する対応タスクを定義
     4. 後続サイクルへの教訓と知見を文書化
   - 検証結果の記録方法：

     ```md
     ## 検証ポイント記録: VP[N.M]

     - 実施日: [日付]
     - 対象タスク: T[ID1], T[ID2], ...
     - 検証項目: [検証内容リスト]
     - 発見された問題:
       - [問題 1]: [説明] → 対応タスク T[新 ID]
       - [問題 2]: [説明] → 対応タスク T[新 ID]
     - 後続サイクルへの教訓: [詳細説明]
     ```

4. **緊急サイクル追加メカニズム**：

   - 深刻なセキュリティ問題が発見された場合、予定されたサイクル間に緊急サイクルを挿入する手順：
     1. 最も関連性の高いサイクルの後に新しいサイクル番号を割り当て
     2. 緊急対応の必要性と影響範囲を文書化
     3. 後続サイクルの番号を必要に応じて調整
   - 緊急サイクル追加の記録方法：

     ```md
     ## 緊急サイクル追加記録

     - サイクル ID: サイクル[N+]
     - 追加日: [日付]
     - 発見元: VP[X.Y]
     - 追加理由: [セキュリティ問題の詳細説明]
     - 影響範囲: [影響を受けるサイクルとタスク]
     ```

このアプローチにより、実装計画は固定的な手順書ではなく、プロジェクトの進行と共に継続的に最適化される「生きた文書」となります。核心的セキュリティ要件を常に最優先し、実装から得られる知見を積極的に取り入れながら、最も効果的な実装経路を適応的に見出していきます。
