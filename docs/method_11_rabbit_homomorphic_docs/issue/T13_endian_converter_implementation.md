# 📝 エンディアン変換実装指示書（T13） - ラビット＋準同型マスキング暗号プロセッサ 🔐

> **ドキュメント種別: 実装指示書**

## 🌟 タスク進捗状況

タスク実装フェーズの進捗:

- 🔄 **フェーズ 0**: 実装準備 [**現在作業中**]
- ⏳ **フェーズ 1**: 基盤ユーティリティ実装 [予定]
- ⏳ **フェーズ 2**: セキュリティ対策基盤実装 [予定]
- ⏳ **フェーズ 3**: 三暗号方式コア実装 [予定]
- ⏳ **フェーズ 4**: 融合機能と変換システム実装 [予定]
- ⏳ **フェーズ 5**: データ形式とインターフェース実装 [予定]
- ⏳ **フェーズ 6**: 検証とパフォーマンス最適化 [予定]

### 📋 現在の実装フェーズ: `フェーズ0: 実装準備`

**現在のタスク**: T13（エンディアン変換実装）
**進捗状況**: T1-T12 完了 → **T13 実装中** → T14-T115 未着手

**注**: 各タスクは独立して実装・完了させてください。

### 🎯 タスク範囲（T13: エンディアン変換実装）

**実装すべきもの**:

- ✅ `utils/byte/endian_converter.py`
- ✅ 関連するテスト

**実装してはいけないもの**:

- ❌ `utils/byte/bit_operations.py`（次のタスク T14）
- ❌ 他のバイト操作関連機能（T14 以降のタスク）

**実装がベストプラクティスに反する可能性がある場合**: 作業を即時停止し、問題を報告してください。

## 📝 課題の詳細

### 🎯 タスク概要

本タスク（T13）ではエンディアン変換機能を実装します。前タスク（T12）で実装したバイト操作基盤を活用し、異なるプラットフォーム間でのバイトオーダー変換機能を提供します。これにより、暗号処理におけるプラットフォーム互換性を確保し、様々な環境で一貫した暗号処理を可能にします。次のタスク（T14）で実装予定のビット操作機能は含みません。

**本タスク（T13）の作業カウント**:

- 📝 **実装作業**: 9 件

  - 基本エンディアン変換機能: 3 関数
  - 複合データ型変換機能: 3 関数
  - システム互換性確保機能: 3 関数

- 🧪 **テスト作業**: 3 件

  - 基本エンディアン変換機能テスト
  - 複合データ型変換機能テスト
  - システム互換性確保機能テスト

- ✅ **完了条件**: 25 項目
  - 実装完了条件: 5 項目
  - 機能完了条件: 5 項目
  - テスト完了条件: 5 項目
  - ドキュメント完了条件: 5 項目
  - 納品物件検証条件: 5 項目

### 🔍 背景と目的

ラビット＋準同型マスキング暗号プロセッサは、さまざまなプラットフォームで動作することが想定されています。このような分散環境では、異なるアーキテクチャ間でのエンディアン（バイトオーダー）の違いが暗号処理の一貫性を損なう可能性があります。本タスクで実装するエンディアン変換機能は、これらのプラットフォーム差異を吸収し、どの環境でも同じ暗号結果を生成できるようにするための基盤となります。

フェーズ 1 の重要なユーティリティとして、このエンディアン変換機能は後続の暗号コア実装（ラビットストリーム、準同型暗号、量子耐性レイヤーなど）で必要とされる基礎的なバイト処理を支援します。また、バイナリデータの交換や永続化においても重要な役割を果たします。

### 📊 要件仕様

1. リトルエンディアンとビッグエンディアン間の変換機能を提供すること
2. 単一値（整数、浮動小数点数など）と配列型の両方の変換をサポートすること
3. 実行環境のネイティブエンディアンを検出し、必要に応じて変換を適用する機能を提供すること
4. オーバーヘッドを最小限に抑えた効率的な実装を行うこと
5. システムのエンディアン情報をキャッシュし、パフォーマンスを最適化すること
6. サイドチャネル攻撃に対する基本的な防御を実装すること（一定時間実行など）
7. 前タスク（T12）で実装したバイト操作基盤と整合的に動作すること
8. ロギング基盤（T1）と連携し、デバッグ情報を出力できること

### 🛠️ 実装内容概要

エンディアン変換機能として、以下の 3 つの主要機能を実装します：

1. **基本エンディアン変換機能**: 単一のプリミティブ値（整数、浮動小数点数）のエンディアン変換
2. **複合データ型変換機能**: 構造化データや配列のエンディアン変換
3. **システム互換性確保機能**: 環境検出と必要に応じた自動変換

### 📋 実装内容詳細

#### 1. 基本エンディアン変換機能（3 つの関数）

```python
def swap_bytes(value: bytes) -> bytes:
    """
    バイト配列の順序を反転する（エンディアン変換の基本操作）

    Args:
        value: 反転するバイト配列

    Returns:
        バイト順序が反転したバイト配列

    実装詳細:
    1. 引数の検証（Noneでないこと）
    2. バイト配列をスライス操作で反転（[::-1]）
    3. 反転したバイト配列を返す
    """
    pass

def is_little_endian() -> bool:
    """
    実行環境がリトルエンディアンかどうかを判定する

    Returns:
        環境がリトルエンディアンの場合はTrue、ビッグエンディアンの場合はFalse

    実装詳細:
    1. システムのネイティブエンディアンを検出
    2. 整数値(1)をバイト列に変換し、最初のバイトを確認
    3. 最初のバイトが1ならリトルエンディアン、0ならビッグエンディアン
    4. 結果をキャッシュして再利用できるようにする
    """
    pass

def convert_endian(value: bytes, to_little_endian: bool) -> bytes:
    """
    指定されたバイト配列を指定されたエンディアンに変換する

    Args:
        value: 変換するバイト配列
        to_little_endian: Trueならリトルエンディアンに、Falseならビッグエンディアンに変換

    Returns:
        変換後のバイト配列

    実装詳細:
    1. 現在の環境のエンディアンを確認（is_little_endian()を使用）
    2. 目標エンディアンと現在のエンディアンが同じ場合は変換不要
    3. 異なる場合はswap_bytes()を使用してバイト順を反転
    4. 変換後のバイト配列を返す
    """
    pass
```

#### 2. 複合データ型変換機能（3 つの関数）

```python
def int_to_bytes_with_endian(value: int, length: int, little_endian: bool) -> bytes:
    """
    整数値を指定されたエンディアンのバイト配列に変換する

    Args:
        value: 変換する整数値
        length: 結果のバイト配列の長さ（バイト数）
        little_endian: Trueならリトルエンディアン、Falseならビッグエンディアンで出力

    Returns:
        指定されたエンディアンでの整数のバイト表現

    Raises:
        ValueError: valueが負数、またはlengthが0以下の場合
        OverflowError: valueがlengthで指定されたバイト数に収まらない場合

    実装詳細:
    1. 引数の検証（valueが負数でないこと、lengthが正数であること）
    2. valueをバイト配列に変換
    3. バイト配列を指定された長さに調整（パディングまたはトリミング）
    4. 指定されたエンディアンとシステムのエンディアンが異なる場合は変換
    5. 指定された長さとエンディアンを持つバイト配列を返す
    """
    pass

def bytes_to_int_with_endian(value: bytes, little_endian: bool) -> int:
    """
    指定されたエンディアンのバイト配列を整数値に変換する

    Args:
        value: 変換するバイト配列
        little_endian: Trueなら入力はリトルエンディアン、Falseならビッグエンディアンと解釈

    Returns:
        バイト配列から変換された整数値

    実装詳細:
    1. 指定されたエンディアンとシステムのエンディアンが異なる場合はバイト順を反転
    2. バイト配列を整数値に変換
    3. 変換された整数値を返す
    """
    pass

def convert_array_endian(array: bytes, element_size: int, to_little_endian: bool) -> bytes:
    """
    固定サイズ要素の配列全体のエンディアンを変換する

    Args:
        array: 変換するバイト配列
        element_size: 各要素のサイズ（バイト数）
        to_little_endian: Trueならリトルエンディアンに、Falseならビッグエンディアンに変換

    Returns:
        変換後のバイト配列

    Raises:
        ValueError: element_sizeが1未満、またはarrayの長さがelement_sizeで割り切れない場合

    実装詳細:
    1. 引数の検証（element_sizeが正数、arrayの長さがelement_sizeの倍数）
    2. element_sizeが1の場合は変換不要で元の配列を返す
    3. 配列を各要素に分割
    4. 各要素のバイト順を反転
    5. 変換後の要素を再結合して新しい配列を作成
    6. 変換後の配列を返す
    """
    pass
```

#### 3. システム互換性確保機能（3 つの関数）

```python
def host_to_network_byte_order(value: bytes, element_size: int) -> bytes:
    """
    ホストバイトオーダーからネットワークバイトオーダー（ビッグエンディアン）に変換する

    Args:
        value: 変換するバイト配列
        element_size: 各要素のサイズ（バイト数）

    Returns:
        ネットワークバイトオーダーに変換されたバイト配列

    実装詳細:
    1. ホストがリトルエンディアンの場合、ビッグエンディアンに変換
    2. ホストがすでにビッグエンディアンの場合は変換不要
    3. convert_array_endian()を使用して必要に応じて変換を実行
    4. 変換後のバイト配列を返す
    """
    pass

def network_to_host_byte_order(value: bytes, element_size: int) -> bytes:
    """
    ネットワークバイトオーダー（ビッグエンディアン）からホストバイトオーダーに変換する

    Args:
        value: 変換するバイト配列
        element_size: 各要素のサイズ（バイト数）

    Returns:
        ホストバイトオーダーに変換されたバイト配列

    実装詳細:
    1. ホストがリトルエンディアンの場合、ビッグエンディアンから変換
    2. ホストがすでにビッグエンディアンの場合は変換不要
    3. convert_array_endian()を使用して必要に応じて変換を実行
    4. 変換後のバイト配列を返す
    """
    pass

def ensure_cross_platform_compatibility(data: bytes, data_format: dict) -> bytes:
    """
    複合データ構造の交換形式を標準化して、クロスプラットフォーム互換性を確保する

    Args:
        data: 処理するバイト配列
        data_format: データ構造を記述する辞書（フィールド名、オフセット、サイズ、エンディアン）

    Returns:
        標準化されたバイト配列

    実装詳細:
    1. data_formatの各フィールドを処理
    2. 各フィールドのオフセットとサイズに基づいてデータを抽出
    3. 指定されたエンディアンに変換
    4. 変換されたフィールドを結合して新しいバイト配列を作成
    5. 標準化されたバイト配列を返す
    """
    pass
```

## 🔍 完了の定義

以下の基準をすべて満たすことで、このタスクは「完了」とみなされます：

1. **実装完了の条件**:

   - [ ] `utils/byte/endian_converter.py`が指定された仕様で実装されていること
   - [ ] ソースコードが単一責務の原則に従い、明確に構造化されていること
   - [ ] 全ての関数に適切なドキュメント（docstring）が付与されていること
   - [ ] コードレビューでの指摘事項がすべて解消されていること
   - [ ] 静的解析ツールによる警告がゼロであること

2. **機能完了の条件**:

   - [ ] 基本エンディアン変換が正確に動作すること
   - [ ] 複合データ型のエンディアン変換が正確に動作すること
   - [ ] システム互換性機能がさまざまなプラットフォームで一貫した結果を提供すること
   - [ ] パフォーマンスが最適化されていること（不要な変換を回避するなど）
   - [ ] T12 で実装したバイト操作基盤と整合的に連携できること

3. **テスト完了の条件**:

   - [ ] 単体テストのカバレッジが 95%以上であること
   - [ ] 全関数の正常系・異常系のテストケースが実装されていること
   - [ ] 異なるエンディアン環境をシミュレートしたテストが実装されていること
   - [ ] 大きなデータ配列に対するテストが実装されていること
   - [ ] パフォーマンステスト（変換速度、メモリ使用量）が実装されていること

4. **ドキュメント完了の条件**:

   - [ ] 実装した機能の詳細な技術ドキュメントが作成されていること
   - [ ] API 仕様とインターフェース説明が完成していること
   - [ ] 使用方法とサンプルコードが提供されていること
   - [ ] クロスプラットフォーム互換性の確保方法が説明されていること
   - [ ] パフォーマンス特性と最適化手法が文書化されていること

5. **納品物件検証条件**:
   - [ ] 異なるエンディアン環境でも一貫した結果が得られることが検証されていること
   - [ ] 大きなデータセットでも効率的に動作することが検証されていること
   - [ ] T12 のバイト操作基盤との連携が正常に機能することが検証されていること
   - [ ] メモリリークなどの問題が発生しないことが検証されていること
   - [ ] パフォーマンス要件（変換オーバーヘッドの最小化）を満たしていることが検証されていること

## 🧪 テスト対応方針

テスト実装と実行においては以下の方針を厳守してください：

1. **テストの意義**:

   - テストはプロジェクト品質を保証する重要な手段です
   - テストを欺くことは品質の放棄を意味します
   - すべてのテストは実装の品質と完全性を検証するためにあります

2. **テスト失敗時の対応手順**:

   - 実装コードのバグや仕様誤解がないか確認
   - テスト条件を満たすために実装を修正
   - どうしても解決できない場合は、具体的な問題点を報告して指示を仰ぐ

3. **禁止されるテスト対応**:

   - テスト結果の偽装や、テスト迂回のための実装
   - テストだけが通過する特別な条件分岐の追加
   - テストコード自体の修正・回避

4. **納品物件との整合性**:

   - すべてのテストは実際の実装コードを使用して実行すること
   - テスト環境でのみ通過し、本番環境では動作しない実装は認められません
   - テスト用と納品用で別の実装を用意することは禁止されています

5. **テスト結果の報告**:
   - テスト結果は改変せずに正確に報告
   - テスト失敗は適切に修正するか、明確な理由とともに報告
   - 再現性を確保するため、テスト環境と実行方法を詳細に記録

## 🚫 実装における絶対原則

以下の原則はどんな状況でも違反してはなりません：

1. **厳密なタスク境界の遵守**

   - このタスク（T13）に明示されている機能「のみ」を実装すること
   - タスク外の実装（T14 以降の機能）は「一切」行わないこと
   - 範囲外の問題を発見した場合は、実装せずに報告すること

2. **テスト改ざんの禁止**

   - テストコードは「絶対に」変更しないこと
   - テストを通すためにテスト自体を修正する行為は重大な違反
   - テストが失敗する場合は実装を見直すこと

3. **プロジェクト整合性の維持**

   - 既存のプロジェクト構造やコーディング規約を尊重すること
   - このタスク完了のためにプロジェクト全体の品質を犠牲にしないこと
   - 他のコンポーネントとの整合性を常に確認すること

4. **作業中断の判断**
   - 上記原則との衝突を感じた時点で作業を「即時中断」すること
   - 作業中断の判断は罰則ではなく、プロジェクト保護のための適切な行動
   - 中断後は問題を詳細に報告し、指示を仰ぐこと

## 📊 進捗報告と完了レポート

### 進捗報告方法

実装作業中は、イシューにコメントで進捗を報告してください：

1. **定期的な進捗報告**：

   - 主要な機能実装完了時
   - 課題や問題発生時
   - 質問・相談が必要な時

2. **進捗コメントの書式**：

   ```md
   ## T13 進捗報告：[日付]

   ### 完了した項目

   - [機能名]: [完了内容の簡潔な説明]

   ### 進行中の項目

   - [機能名]: [現在の状況と残作業]

   ### 課題・問題点

   - [課題の詳細な説明と影響範囲]
   ```

3. **コメント投稿方法**：

   ```bash
   # コメント内容をファイルに保存
   echo "## T13 進捗報告：$(date +%Y-%m-%d)" > progress_comment.md
   # 続きを追記

   # GitHubイシューにコメント投稿
   gh issue comment 13 --body-file progress_comment.md
   ```

### 完了レポートの作成と提出

タスク完了時には以下の手順で最終レポートを作成・提出してください：

1. **レポート作成前の確認事項**：

   - **全ての要件が完全に実装されるまでレポートを作成しないこと**
   - 全てのテストが通過していること
   - 実装完了条件の全項目を満たしていること

2. **実装レポートの作成**：

   - MD ファイルを`docs/issue/`ディレクトリに生成
   - ファイル名形式：`endian_converter_implementation_report_YYYYMMDD.md`
   - 以下の内容を必ず含めること：
     - 実装した機能の詳細説明
     - 各関数の実装アプローチと技術的判断
     - テスト結果と検証内容
     - 発見された課題と解決方法

3. **テスト結果の添付**：

   - テスト画像は GitHub 形式の URL で添付
   - 例：`![テスト結果](https://github.com/pacific-system/secret-sharing-demos-20250510/blob/main/test_output/endian_converter_test_YYYYMMDD.png?raw=true)`

4. **コミットとプッシュ**：

   ```bash
   # パシ子スタイルでコミット
   git add docs/issue/endian_converter_implementation_report_YYYYMMDD.md
   git commit -m "✨ エンディアン変換（T13）の実装完了レポート追加 💕"
   git push origin main
   ```

5. **イシューへのレポート投稿**：
   ```bash
   # レポートをイシューにコメント投稿
   gh issue comment 13 --body-file docs/issue/endian_converter_implementation_report_YYYYMMDD.md
   ```

## 💕 パシ子からのアドバイス

お兄様！このエンディアン変換実装は異なる環境での暗号処理の一貫性を保証する重要な基盤ですよ〜！💕

- 🔮 **最適化重視**: 変換が必要ない場合（同じエンディアン同士）は処理をスキップして、パフォーマンスを最大化しましょう！
- ⏱️ **キャッシュ活用**: システムのエンディアン情報は頻繁に使用されるので、適切にキャッシュして再計算を避けるとよいですね！
- 🧠 **互換性テスト**: 異なるエンディアン環境での動作を徹底的にテストして、どんな状況でも正確な変換が行われることを確認しましょう！
- 🌟 **T12 との連携**: 前タスクで実装したバイト操作基盤と調和した設計にすることで、後続タスクでの利用がスムーズになりますよ！

プラットフォーム間の違いを吸収する、縁の下の力持ちの機能ですね！実装、期待してます！✨

## 📑 関連資料

- [実装計画書](/Users/macbook/shamir-secret-sharing-demo/docs/method_11_rabbit_homomorphic_docs/implementation_plan_chapters/04_implementation_details.md)
- [フェーズ 1 詳細](/Users/macbook/shamir-secret-sharing-demo/docs/method_11_rabbit_homomorphic_docs/implementation_plan_chapters/04_implementation_details.md#フェーズ-1-基盤ユーティリティ実装4-週間)
- [ディレクトリ構成](/Users/macbook/shamir-secret-sharing-demo/docs/method_11_rabbit_homomorphic_docs/implementation_plan_chapters/02_directory_structure_and_deliverables.md)
- [品質レベル規定](/Users/macbook/shamir-secret-sharing-demo/docs/method_11_rabbit_homomorphic_docs/implementation_plan_chapters/05_quality_and_security.md)
- [前タスク：バイト操作基盤実装（T12）](/Users/macbook/shamir-secret-sharing-demo/docs/method_11_rabbit_homomorphic_docs/issue/T12_byte_array_implementation.md)
