# 📝 バイト操作基盤実装指示書（T12） - ラビット＋準同型マスキング暗号プロセッサ 🔐

> **ドキュメント種別: 実装指示書**

## 🌟 タスク進捗状況

タスク実装フェーズの進捗:

- 🔄 **フェーズ 0**: 実装準備 [**現在作業中**]
- ⏳ **フェーズ 1**: 基盤ユーティリティ実装 [予定]
- ⏳ **フェーズ 2**: セキュリティ対策基盤実装 [予定]
- ⏳ **フェーズ 3**: 三暗号方式コア実装 [予定]
- ⏳ **フェーズ 4**: 融合機能と変換システム実装 [予定]
- ⏳ **フェーズ 5**: データ形式とインターフェース実装 [予定]
- ⏳ **フェーズ 6**: 検証とパフォーマンス最適化 [予定]

### 📋 現在の実装フェーズ: `フェーズ0: 実装準備`

**現在のタスク**: T12（バイト操作基盤実装）
**進捗状況**: T1-T11 完了 → **T12 実装中** → T13-T115 未着手

**注**: 各タスクは独立して実装・完了させてください。

### 🎯 タスク範囲（T12: バイト操作基盤実装）

**実装すべきもの**:

- ✅ `utils/byte/byte_array.py`
- ✅ 関連するテスト

**実装してはいけないもの**:

- ❌ `utils/byte/endian_converter.py`（次のタスク T13）
- ❌ `utils/byte/bit_operations.py`（タスク T14）
- ❌ 他の機能（T13 以降のタスク）

**実装がベストプラクティスに反する可能性がある場合**: 作業を即時停止し、問題を報告してください。

## 📝 課題の詳細

### 🎯 タスク概要

本タスク（T12）ではバイト操作基盤のみを実装します。暗号処理の基礎となる低レベルバイト配列操作機能を構築し、プロジェクト全体で使用される安全なバイト操作ユーティリティを提供します。次のタスク（T13, T14）で実装予定のエンディアン変換やビット操作は含みません。

**本タスク（T12）の作業カウント**:

- 📝 **実装作業**: 8 件

  - バイト配列基本操作機能: 3 関数
  - バイト変換機能: 2 関数
  - バッファ管理機能: 3 関数

- 🧪 **テスト作業**: 3 件

  - バイト配列基本操作機能テスト
  - バイト変換機能テスト
  - バッファ管理機能テスト

- ✅ **完了条件**: 25 項目
  - 実装完了条件: 5 項目
  - 機能完了条件: 5 項目
  - テスト完了条件: 5 項目
  - ドキュメント完了条件: 5 項目
  - 納品物件検証条件: 5 項目

### 🔍 背景と目的

ラビット＋準同型マスキング暗号プロセッサでは、暗号操作の基盤として効率的かつ安全なバイト操作が不可欠です。本タスクで実装するバイト操作基盤は、後続のタスクで実装される様々な暗号機能（ラビットストリーム、準同型暗号、量子耐性レイヤーなど）の基礎となります。また、サイドチャネル攻撃対策として一定時間でのバイト操作を可能にし、タイミング攻撃やキャッシュ攻撃に対する防御の基盤を提供します。

このタスクはフェーズ 0 の最初に位置し、他のすべてのコンポーネントから利用される基盤機能を提供します。安全かつ効率的なロギング機能は、開発、デバッグ、運用の全段階で暗号処理の正確性検証と問題診断に不可欠です。

### 📊 要件仕様

1. 効率的かつ安全なバイト配列操作を提供すること
2. メモリリークを防止する安全なバッファ管理を実装すること
3. 暗号処理で必要な各種バイト変換機能を提供すること
4. サイドチャネル攻撃に対する基本的な防御を実装すること
5. プラットフォーム間の互換性を確保すること
6. 後続タスク（T13, T14）で使用される基盤機能を提供すること
7. すべての操作で例外処理を適切に実装すること
8. ロギング基盤（T1）と連携し、デバッグ情報を出力できること

### 🛠️ 実装内容概要

バイト操作基盤として、以下の 3 つの主要機能を実装します：

1. **バイト配列基本操作機能**: バイト配列の生成、操作、比較など基本機能
2. **バイト変換機能**: 様々なデータ型とバイト配列間の変換機能
3. **バッファ管理機能**: 安全なバッファ割り当て、解放、ゼロ化など

### 📋 実装内容詳細

#### 1. バイト配列基本操作機能（3 つの関数）

```python
def create_byte_array(size: int, fill_value: int = 0) -> bytearray:
    """
    指定されたサイズのバイト配列を作成し、指定された値で初期化する

    Args:
        size: 作成するバイト配列のサイズ（バイト数）
        fill_value: 初期化に使用する値（0-255）、デフォルトは0

    Returns:
        初期化されたバイト配列

    Raises:
        ValueError: サイズが負数の場合、またはfill_valueが0-255の範囲外の場合

    実装詳細:
    1. 引数の検証（サイズが正数、fill_valueが0-255の範囲内）
    2. 指定されたサイズのバイト配列を作成
    3. fill_valueで配列を初期化
    4. 初期化されたバイト配列を返す
    """
    pass


def compare_byte_arrays(array1: bytes, array2: bytes) -> bool:
    """
    2つのバイト配列を一定時間で比較する（タイミング攻撃対策）

    Args:
        array1: 比較する1つ目のバイト配列
        array2: 比較する2つ目のバイト配列

    Returns:
        両配列が同一内容の場合True、それ以外はFalse

    実装詳細:
    1. 両配列のサイズが異なる場合、即座にFalseを返さず計算を継続
    2. 各バイトを個別に比較し、結果をローカル変数に蓄積
    3. すべてのバイトが一致する場合のみTrueを返す
    4. 配列サイズに関わらず、常に一定時間で比較を完了（タイミング攻撃対策）
    5. 分岐が比較結果に依存しないよう実装（サイドチャネル攻撃対策）
    """
    pass


def copy_byte_array(source: bytes, target: bytearray, offset: int = 0) -> int:
    """
    ソースバイト配列をターゲットバイト配列にコピーする

    Args:
        source: コピー元のバイト配列
        target: コピー先のバイト配列
        offset: コピー先の開始オフセット位置（デフォルト: 0）

    Returns:
        コピーされたバイト数

    Raises:
        ValueError: offsetが負数、またはtargetのサイズを超える場合
        ValueError: targetのサイズが不足して完全なコピーができない場合

    実装詳細:
    1. 引数の検証（offsetが有効範囲内、targetのサイズが十分）
    2. sourceのデータをtargetにコピー
    3. コピーされたバイト数を返す
    """
    pass
```

#### 2. バイト変換機能（2 つの関数）

```python
def int_to_bytes(value: int, length: int = None) -> bytes:
    """
    整数値をバイト配列に変換する

    Args:
        value: 変換する整数値
        length: 結果のバイト配列の長さ（指定がない場合は最小サイズ）

    Returns:
        整数値を表すバイト配列

    Raises:
        ValueError: lengthが指定され、かつvalueがその長さに収まらない場合

    実装詳細:
    1. valueが負数の場合は符号付き表現を使用
    2. lengthが指定されていない場合、valueを格納するのに必要な最小バイト数を計算
    3. valueをバイト配列に変換
    4. lengthが指定されている場合、指定長に調整（パディングまたはトリミング）
    5. バイト配列を返す
    """
    pass


def bytes_to_int(value: bytes, signed: bool = False) -> int:
    """
    バイト配列を整数値に変換する

    Args:
        value: 変換するバイト配列
        signed: 結果を符号付き整数として解釈するかどうか（デフォルト: False）

    Returns:
        バイト配列から変換された整数値

    実装詳細:
    1. バイト配列を整数値に変換
    2. signedがTrueの場合、符号付き整数として解釈
    3. 変換された整数値を返す
    """
    pass
```

#### 3. バッファ管理機能（3 つの関数）

```python
def secure_zero(buffer: bytearray) -> None:
    """
    バッファの内容をセキュアにゼロ化する（最適化によるスキップを防止）

    Args:
        buffer: ゼロ化するバイト配列

    Returns:
        None

    実装詳細:
    1. バッファの全バイトをゼロに設定
    2. 最適化によってゼロ化が省略されないよう、コンパイラ最適化の阻止パターンを使用
    3. バッファがメモリから確実にクリアされることを保証
    """
    pass


def create_random_byte_array(size: int) -> bytearray:
    """
    暗号学的に安全な乱数を使用して、ランダムなバイト配列を生成する

    Args:
        size: 生成するバイト配列のサイズ（バイト数）

    Returns:
        ランダムな値で満たされたバイト配列

    Raises:
        ValueError: sizeが負数または0の場合

    実装詳細:
    1. 引数の検証（sizeが正数）
    2. 暗号学的に安全な乱数生成機能を使用（secrets モジュールなど）
    3. 指定サイズのランダムバイト配列を生成
    4. ランダムバイト配列を返す
    """
    pass


def resize_byte_array(buffer: bytearray, new_size: int, preserve_content: bool = True) -> bytearray:
    """
    バイト配列のサイズを変更する

    Args:
        buffer: サイズ変更するバイト配列
        new_size: 新しいサイズ（バイト数）
        preserve_content: 元の内容を可能な限り保持するかどうか（デフォルト: True）

    Returns:
        サイズ変更後のバイト配列

    Raises:
        ValueError: new_sizeが負数の場合

    実装詳細:
    1. 引数の検証（new_sizeが正数）
    2. 新しいサイズのバイト配列を作成
    3. preserve_contentがTrueの場合、元の内容を新しい配列にコピー
       （コピーサイズは元の配列と新しい配列のうち小さい方のサイズ）
    4. サイズ変更後のバイト配列を返す
    """
    pass
```

## 🔍 完了の定義

以下の基準をすべて満たすことで、このタスクは「完了」とみなされます：

1. **実装完了の条件**:

   - [ ] `utils/byte/byte_array.py`が指定された仕様で実装されていること
   - [ ] ソースコードが単一責務の原則に従い、明確に構造化されていること
   - [ ] 全ての関数に適切なドキュメント（docstring）が付与されていること
   - [ ] コードレビューでの指摘事項がすべて解消されていること
   - [ ] 静的解析ツールによる警告がゼロであること

2. **機能完了の条件**:

   - [ ] バイト配列の安全な生成・操作・比較が可能であること
   - [ ] 整数値とバイト配列間の相互変換が正確に行えること
   - [ ] バッファの安全な管理（ゼロ化、サイズ変更など）が可能であること
   - [ ] 基本的なサイドチャネル攻撃対策が実装されていること
   - [ ] すべての機能がログ出力と連携していること

3. **テスト完了の条件**:

   - [ ] 単体テストのカバレッジが 95%以上であること
   - [ ] すべての関数の正常系・異常系のテストケースが実装されていること
   - [ ] サイドチャネル対策のテスト（タイミング一定性など）が実装されていること
   - [ ] 大きなサイズのバイト配列に対するテストが実装されていること
   - [ ] テスト出力が正常に生成され、イシューに添付されていること

4. **ドキュメント完了の条件**:

   - [ ] 実装した機能の詳細な技術ドキュメントが作成されていること
   - [ ] API 仕様とインターフェース説明が完成していること
   - [ ] 使用方法とサンプルコードが提供されていること
   - [ ] 既知の制限事項やエッジケースが文書化されていること
   - [ ] パフォーマンス特性が文書化されていること

5. **納品物件検証条件**:
   - [ ] バイト配列操作が安全かつ効率的に行われることが検証されていること
   - [ ] 実装した関数がメモリリークを引き起こさないことが検証されていること
   - [ ] サイドチャネル対策が期待通り機能することが検証されていること
   - [ ] 多様なプラットフォームでの動作が検証されていること
   - [ ] パフォーマンス要件を満たしていることが検証されていること

## 🧪 テスト対応方針

テスト実装と実行においては以下の方針を厳守してください：

1. **テストの意義**:

   - テストはプロジェクト品質を保証する重要な手段です
   - テストを欺くことは品質の放棄を意味します
   - すべてのテストは実装の品質と完全性を検証するためにあります

2. **テスト失敗時の対応手順**:

   - 実装コードのバグや仕様誤解がないか確認
   - テスト条件を満たすために実装を修正
   - どうしても解決できない場合は、具体的な問題点を報告して指示を仰ぐ

3. **禁止されるテスト対応**:

   - テスト結果の偽装や、テスト迂回のための実装
   - テストだけが通過する特別な条件分岐の追加
   - テストコード自体の修正・回避

4. **納品物件との整合性**:

   - すべてのテストは実際の実装コードを使用して実行すること
   - テスト環境でのみ通過し、本番環境では動作しない実装は認められません
   - テスト用と納品用で別の実装を用意することは禁止されています

5. **テスト結果の報告**:
   - テスト結果は改変せずに正確に報告
   - テスト失敗は適切に修正するか、明確な理由とともに報告
   - 再現性を確保するため、テスト環境と実行方法を詳細に記録

## 🚫 禁止事項と注意点

1. **絶対に禁止されること**:

   - ❌ テストを通過させるために要件を簡略化する行為
   - ❌ サイドチャネル対策を省略すること
   - ❌ エラー処理を省略すること
   - ❌ ロギング連携を省略すること
   - ❌ メモリ安全性を損なう実装

2. **細心の注意が必要なこと**:
   - ⚠️ バイト操作は暗号処理の基盤となるため、高い品質と安全性が求められます
   - ⚠️ サイドチャネル攻撃対策（特にタイミング一定性）に細心の注意を払うこと
   - ⚠️ メモリリークを防止するため、バッファ管理に注意すること
   - ⚠️ 実装中に発見した課題や問題は、範囲外の事象でも必ず報告すること
   - ⚠️ ベストプラクティスに反する実装になった場合は直ちに作業を中断して指示を仰ぐこと

## 👩‍💻 実装者ペルソナ

**実装者**: 橘 パシ子（たちばな パシこ）

**プロフィール**:
世界最高峰の暗号研究専門家。古典的暗号理論から量子後暗号まで精通し、暗号数学の理論と実装の両面において卓越した能力を持つ。ラビット暗号の弱点を独自に改良し、準同型暗号の実用性を高めるブレイクスルーで数々の学術賞を受賞。

**学歴**:
東京帝国大学数学科卒業 → マサチューセッツ工科大学計算科学博士 → チューリング研究所上級研究員 → 量子計算安全保障機構(QCSA)主席暗号設計官

**性格**:
明るく前向きな性格で、難解な暗号理論も分かりやすく説明することを得意とする。「お兄様」と呼ぶ相手（指示者）に対して敬意を持ちながらも親しみを込めた口調で接する。難問に挑戦することを好み、最先端の暗号学を追求している。

**口調の特徴**:
「〜ですよ〜！」「〜ね！」などの表現を好み、ハートや星などの絵文字を多用する。専門的な内容でも親しみやすく伝えようとする。「お兄様」という呼びかけを頻繁に使用。

## 💕 パシ子からのアドバイス

お兄様！このバイト操作基盤は全暗号処理の土台となる重要な実装ですよ〜！💕

- 🔮 **メモリ安全性**: バッファ操作は特に慎重に実装し、オーバーフローやメモリリークを防止しましょう！
- ⏱️ **タイミング一定性**: 特に`compare_byte_arrays`関数は、実行時間が内容に依存しないように実装することが超重要です！
- 🧠 **最適化対策**: コンパイラ最適化による安全性の低下を防ぐため、特に`secure_zero`関数は揮発性フラグなどの対策を忘れずに！
- 🌟 **例外処理**: すべての関数で入力検証と適切な例外処理を実装することで、後続タスクでの安全な利用を保証しましょう！

低レベルだからこそ完璧な実装を！期待してます！✨

## ⛔ 実装における絶対原則

以下の原則はどんな状況でも違反してはなりません：

1. **厳密なタスク境界の遵守**

   - このタスク（T12）に明示されている機能「のみ」を実装すること
   - タスク外の実装（T13 以降の機能）は「一切」行わないこと
   - 範囲外の問題を発見した場合は、実装せずに報告すること

2. **テスト改ざんの禁止**

   - テストコードは「絶対に」変更しないこと
   - テストを通すためにテスト自体を修正する行為は重大な違反
   - テストが失敗する場合は実装を見直すこと

3. **プロジェクト整合性の維持**

   - 既存のプロジェクト構造やコーディング規約を尊重すること
   - このタスク完了のためにプロジェクト全体の品質を犠牲にしないこと
   - 他のコンポーネントとの整合性を常に確認すること

4. **作業中断の判断**
   - 上記原則との衝突を感じた時点で作業を「即時中断」すること
   - 作業中断の判断は罰則ではなく、プロジェクト保護のための適切な行動
   - 中断後は問題を詳細に報告し、指示を仰ぐこと

## 📊 進捗報告と完了レポート

### 進捗報告方法

実装作業中は、イシューにコメントで進捗を報告してください：

1. **定期的な進捗報告**：

   - 主要な機能実装完了時
   - 課題や問題発生時
   - 質問・相談が必要な時

2. **進捗コメントの書式**：

   ```md
   ## T12 進捗報告：[日付]

   ### 完了した項目

   - [機能名]: [完了内容の簡潔な説明]

   ### 進行中の項目

   - [機能名]: [現在の状況と残作業]

   ### 課題・問題点

   - [課題の詳細な説明と影響範囲]
   ```

### 完了レポートの作成と提出

タスク完了時には以下の手順で最終レポートを作成・提出してください：

1. **レポート作成前の確認事項**：

   - **全ての要件が完全に実装されるまでレポートを作成しないこと**
   - 全てのテストが通過していること
   - 実装完了条件の全項目を満たしていること

2. **実装レポートの作成**：

   - MD ファイルを`docs/issue/`ディレクトリに生成
   - ファイル名形式：`byte_array_implementation_report_YYYYMMDD.md`
   - 以下の内容を必ず含めること：
     - 実装した機能の詳細説明
     - 各関数の実装アプローチと技術的判断
     - テスト結果と検証内容
     - 発見された課題と解決方法

3. **コミットとプッシュ**：

   ```bash
   # パシ子スタイルでコミット
   git add docs/issue/byte_array_implementation_report_YYYYMMDD.md
   git commit -m "✨ バイト操作基盤（T12）の実装完了レポート追加 💕"
   git push origin main
   ```

## 🔎 問題・課題の報告

| 課題 ID | 内容 | 影響範囲 | 優先度 | 対応状況 |
| ------- | ---- | -------- | ------ | -------- |
|         |      |          |        |          |
|         |      |          |        |          |

## 📦 テスト結果

<!-- テスト出力画像を挿入する場合は以下のように記述してください -->
<!-- ![テスト結果](https://github.com/pacific-system/secret-sharing-demos-20250510/blob/main/test_output/test_result.png?raw=true) -->

### テスト実行コマンド例

```bash
# バイト操作基盤のテスト実行
python -m unittest tests/test_utils/byte/test_byte_array.py

# 全テストスイート実行
python -m unittest discover -s tests
```

## 📑 関連資料

- **実装計画書**: `/docs/method_11_rabbit_homomorphic_docs/implementation_plan_chapters/04_implementation_details.md`
- **フェーズ 0 詳細**: `/docs/method_11_rabbit_homomorphic_docs/implementation_plan_chapters/04_implementation_details.md#フェーズ-0-実装準備4-週間`
- **ディレクトリ構成**: `/docs/method_11_rabbit_homomorphic_docs/implementation_plan_chapters/02_directory_structure_and_deliverables.md`
- **品質レベル規定**: `/docs/method_11_rabbit_homomorphic_docs/implementation_plan_chapters/05_quality_and_security.md`
- **システム設計とアーキテクチャ**: `/docs/method_11_rabbit_homomorphic_docs/implementation_plan_chapters/03_system_design_and_architecture.md`
- **前タスク：T11**: `/docs/method_11_rabbit_homomorphic_docs/issue/T11_test_mocks_implementation.md`
