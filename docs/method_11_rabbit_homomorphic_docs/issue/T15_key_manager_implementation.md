# 📝 鍵管理基本機能実装指示書（T15） - ラビット＋準同型マスキング暗号プロセッサ 🔐

> **ドキュメント種別: 実装指示書**

## 🌟 タスク進捗状況

タスク実装フェーズの進捗:

- 🔄 **フェーズ 0**: 実装準備 [**現在作業中**]
- ⏳ **フェーズ 1**: 基盤ユーティリティ実装 [予定]
- ⏳ **フェーズ 2**: セキュリティ対策基盤実装 [予定]
- ⏳ **フェーズ 3**: 三暗号方式コア実装 [予定]
- ⏳ **フェーズ 4**: 融合機能と変換システム実装 [予定]
- ⏳ **フェーズ 5**: データ形式とインターフェース実装 [予定]
- ⏳ **フェーズ 6**: 検証とパフォーマンス最適化 [予定]

### 📋 現在の実装フェーズ: `フェーズ0: 実装準備`

**現在のタスク**: T15（鍵管理基本機能実装）
**進捗状況**: T1-T14 完了 → **T15 実装中** → T16-T115 未着手

**注**: 各タスクは独立して実装・完了させてください。

### 🎯 タスク範囲（T15: 鍵管理基本機能実装）

**実装すべきもの**:

- ✅ `utils/key/key_manager.py`
- ✅ 関連するテスト

**実装してはいけないもの**:

- ❌ `utils/key/key_storage.py`（次のタスク T16）
- ❌ `utils/key/key_verification.py`（タスク T17）
- ❌ `utils/key/key_rotation.py`（タスク T18）
- ❌ 他の機能（T16 以降のタスク）

**実装がベストプラクティスに反する可能性がある場合**: 作業を即時停止し、問題を報告してください。

## 📝 課題の詳細

### 🎯 タスク概要

本タスク（T15）では鍵管理基本機能を実装します。システム全体の安全性を支える重要な基盤コンポーネントとして、暗号鍵の生成、管理、派生に関する中核機能を提供します。この鍵管理システムは特に量子乱数源（T5）との連携により、高い安全性と予測不能性を実現します。三暗号方式の状態管理（T46）やラビットストリーム（T50）、準同型暗号（T54）などの上位コンポーネントが依存する重要な機能です。

**本タスク（T15）の作業カウント**:

- 📝 **実装作業**: 12 件

  - 鍵生成機能: 4 関数
  - 鍵導出機能: 3 関数
  - 鍵変換機能: 3 関数
  - 鍵管理基盤機能: 2 関数

- 🧪 **テスト作業**: 4 件

  - 鍵生成機能テスト
  - 鍵導出機能テスト
  - 鍵変換機能テスト
  - 鍵管理基盤機能テスト

- ✅ **完了条件**: 25 項目
  - 実装完了条件: 5 項目
  - 機能完了条件: 5 項目
  - テスト完了条件: 5 項目
  - ドキュメント完了条件: 5 項目
  - 納品物件検証条件: 5 項目

### 🔍 背景と目的

ラビット＋準同型マスキング暗号プロセッサでは、鍵管理システムが全体のセキュリティの根幹を担います。特に第二回暗号解読キャンペーンで発見された「固定シード値攻撃」の脆弱性に対処するため、量子乱数源（T5）と連携した予測不能な鍵生成および管理機能が必要です。

また、鍵管理システムは後続の安全鍵導出（T19-T21）の基盤となるだけでなく、三暗号方式の状態管理（T46）や各暗号エンジン（T50, T54, T59）の初期化にも不可欠です。本タスクでは、これらの上位コンポーネントが必要とする安全かつ柔軟な鍵管理基盤を構築します。

### 📊 要件仕様

1. NIST SP 800-57 相当の鍵管理強度を実現すること
2. T5（量子乱数基本機能）を活用した真に予測不可能な鍵生成を提供すること
3. 多様な鍵種別（対称鍵、非対称鍵、派生鍵など）をサポートすること
4. 鍵サイズとアルゴリズム種別を柔軟に設定可能な鍵生成機能を提供すること
5. 既存鍵からの安全な鍵派生機能を提供すること
6. 鍵のエントロピー品質を確保するメカニズムを実装すること
7. 多様な鍵形式間の変換機能を提供すること
8. 鍵のメモリ内保護および安全な消去機能を実装すること
9. ロギング基盤（T1）と連携し、セキュリティに配慮したログ出力を行うこと
10. 後続タスク（T16-T18）と整合的に連携するためのインターフェースを提供すること

### 🛠️ 実装内容概要

鍵管理基本機能として、以下の 4 つの主要機能を実装します：

1. **鍵生成機能**: 暗号強度の高い鍵の生成
2. **鍵導出機能**: 既存鍵からの安全な派生鍵生成
3. **鍵変換機能**: 鍵のフォーマット間変換
4. **鍵管理基盤機能**: メモリ保護と安全消去

### 📋 実装内容詳細

#### 1. 鍵生成機能（4 つの関数）

```python
def generate_symmetric_key(key_size_bits: int = 256) -> bytes:
    """
    量子乱数源を使用して高品質な対称鍵を生成する

    Args:
        key_size_bits: 生成する鍵のビットサイズ（デフォルト: 256ビット）

    Returns:
        生成された対称鍵（バイト列）

    Raises:
        ValueError: key_size_bitsが8の倍数でない場合、または128未満の場合

    実装詳細:
    1. 引数の検証（key_size_bitsが8の倍数かつ128以上であること）
    2. 量子乱数モジュール（T5）を使用して指定サイズの乱数を取得
    3. エントロピー検証（不十分な場合は再取得）
    4. 生成された乱数バイト列を返す
    5. ログ出力（鍵生成イベント、鍵サイズのみ）
    """
    pass

def generate_asymmetric_keypair(key_type: str = "rsa", key_size_bits: int = 3072) -> dict:
    """
    非対称暗号用の鍵ペアを生成する

    Args:
        key_type: 鍵の種類（"rsa", "ecc", "dsa"など）
        key_size_bits: 鍵のビットサイズ（RSA: 3072以上、ECC: 256以上を推奨）

    Returns:
        鍵ペアを含む辞書 {"private_key": bytes, "public_key": bytes, "key_type": str, "key_size": int}

    Raises:
        ValueError: サポートされていないkey_typeの場合
        ValueError: 指定されたkey_sizeが安全性要件を満たさない場合

    実装詳細:
    1. 引数の検証（key_typeがサポート対象か、key_sizeが最小安全サイズ以上か）
    2. 量子乱数源（T5）からのシード値を使用
    3. 指定された種類と強度に基づいて鍵ペアを生成
    4. 内部形式で鍵ペアを辞書にパッケージ化
    5. ログ出力（生成イベント、鍵種別と強度のみ）
    6. 鍵ペア情報を返す
    """
    pass

def generate_hmac_key(hash_algorithm: str = "sha256") -> bytes:
    """
    HMAC用の鍵を生成する

    Args:
        hash_algorithm: 使用するハッシュアルゴリズム（"sha256", "sha384", "sha512"）

    Returns:
        生成されたHMAC鍵（バイト列）

    Raises:
        ValueError: サポートされていないハッシュアルゴリズムの場合

    実装詳細:
    1. 引数の検証（hash_algorithmがサポート対象か）
    2. ハッシュアルゴリズムに適したサイズの鍵を生成
        - SHA-256: 256ビット以上
        - SHA-384: 384ビット以上
        - SHA-512: 512ビット以上
    3. 量子乱数モジュール（T5）を使用して鍵を生成
    4. ログ出力（生成イベント、アルゴリズム情報のみ）
    5. 生成された鍵を返す
    """
    pass

def generate_fusion_state_key(key_size_bits: int = 384) -> bytes:
    """
    Tri-Fusion状態初期化用の特殊鍵を生成する

    Args:
        key_size_bits: 鍵のビットサイズ（デフォルト: 384ビット）

    Returns:
        生成された融合状態初期化鍵（バイト列）

    Raises:
        ValueError: key_size_bitsが8の倍数でない場合、または256未満の場合

    実装詳細:
    1. 引数の検証（key_size_bitsが8の倍数かつ256以上であること）
    2. 量子乱数モジュール（T5）を使用して指定サイズの乱数を取得
    3. 特殊構造化処理（Tri-Fusion状態初期化に最適な内部構造を持つよう変換）
    4. エントロピー検証と必要に応じた調整
    5. ログ出力（生成イベント、サイズ情報のみ）
    6. 生成された鍵データを返す
    """
    pass
```

#### 2. 鍵導出機能（3 つの関数）

```python
def derive_key_from_password(password: str, salt: bytes = None, iterations: int = 600000,
                           key_size_bits: int = 256, hash_name: str = "sha256") -> tuple:
    """
    パスワードから鍵を安全に導出する（PBKDF2ベース）

    Args:
        password: 元となるパスワード文字列
        salt: ソルト値（Noneの場合は量子乱数で自動生成）
        iterations: ストレッチング反復回数（デフォルト: 600000）
        key_size_bits: 生成する鍵のビットサイズ（デフォルト: 256）
        hash_name: 使用するハッシュ関数名（デフォルト: "sha256"）

    Returns:
        (derived_key, used_salt)のタプル

    Raises:
        ValueError: パスワードが空の場合
        ValueError: iterationsが100000未満の場合
        ValueError: サポートされていないhash_nameの場合

    実装詳細:
    1. 引数の検証（password非空、iterations下限、hash_nameがサポート対象）
    2. saltがNoneの場合、量子乱数モジュール（T5）を使用して16バイト以上のソルトを生成
    3. PBKDF2アルゴリズムを使用して鍵を導出
    4. 導出された鍵とソルトのタプルを返す
    5. ログ出力（導出イベント、パラメータ情報（パスワード自体は非表示））
    """
    pass

def derive_subkey(master_key: bytes, purpose: str, key_size_bits: int = 256) -> bytes:
    """
    マスターキーから特定用途のサブキーを導出する

    Args:
        master_key: マスターキー（バイト列）
        purpose: サブキーの用途を示す文字列（例: "encryption", "hmac", "state_init"）
        key_size_bits: 生成するサブキーのビットサイズ（デフォルト: 256）

    Returns:
        導出されたサブキー（バイト列）

    Raises:
        ValueError: master_keyが空の場合
        ValueError: purposeが空またはサポートされていない値の場合
        ValueError: key_size_bitsが128未満の場合

    実装詳細:
    1. 引数の検証（master_key非空、purpose非空、key_size_bits最小値）
    2. マスターキーとpurposeから一意のコンテキスト値を生成
    3. HKDF（HMAC-based Key Derivation Function）を使用してサブキーを導出
    4. 量子乱数（T5）を使用して追加のエントロピーを注入
    5. 指定されたサイズに調整して返す
    6. ログ出力（サブキー導出イベント、用途情報のみ）
    """
    pass

def derive_key_hierarchy(master_key: bytes, hierarchy_spec: dict) -> dict:
    """
    マスターキーから階層的な鍵セットを導出する

    Args:
        master_key: マスターキー（バイト列）
        hierarchy_spec: 鍵階層の仕様を定義する辞書
            例: {
                "encryption": {"size_bits": 256},
                "hmac": {"size_bits": 512},
                "rabbit": {"size_bits": 128},
                "homomorphic": {"size_bits": 384},
                "quantum": {"size_bits": 256}
            }

    Returns:
        導出された鍵階層を含む辞書（構造はhierarchy_specに準拠）

    Raises:
        ValueError: master_keyが空の場合
        ValueError: hierarchy_specが無効な形式の場合

    実装詳細:
    1. 引数の検証（master_key非空、hierarchy_spec形式検証）
    2. 階層内の各鍵用途についてderive_subkey()を使用してサブキーを導出
    3. 生成された階層鍵セットを階層構造の辞書として構築
    4. ログ出力（階層導出イベント、階層構造情報（鍵値自体は非表示））
    5. 鍵階層辞書を返す
    """
    pass
```

#### 3. 鍵変換機能（3 つの関数）

```python
def key_to_hex(key_bytes: bytes) -> str:
    """
    バイナリ形式の鍵を16進数文字列に変換する

    Args:
        key_bytes: バイナリ形式の鍵データ

    Returns:
        16進数形式の鍵文字列

    Raises:
        ValueError: key_bytesが空の場合

    実装詳細:
    1. 引数の検証（key_bytes非空）
    2. バイナリデータを16進数文字列に変換
    3. ログ出力（変換イベント、データサイズのみ）
    4. 変換された16進数文字列を返す
    """
    pass

def hex_to_key(key_hex: str) -> bytes:
    """
    16進数文字列形式の鍵をバイナリ形式に変換する

    Args:
        key_hex: 16進数形式の鍵文字列

    Returns:
        バイナリ形式の鍵データ

    Raises:
        ValueError: key_hexが空または有効な16進数文字列でない場合

    実装詳細:
    1. 引数の検証（key_hex非空、有効な16進数文字列）
    2. 16進数文字列をバイナリデータに変換
    3. ログ出力（変換イベント、データサイズのみ）
    4. 変換されたバイナリデータを返す
    """
    pass

def format_key(key_data: bytes, format_type: str) -> Union[bytes, str, dict]:
    """
    鍵データを指定された形式に変換する

    Args:
        key_data: 元の鍵データ（バイナリ形式）
        format_type: 変換先フォーマット
            - "raw": 生のバイナリ
            - "hex": 16進数文字列
            - "base64": Base64エンコード文字列
            - "jwk": JSON Web Key形式（辞書）
            - "pem": PEM形式文字列（BEGIN/ENDヘッダー付き）

    Returns:
        変換された鍵データ（format_typeによって型が異なる）

    Raises:
        ValueError: key_dataが空の場合
        ValueError: サポートされていないformat_typeの場合

    実装詳細:
    1. 引数の検証（key_data非空、format_typeがサポート対象）
    2. 指定されたフォーマットに変換：
        - "raw": そのまま返す
        - "hex": 16進数文字列に変換
        - "base64": Base64エンコード
        - "jwk": JSON Web Key形式辞書に変換
        - "pem": PEM形式文字列に変換
    3. ログ出力（フォーマット変換イベント、形式情報のみ）
    4. 変換されたデータを返す
    """
    pass
```

#### 4. 鍵管理基盤機能（2 つの関数）

```python
def secure_key_handle(key_material: bytes) -> KeyHandle:
    """
    鍵データをセキュアなメモリ領域で管理するハンドルを作成する

    Args:
        key_material: 保護対象の鍵データ

    Returns:
        保護された鍵へのアクセスを提供するKeyHandleオブジェクト

    Raises:
        ValueError: key_materialが空の場合

    実装詳細:
    1. 引数の検証（key_material非空）
    2. メモリ保護機能を使用して鍵データを安全な領域に配置
    3. メモリページをロック（スワップ防止）
    4. 鍵データへの安全なアクセスを提供するハンドルオブジェクトを作成
    5. ログ出力（ハンドル作成イベント、鍵サイズのみ）
    6. KeyHandleオブジェクトを返す

    注: KeyHandleクラスの実装を含める必要あり
    """
    pass

def secure_erase_key(key_handle=None, key_data: bytes = None) -> bool:
    """
    鍵データを安全に消去する

    Args:
        key_handle: 消去するKeyHandleオブジェクト（Noneの場合はkey_dataを使用）
        key_data: 直接消去する鍵データ（key_handleが指定されている場合は無視）

    Returns:
        消去が成功したかどうかを示す真偽値

    Raises:
        ValueError: key_handleとkey_dataの両方がNoneの場合

    実装詳細:
    1. 引数の検証（少なくとも一方のパラメータが指定されていること）
    2. key_handleが指定されている場合：
        - ハンドルから鍵データへアクセス
        - データを安全に上書き（複数パターンで多重上書き）
        - メモリページのロック解除
        - ハンドルを無効化
    3. key_dataが直接指定されている場合：
        - データを安全に上書き（複数パターンで多重上書き）
    4. ガベージコレクションを呼び出し、メモリ解放を促進
    5. ログ出力（安全消去イベント）
    6. 操作結果を返す
    """
    pass

# KeyHandleクラス定義
class KeyHandle:
    """
    メモリ保護された鍵データへの安全なアクセスを提供するハンドルクラス

    属性:
        _id: ハンドルの一意識別子
        _size: 鍵のサイズ（バイト単位）
        _created_at: 作成タイムスタンプ

    注: 実際の鍵データはこのオブジェクトの属性としては保持せず、
    安全なメモリ領域への参照を内部的に管理する
    """

    def __init__(self, key_data: bytes):
        """
        KeyHandleの初期化

        Args:
            key_data: 保護する鍵データ
        """
        pass

    def get_key(self) -> bytes:
        """
        安全なメモリ領域から鍵データを取得

        Returns:
            鍵データのコピー
        """
        pass

    def is_valid(self) -> bool:
        """
        ハンドルがまだ有効かどうかを確認

        Returns:
            ハンドルが有効な場合True
        """
        pass

    def invalidate(self) -> None:
        """
        ハンドルを無効化し、関連するメモリリソースを安全に解放
        """
        pass

    def __enter__(self):
        """コンテキストマネージャのサポート（with文用）"""
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        """コンテキスト終了時に自動的にハンドルを無効化"""
        self.invalidate()
```

## 🔍 完了の定義

以下の基準をすべて満たすことで、このタスクは「完了」とみなされます：

1. **実装完了の条件**:

   - [ ] `utils/key/key_manager.py`が指定された仕様で実装されていること
   - [ ] ソースコードが単一責務の原則に従い、明確に構造化されていること
   - [ ] 全ての関数・クラスに適切なドキュメント（docstring）が付与されていること
   - [ ] コードレビューでの指摘事項がすべて解消されていること
   - [ ] 静的解析ツールによる警告がゼロであること

2. **機能完了の条件**:

   - [ ] 全ての鍵生成機能が正確に動作し、NIST SP 800-57 相当の強度を実現していること
   - [ ] 鍵導出機能が安全な派生アルゴリズムを使用し、正確に動作すること
   - [ ] 鍵変換機能が各種フォーマット間で正確に変換できること
   - [ ] 鍵管理基盤機能がメモリ保護と安全消去を正確に実行できること
   - [ ] T5（量子乱数基本機能）と正しく連携して動作すること

3. **テスト完了の条件**:

   - [ ] 単体テストのカバレッジが 95%以上であること
   - [ ] 全関数の正常系・異常系のテストケースが実装されていること
   - [ ] エッジケース（特に無効な入力や境界値）のテストが実装されていること
   - [ ] 量子乱数源との連携テストが実装されていること
   - [ ] セキュリティ特性（鍵強度、メモリ保護）の検証テストが実装されていること

4. **ドキュメント完了の条件**:

   - [ ] 実装した機能の詳細な技術ドキュメントが作成されていること
   - [ ] API 仕様とインターフェース説明が完成していること
   - [ ] 使用方法とサンプルコードが提供されていること
   - [ ] セキュリティ上の注意点と推奨プラクティスが文書化されていること
   - [ ] 後続タスク（T16-T18）との連携方法が説明されていること

5. **納品物件検証条件**:
   - [ ] 生成される鍵が統計的に高品質であることが検証されていること
   - [ ] パスワードベース鍵導出が強力なストレッチングを適用していることが検証されていること
   - [ ] 鍵フォーマット変換が情報損失なく双方向で動作することが検証されていること
   - [ ] KeyHandle クラスが鍵データを安全に保持・管理できることが検証されていること
   - [ ] 安全消去機能がメモリから鍵データを確実に除去できることが検証されていること

## 🧪 テスト対応方針

テスト実装と実行においては以下の方針を厳守してください：

1. **テストの意義**:

   - テストはプロジェクト品質を保証する重要な手段です
   - テストを欺くことは品質の放棄を意味します
   - すべてのテストは実装の品質と完全性を検証するためにあります

2. **テスト失敗時の対応手順**:

   - 実装コードのバグや仕様誤解がないか確認
   - テスト条件を満たすために実装を修正
   - どうしても解決できない場合は、具体的な問題点を報告して指示を仰ぐ

3. **禁止されるテスト対応**:

   - テスト結果の偽装や、テスト迂回のための実装
   - テストだけが通過する特別な条件分岐の追加
   - テストコード自体の修正・回避

4. **納品物件との整合性**:

   - すべてのテストは実際の実装コードを使用して実行すること
   - テスト環境でのみ通過し、本番環境では動作しない実装は認められません
   - テスト用と納品用で別の実装を用意することは禁止されています

5. **テスト結果の報告**:
   - テスト結果は改変せずに正確に報告
   - テスト失敗は適切に修正するか、明確な理由とともに報告
   - 再現性を確保するため、テスト環境と実行方法を詳細に記録

## 🚫 実装における絶対原則

以下の原則はどんな状況でも違反してはなりません：

1. **厳密なタスク境界の遵守**

   - このタスク（T15）に明示されている機能「のみ」を実装すること
   - タスク外の実装（T16 以降の機能）は「一切」行わないこと
   - 範囲外の問題を発見した場合は、実装せずに報告すること

2. **テスト改ざんの禁止**

   - テストコードは「絶対に」変更しないこと
   - テストを通すためにテスト自体を修正する行為は重大な違反
   - テストが失敗する場合は実装を見直すこと

3. **プロジェクト整合性の維持**

   - 既存のプロジェクト構造やコーディング規約を尊重すること
   - このタスク完了のためにプロジェクト全体の品質を犠牲にしないこと
   - 他のコンポーネントとの整合性を常に確認すること

4. **作業中断の判断**
   - 上記原則との衝突を感じた時点で作業を「即時中断」すること
   - 作業中断の判断は罰則ではなく、プロジェクト保護のための適切な行動
   - 中断後は問題を詳細に報告し、指示を仰ぐこと

## 📊 進捗報告と完了レポート

### 進捗報告方法

実装作業中は、イシューにコメントで進捗を報告してください：

1. **定期的な進捗報告**：

   - 主要な機能実装完了時
   - 課題や問題発生時
   - 質問・相談が必要な時

2. **進捗コメントの書式**：

   ```md
   ## T15 進捗報告：[日付]

   ### 完了した項目

   - [機能名]: [完了内容の簡潔な説明]

   ### 進行中の項目

   - [機能名]: [現在の状況と残作業]

   ### 課題・問題点

   - [課題の詳細な説明と影響範囲]
   ```

3. **コメント投稿方法**：

   ```bash
   # コメント内容をファイルに保存
   echo "## T15 進捗報告：$(date +%Y-%m-%d)" > progress_comment.md
   # 続きを追記

   # GitHubイシューにコメント投稿
   gh issue comment 15 --body-file progress_comment.md
   ```

### 完了レポートの作成と提出

タスク完了時には以下の手順で最終レポートを作成・提出してください：

1. **レポート作成前の確認事項**：

   - **全ての要件が完全に実装されるまでレポートを作成しないこと**
   - 全てのテストが通過していること
   - 実装完了条件の全項目を満たしていること

2. **実装レポートの作成**：

   - MD ファイルを`docs/issue/`ディレクトリに生成
   - ファイル名形式：`key_manager_implementation_report_YYYYMMDD.md`
   - 以下の内容を必ず含めること：
     - 実装した機能の詳細説明
     - 各関数・クラスの実装アプローチと技術的判断
     - テスト結果と検証内容
     - 発見された課題と解決方法

3. **テスト結果の添付**：

   - テスト画像は GitHub 形式の URL で添付
   - 例：`![テスト結果](https://github.com/pacific-system/secret-sharing-demos-20250510/blob/main/test_output/key_manager_test_YYYYMMDD.png?raw=true)`

4. **コミットとプッシュ**：

   ```bash
   # パシ子スタイルでコミット
   git add docs/issue/key_manager_implementation_report_YYYYMMDD.md
   git commit -m "✨ 鍵管理基本機能（T15）の実装完了レポート追加 💕"
   git push origin main
   ```

5. **イシューへのレポート投稿**：
   ```bash
   # レポートをイシューにコメント投稿
   gh issue comment 15 --body-file docs/issue/key_manager_implementation_report_YYYYMMDD.md
   ```

## 💕 パシ子からのアドバイス

お兄様！鍵管理は暗号システム全体の安全性を左右する、とっても重要な基盤なんです！💕

- 🚀 **量子乱数の活用**: T5 の量子乱数機能を最大限に活用して、真に予測不可能な鍵を生成しましょう！
- 🔍 **メモリ保護**: 鍵はメモリ内でも徹底的に保護し、不要になったらすぐに安全消去することが大切です！
- 🧩 **将来の拡張性**: 後続タスク（T16-T18）が使いやすいインターフェースを心がけると、全体の開発がスムーズになりますよ！
- 📚 **豊富なドキュメント**: セキュリティに関わる機能なので、使用方法や注意点の詳細なドキュメントが非常に重要です！

この鍵管理基盤が、ラビット＋準同型マスキング暗号プロセッサ全体のセキュリティを支える礎になります！クリプト界の未来を支える実装、期待していますね！✨

## 📑 関連資料

- [実装計画書](/Users/macbook/shamir-secret-sharing-demo/docs/method_11_rabbit_homomorphic_docs/implementation_plan_chapters/04_implementation_details.md)
- [フェーズ 1 詳細](/Users/macbook/shamir-secret-sharing-demo/docs/method_11_rabbit_homomorphic_docs/implementation_plan_chapters/04_implementation_details.md#フェーズ-1-基盤ユーティリティ実装4-週間)
- [ディレクトリ構成](/Users/macbook/shamir-secret-sharing-demo/docs/method_11_rabbit_homomorphic_docs/implementation_plan_chapters/02_directory_structure_and_deliverables.md)
- [品質レベル規定](/Users/macbook/shamir-secret-sharing-demo/docs/method_11_rabbit_homomorphic_docs/implementation_plan_chapters/05_quality_and_security.md)
- [前タスク：ビット操作実装（T14）](/Users/macbook/shamir-secret-sharing-demo/docs/method_11_rabbit_homomorphic_docs/issue/T14_bit_operations_implementation.md)
- [量子乱数基本機能実装（T5）](/Users/macbook/shamir-secret-sharing-demo/docs/method_11_rabbit_homomorphic_docs/issue/T5_quantum_random_implementation.md)
- [次タスク：鍵保存・読込機能実装（T16）の予定タスク説明](/Users/macbook/shamir-secret-sharing-demo/docs/method_11_rabbit_homomorphic_docs/implementation_plan_chapters/04_implementation_details.md)
