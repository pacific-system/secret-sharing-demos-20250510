# シャミア暗号化システム改善計画


## はじめに


このドキュメントは、シャミア秘密分散法による複数平文復号システムの初期化処理と暗号化ファイルフォーマットを改善するための計画書です。システムは暗号書庫として機能し、ファイル A とファイル B が同一の暗号ファイル内に混在して保管されます。このシステムの設計では、**ファイル種別ごとに1つのファイルしか暗号化できない**（ファイル A は1つ、ファイル B は1つ）という制約があります。


## 目次


1. [初期化時の暗号化ファイル生成に関する課題](#1-初期化時の暗号化ファイル生成に関する課題)
2. [初期化時の暗号化ファイル生成改善](#2-初期化時の暗号化ファイル生成改善)
3. [シェアフォーマットの最適化](#3-シェアフォーマットの最適化)
4. [UUIDを使用したファイル命名規則](#4-uuidを使用したファイル命名規則)
5. [実装計画と優先順位](#5-実装計画と優先順位)


## 1. 初期化時の暗号化ファイル生成に関する課題

## 現状の問題点

現在の実装では、初期化段階でゴミデータで埋められた暗号化ファイルの雛形が生成されていません。システムは暗号書庫として機能し、ファイル A とファイル B が同一の暗号ファイル内に混在して保管されます。これにより以下の問題が発生しています：

1. ファイル A のみ暗号化した際に、残りのスペースをゴミデータで埋める必要があり、効率的ではありません
2. ファイルサイズの変化から情報漏洩の可能性があります（例：いくつのファイルが含まれているか）
3. 暗号化ファイルのフォーマットが一貫していません
4. 初期化するたびに新たな UUID を持つ暗号ファイルが生成される必要があります
5. 初期化ファイルと暗号化済みファイルの区別が可能であり、セキュリティリスクが生じています
6. 過去のコードがシステム内に残されており、セキュリティ上の欠陥を含む古い実装が誤って使用される危険性があります

## セキュリティへの影響

現状の実装では、以下のセキュリティ上の懸念があります：

1. **統計的区別可能性**: ファイル追加ごとにファイルサイズが変化することで、ファイル内容に関する情報が漏洩する可能性
2. **タイミング攻撃**: 初期化と更新で処理時間が大きく異なることでサイドチャネル攻撃の可能性
3. **一貫性の欠如**: 暗号化ファイルの構造が常に同じではないため、解析が容易になる可能性
4. **ファイル関係性の漏洩**: 複数の暗号ファイルが存在する場合に関連性が推測される可能性
5. **ファイルタイプ識別リスク**: 初期化ファイルと暗号化済みファイルが外部から区別可能であり、どのファイルが実データを含むか特定される可能性
6. **コード混在リスク**: 過去の形式と新しい形式のコードが混在することで、古い脆弱な実装が使用されるリスクが生じます

## セキュリティ理念との乖離

現状の実装では、設計書の以下の重要なセキュリティ理念が実装されていません：

1. **MAP 決定論的生成原則**: パーティションキーとパスワードから全てのシェア位置情報が決定論的に生成される設計になっていないため、ファイル内でのシェア位置指定が冗長
2. **統計的区別不可能性**: 初期状態でランダムなゴミデータがないため、文書追加時の統計的区別が可能になっている
3. **二重の MAP 構造**: 設計書にある「第 1 段階 MAP（パーティションマップキー）」と「第 2 段階 MAP（パスワード）」の連携が不十分
4. **ファイル混在保管原則**: 設計ではファイル A とファイル B が同一の暗号ファイル内に混在して保管されることが想定されているが、これが明示的に実装されていない
5. **区別不能性原則**: 初期化ファイルと暗号化済みファイルが区別できないようにするという基本原則が守られていない
6. **コード純粋性原則**: セキュリティ上の欠陥を含む古いコードは完全に削除し、新たなセキュアな実装のみを残すという原則が守られていない

## 必要な改善点

1. 初期化時に完全な暗号化ファイルの雛形を生成する
2. すべてのシェア空間をランダムなゴミデータで埋める
3. シェアの格納方法を最適化する
4. ファイル命名方法を改善し、上書きを防止する
5. 多段 MAP の原理に完全準拠したシェア位置決定方式を実装
6. ファイル A とファイル B が同一の暗号ファイル内に混在保管される仕組みを明示的に実装する
7. 過去形式との互換性は一切考慮せず、セキュリティ基準から逸脱した実装を許容しない
8. 初期化ファイルと暗号化済みファイルが外部から区別できないよう、ファイル構造とヘッダー情報を統一する
9. 過去形式に関連するすべてのコードをコードベースから完全に削除し、新しい実装のみを残す

これらの改善により、暗号化システムのセキュリティと効率性を向上させることが可能です。過去形式はセキュリティ基準から逸脱した実装であるため、互換性は一切考慮せず、設計書の理念に完全準拠した新形式のみをサポートします。初期化ファイルと暗号化済みファイルが外部から区別できないようにすることで、どのファイルに実データが含まれているかという情報漏洩を防止し、システム全体のセキュリティを強化します。また、すべての過去形式関連コードを完全に削除することで、セキュリティ上の脆弱性を含む古い実装が誤って使用されるリスクを排除し、クリーンで安全なコードベースを確保します。



## 2. 初期化時の暗号化ファイル生成改善

## 初期化時の暗号化ファイル雛形生成

システム初期化時に、ゴミデータで埋められた暗号化ファイルの雛形を自動生成する機能を追加します。設計書の「パーティション空間設計」に厳密に準拠し、統計的区別不可能性を確保します。このシステムは暗号書庫として機能し、ファイル A とファイル B が同一の暗号ファイル内に混在して保管されます。**過去形式との互換性は一切考慮せず、設計書のセキュリティ基準に完全準拠した新しい形式のみを実装します。また、過去形式に関連するコード関数は全て削除し、新しい実装のみをコードベースに残します。**

### 仕様

1. **パーティション空間準拠**:

   - ファイル A 用領域：30-40%
   - ファイル B 用領域：30-40%
   - 未割当領域：20-40%
   - これらが統計的に区別できないよう分散配置

2. **ファイル生成タイミング**:

   - `init` コマンド実行時に自動的に雛形ファイルを生成
   - 初期化するたびに新たな UUID を付与した暗号ファイルが生成される（既存ファイルは上書きされない）

3. **出力パス**:

   - 指定パス: `./output/` ディレクトリ（相対パス）
   - ファイル名: `encrypted_{UUID}.json`
   - 時間情報を含めず、UUID のみで一意性を確保

4. **雛形ファイルの内容**:

   - 全シェア ID 空間をランダムなゴミデータで埋める
   - シェアの値は暗号論的に安全な乱数で生成し、実際のシェアと区別不可能にする
   - シェアの分布は設計書の「分散配置」原則に従い、どの部分を切り取っても識別不可能にする
   - 初期化ファイルと暗号化済みファイルが外部から区別できないようにする

5. **セキュリティ要件**:

   - ゴミデータは暗号論的に安全な乱数で生成
   - ゴミデータの分布は実際のシェアと統計的に区別不可能
   - 不要なメタデータを含まず情報漏洩リスクを最小化
   - ファイル名に時間情報を含めないことで、作業時間帯の漏洩を防止
   - 初期化ファイルと暗号化済みファイルを区別不可能にする

6. **ファイル種別の管理**:

   - ファイル A・ファイル B が同一の暗号ファイル内に混在して保管される
   - それぞれのファイル種別用の領域は区別されず、統計的に区別不可能
   - ファイル種別はパーティションキーから導出され、暗号ファイル内に明示的に保存されない

7. **過去形式コードの完全削除**:

   - 過去形式に関連するすべてのコード関数をコードベースから削除
   - 変換関数も実装せず、削除
   - 過去形式ファイルの読み取り関数も完全に削除
   - セキュリティリスクを排除するため、過去形式のコードは一切残さない

### 完全最小化されたヘッダー情報

実装においては、外部から暗号ファイルと初期化ファイルを完全に区別できないよう、必要最小限のヘッダー情報のみを含めます：

1. **salt**: シェア生成に使用したソルト値（常にランダム生成）

以下のメタデータは含めません：

- **magic**: 固定値は暗号ファイルの特性を示す手がかりになるため、区別不能性を高めるために完全に削除
- **created_at**: 作成時刻はリスクになるため含めない
- **share_id_space**: 配列のサイズから計算可能
- **total_chunks**: MAP からの導出または配列サイズで算出可能
- **threshold**: 多段 MAP から取得可能で、内部的にも導出できるため不要
- **file_type**: ファイル種別（A/B）も含めず、パーティションキーから導出
- **version**: 互換性は別の方法で処理するため不要

### 完全な MAP 依存設計

全てのパラメータを多段 MAP から取得する設計により、以下の利点があります：

1. **決定論的性質の強化**: 全ての重要パラメータが MAP から一意に決まるため、予測可能性が向上
2. **メタデータの完全排除**: ファイル内に保存するメタデータを最小限に抑え、情報漏洩リスクを低減
3. **一貫性の確保**: パラメータの管理を一元化し、整合性を保証
4. **実装の簡素化**: 複数の場所で同じパラメータを管理する必要がなくなり、コードの単純化が可能
5. **ファイル種別の隠蔽**: ファイルの種別（A/B）を暗号ファイル内に明示的に保存しない
6. **区別不可能性**: 初期化ファイルと暗号化済みファイルの区別が統計的に不可能
7. **コードの浄化**: 過去形式のコードを完全に排除し、セキュリティリスクを低減

## 実装アプローチ

```python
def generate_empty_encrypted_file(output_dir='./output'):
    """初期化時にゴミデータで埋められた暗号化ファイルの雛形を生成
    設計書の多段MAP原則に厳密に従う実装。最小限のメタデータのみを含む。
    全てのパラメータはMAPから取得。常に新たなUUIDを付与した暗号ファイルを生成。
    初期化ファイルと暗号化済みファイルが外部から完全に区別できないよう設計。
    """
    # 出力ディレクトリの確認・作成
    os.makedirs(output_dir, exist_ok=True)

    # 常に新たなUUIDを生成（既存ファイルは上書きしない）
    file_uuid = str(uuid.uuid4())
    output_path = os.path.join(output_dir, f"encrypted_{file_uuid}.json")

    # ソルト値を生成
    salt = secrets.token_bytes(16)
    salt_base64 = base64.urlsafe_b64encode(salt).decode('ascii')

    # 多段MAPからパラメータを取得
    share_id_space = get_share_id_space_from_map()
    total_chunks = get_total_chunks_from_map()

    # 全シェアを格納する一次元配列
    total_shares = total_chunks * share_id_space
    all_values = []

    # 全てのシェアに対して暗号論的に安全なランダム値を生成
    for i in range(total_shares):
        # 大きな素数p未満のランダム値を生成
        random_value = str(secrets.randbelow(int(ShamirConstants.PRIME - 1)) + 1)
        all_values.append(random_value)

    # ファイルフォーマットを構築 - 最小限のヘッダー情報のみ
    # magicフィールドを完全に削除し、暗号化ファイルと区別不能に
    empty_file = {
        "header": {
            "salt": salt_base64
        },
        "values": all_values
    }

    # 暗号化ファイルを保存
    with open(output_path, 'w') as f:
        json.dump(empty_file, f)

    return output_path
```

この機能は`init`コマンドに組み込み、パーティションキーの生成と同時に実行されるようにします。実装では最小限のヘッダー情報のみを含むことで、情報漏洩リスクを低減しつつ、多段 MAP 理念に完全準拠した形式となります。全てのパラメータを多段 MAP から決定論的に取得することで、設計理念に忠実なシステムが実現します。また、初期化するたびに新しい UUID を持つ暗号ファイルが生成され、既存ファイルが上書きされることがないよう設計されています。

特に重要なのは、「magic」フィールドを完全に削除することで、外部からファイルの種類を識別する手がかりを与えず、初期化ファイルと暗号化済みファイルが完全に区別不能になる点です。このヘッダー構造は暗号化処理でも完全に同一とし、初期化ファイルと実データを含むファイルの間で構造的・統計的な違いが一切生じないようにします。両ファイルタイプが完全に区別不能であることは、システムのセキュリティを大幅に強化し、どのファイルに実データが含まれているかという情報漏洩を防止します。

また、過去形式に関連するすべてのコード関数をコードベースから完全に削除することで、セキュリティ上の脆弱性を持つ可能性のある古いコードが誤って使用されるリスクを排除し、全体的なシステムのセキュリティを高めます。



## 3. シェアフォーマットの最適化

## 現在のシェアフォーマットの問題点と設計理念との乖離

現在のシェアフォーマットでは、各シェアに以下のメタデータが含まれています：

```json
{
  "chunk_index": 0,
  "share_id": 5996,
  "value": "2565322559438891508864851625374857349677263049174595886529026700792504434612834755142320849192448263421931556159220597970542267895745169958375066054175256951"
}
```

この形式は設計書の以下の理念に反しています：

1. **決定論的位置決定**: シェアの位置は多段 MAP から決定論的に生成されるべきで、メタデータとして保存すべきではない
2. **冗長性の排除**: chunk_index と share_id は多段 MAP から導出可能なため冗長
3. **暗号解析耐性**: メタデータの存在が暗号解析の手がかりになる

さらに実装上の問題点として：

1. 冗長な情報（chunk_index, share_id）がシェアごとに繰り返されている
2. メタデータの存在が暗号解析の手がかりになる可能性がある
3. ファイルサイズが不必要に大きくなる
4. タイムスタンプ（created_at）がファイルの作成時刻を漏洩させるリスクがある
5. ファイル A とファイル B が同一の暗号ファイル内に混在保管される仕組みが明示的に実装されていない
6. 過去形式のコード関数がシステム内に残されており、セキュリティ脆弱性のあるコードが誤って使用されるリスクがある

## 改善案：完全インデックスベースのシェア保存

多段 MAP から完全に位置を特定できる一次元配列形式に変更し、最小限のヘッダー情報のみを保持します。また、ファイル A とファイル B が同一の暗号ファイル内に混在保管される仕組みを考慮した設計とします。**過去形式との互換性は一切考慮せず、設計書の理念に完全準拠した新しい形式のみをサポートします。さらに、過去形式に関連するすべてのコード関数をコードベースから完全に削除し、新しい実装のみを残します。**

### 新しいシェアフォーマット

```json
{
  "header": {
    "salt": "base64_encoded_salt"
  },
  "values": [
    "value1", "value2", "value3", ... // 一次元配列で全シェア値を格納
  ]
}
```

### 最小限のヘッダー情報

1. **salt**: シェア生成に使用したソルト値

以下のメタデータは不要です：

- **magic**: 固定値は暗号ファイルの特性を示す手がかりになるため、区別不能性を高めるために完全に削除
- **created_at**: 作成時刻は不要であり、セキュリティリスクになる
- **share_id_space**: 配列の長さから計算可能
- **total_chunks**: 多段 MAP から導出可能であり、配列長からも算出可能
- **threshold**: 多段 MAP から取得可能で、内部的にも導出できるため不要
- **file_type**: ファイル種別（A/B）はパーティションキーから導出可能であり、ファイルに含める必要がない
- **version**: 互換性は別の方法で処理するため不要

### メリット

1. **完全な理念準拠**: 設計書の「多段 MAP」理念に完全準拠
2. **ファイルサイズ削減**: メタデータ完全削除によるサイズ削減（40%以上）
3. **暗号解析耐性向上**: シェア位置情報やタイムスタンプが完全に隠蔽され、攻撃者に手がかりを与えない
4. **効率性向上**: インデックス計算のみで位置特定可能で処理効率が向上
5. **情報漏洩リスク低減**: 不要なメタデータを含まないため情報漏洩リスクが減少
6. **完全な MAP 依存**: 全ての重要パラメータを MAP から取得することで、決定論的性質を強化
7. **ファイル混在保管の明確化**: ファイル A とファイル B が同一の暗号ファイル内に混在保管される仕組みを明示的に設計に組み込み
8. **セキュリティ基準への厳格な準拠**: 過去形式との互換性を排除することで、セキュリティ基準から逸脱した実装を完全に廃止
9. **初期化ファイルと暗号化ファイルの区別不能**: ヘッダー情報を最小化し、初期化ファイルと暗号化済みファイルが外部から完全に区別できないよう設計
10. **コードベースの浄化**: 過去形式の関数を完全に削除することで、セキュリティリスクのある古いコードが残らない

### シェアアクセス方法

```python
def get_share_index(chunk_index, share_id):
    """多段MAPで特定されたチャンクとシェアIDから一次元配列内の位置を算出"""
    # 多段MAPから得られたshare_id_space
    share_id_space = get_share_id_space_from_map()

    # 線形インデックス計算: チャンク番号 × シェアID空間サイズ + (シェアID - 1)
    return (chunk_index * share_id_space) + (share_id - 1)

def get_share_value(data, chunk_index, share_id, file_type=None):
    """多段MAPで特定されたシェアの値を取得

    Args:
        data: 暗号化データ
        chunk_index: チャンクインデックス
        share_id: シェアID
        file_type: ファイル種別（'A'または'B'）、デフォルトはNone
    """
    # 必ず新しい形式であることを検証
    if "header" not in data:
        raise ValueError("非対応のファイル形式です。新しい形式のみがサポートされています。")

    # share_id_spaceは配列から計算
    values_length = len(data["values"])
    # MAPから得られたチャンク数で割ることでshare_id_spaceを算出
    total_chunks = get_total_chunks_from_map()
    share_id_space = values_length // total_chunks

    # thresholdもMAPから取得
    threshold = get_threshold_from_map()

    # ファイル種別が指定されている場合、許可されたシェア領域かチェック
    if file_type and not is_share_in_file_partition(share_id, file_type):
        logging.warning(f"ファイル{file_type}の許可領域外のシェアにアクセスしようとしています")
        return None

    index = get_share_index(chunk_index, share_id)

    # インデックスが範囲内かチェック
    if 0 <= index < len(data["values"]):
        return data["values"][index]
    return None
```

### 実装アプローチ

```python
def create_encrypted_format(chunk_data, salt=None):
    """新しい形式の暗号化ファイルを新規作成する

    Args:
        chunk_data: シェアデータの辞書（チャンク番号 -> シェアリスト）
        salt: 使用するソルト値（Noneの場合は新規生成）
    """
    if salt is None:
        # ソルト値を生成
        salt = secrets.token_bytes(16)
        salt_base64 = base64.urlsafe_b64encode(salt).decode('ascii')
    elif isinstance(salt, bytes):
        salt_base64 = base64.urlsafe_b64encode(salt).decode('ascii')
    else:
        salt_base64 = salt  # すでにbase64エンコードされていると仮定

    # 多段MAPからパラメータを取得
    share_id_space = get_share_id_space_from_map()
    total_chunks = len(chunk_data)

    # 最小限のヘッダー情報のみ
    header = {
        "salt": salt_base64
    }

    # 一次元配列を初期化
    total_values = total_chunks * share_id_space
    values = ["0"] * total_values

    # 各チャンクのシェアを一次元配列に配置
    for chunk_idx, shares in chunk_data.items():
        for share in shares:
            share_id = share["id"]
            value = share["value"]

            # 一次元配列内のインデックスを計算
            index = (chunk_idx * share_id_space) + (share_id - 1)
            values[index] = value

    # 新しい形式のデータ構造を構築
    data = {
        "header": header,
        "values": values
    }

    return data
```

### 過去形式コードの完全削除

過去形式のコード関数はセキュリティリスクを伴うため、完全に削除します：

```python
def delete_deprecated_format_functions():
    """過去形式に関連するすべての関数を削除する手順

    この関数は実際には実装せず、以下の関数をコードベースから物理的に削除します：
    - create_v1_format(), create_v2_format()
    - read_v1_format(), read_v2_format()
    - convert_v1_to_v2(), convert_format()
    - is_v1_format(), is_v2_format()
    - その他過去形式に関連するすべてのヘルパー関数
    """
    # 以下は削除すべき関数の例です
    # これらの関数はコードベースから物理的に削除し、
    # 以下のようなコードは残さないでください

    # def create_v1_format():
    #     # ...この関数は削除

    # def create_v2_format():
    #     # ...この関数は削除

    # def read_v1_format():
    #     # ...この関数は削除

    # def is_v2_format():
    #     # ...この関数は削除

    # def convert_v1_to_v2():
    #     # ...この関数は削除

    raise NotImplementedError("このコメントと関数自体も削除してください")
```

この最適化により、ファイルサイズの削減（約 40%以上）と処理効率の向上、そしてセキュリティの強化が期待できます。設計書の「多段 MAP」の理念に完全準拠し、最小限のメタデータのみを保持することで情報漏洩リスクも低減します。過去形式との互換性を排除することで、セキュリティ基準から逸脱した実装を完全に排除し、設計理念に忠実なシステムを実現します。threshold を含むすべての重要パラメータを MAP から取得することで、設計理念に従った真に決定論的なシステムが実現します。さらに、ファイル A とファイル B が同一の暗号ファイル内に混在保管される仕組みを明示的に実装し、システムの制約と設計理念を一致させます。初期化ファイルと暗号化済みファイルを区別不能にすることで、外部からの解析を困難にし、セキュリティをさらに強化します。

過去形式のコード関数をコードベースから完全に削除し、新しい実装のみを残すことで、セキュリティリスクのある古いコードが誤って使用されるリスクを排除します。これにより、クリーンで安全なコードベースが確保され、システム全体のセキュリティが向上します。



## 4. UUID を使用したファイル命名規則

## ファイル命名の課題

現在のシステムには以下のファイル命名に関する課題があります。また、過去形式との互換性は考慮せず、設計理念に完全準拠した新しい形式のみに対応したファイル命名規則を定義します：

1. **上書きリスク**: 同じ出力ファイル名を指定すると、既存ファイルが上書きされる
2. **関連性の不明確さ**: 複数の暗号化ファイル間の関連性を識別する手段がない
3. **情報漏洩リスク**: ファイル名にタイムスタンプなどの情報を含めると、作業時間帯や作業順序などの情報が第三者に漏洩する可能性がある
4. **ファイル種別の識別**: 暗号書庫としてファイル A とファイル B が同一の暗号ファイル内に混在保管されるが、ファイル名からファイル種別を識別できない
5. **ファイルタイプの区別**: 初期化ファイルと暗号化済みファイルが外部から区別できる状態になっており、セキュリティリスクが生じている
6. **旧コード関数の存在**: 過去形式に関連するコード関数がシステム内に残されており、セキュリティリスクのある実装が誤って使用される可能性がある

## 提案: UUID を使用したファイル命名

以下の形式でファイル名を自動生成します。初期化するたびに新たな UUID を持つ暗号ファイルが生成され、既存ファイルが上書きされることはありません：

```
encrypted_{UUID}.json
```

例: `encrypted_550da07d-e131-4e5f-9a15-0a8e2f47be35.json`

### 仕様

1. **UUID**:

   - 形式: 標準的な UUID（バージョン 4）
   - 目的: ファイルの一意性を保証
   - 特徴: 予測不可能で、時間情報を含まない

2. **自動生成ルール**:

   - 出力ファイル名は常に自動生成され、初期化のたびに新たな UUID が付与される
   - 既存ファイルは上書きされず、新しいファイルとして生成される
   - ファイル種別（A/B）をファイル名に表示せず、内部的なみ区別する

3. **暗号書庫の管理**:

   - ファイル A とファイル B が同一の暗号ファイル内に混在保管される
   - 各ファイル種別の領域はパーティションキーから導出され、ファイル名には表示しない
   - ファイル種別の区別は暗号ファイル内でのみ行い、外部からは識別不能

4. **ファイルタイプの区別不能化**:

   - 初期化ファイルと暗号化済みファイルが同一のフォーマットと命名規則を持ち、外部から区別不能
   - ヘッダー情報を最小化し、両タイプのファイルで完全に同一の構造を採用
   - ファイル内容の統計的特性も同一になるよう設計

5. **過去形式コードの完全削除**:

   - 過去形式のファイル名生成関数を完全に削除
   - UUID 命名規則に準拠しない古い関数（例：`generate_timestamp_filename()`）を削除
   - 過去形式をサポートするすべてのコードを削除

## セキュリティとの整合性

ファイル命名規則は以下の点で最小限メタデータ原則と整合しています：

1. **時間情報の排除**: タイムスタンプを含めないことで、作成時刻に関する情報漏洩リスクを排除
2. **予測不可能性**: UUID のランダム性により、ファイル名からパターンを推測することが困難
3. **ファイル内外の分離**: ファイル内部と同様に、外部のファイル名にも必要最小限の情報のみを含める
4. **一意性の確保**: 上書きリスクの回避とファイルの識別が可能な最小限の情報のみを使用
5. **ファイル種別の隠蔽**: ファイル名からファイル種別（A/B）を推測できないようにする
6. **区別不能性**: 初期化ファイルと暗号化済みファイルをファイル名からも区別できないようにする
7. **コードベースの浄化**: 過去形式のコードを完全に削除し、セキュリティリスクを低減

## タイムスタンプを含めない理由

ファイル名にタイムスタンプを含めると以下のセキュリティリスクが生じます：

1. **作業パターンの漏洩**: 特定の時間帯に作業が集中していることが判明し、使用者の行動パターンが推測される
2. **作成順序の漏洩**: 複数ファイルの作成順序が明らかになり、情報の関連性や重要度が推測される
3. **タイムゾーン情報の漏洩**: 使用者の所在地域が推測される可能性がある
4. **メタデータ最小化の原則に反する**: 必要のない情報をファイル名に含めることは、メタデータ最小化の原則に反する

## ファイル種別を内部でのみ区別する理由

ファイル名の設計においてファイル種別（A/B）を外部から隠蔽する理由：

1. **一貫性の確保**: 設計理念との一貫性を保ち、システムの内部構造を外部から隠蔽する
2. **情報漏洩防止**: ファイル名からファイル種別が推測できないようにすることで情報漏洩を防止
3. **セキュリティの向上**: ファイルの所有権と管理を明確にし、誤ったファイルアクセスを防止
4. **パーティション空間設計との整合**: A/B ファイル用の空間が暗号ファイル内部で区別されるという設計理念との整合性を保つ

## ファイルタイプの区別不能性を実現する理由

初期化ファイルと暗号化済みファイルを区別不能にする理由：

1. **情報漏洩防止**: どのファイルが実データを含んでいるかという情報が漏洩するリスクを排除
2. **攻撃対象の不明確化**: 攻撃者がどのファイルを標的にすべきか判断できないようにする
3. **セキュリティレベルの統一**: 全てのファイルを同等のセキュリティレベルで扱う
4. **区別不能性原則の徹底**: 設計書の「区別不能性」という基本原則に完全準拠

## 過去形式コードを完全に削除する理由

過去形式のコード関数を完全に削除する理由：

1. **セキュリティリスクの排除**: 古い脆弱な実装が誤って使用されるリスクを排除
2. **コードベースの単純化**: 不要なコードを削除することでメンテナンス性を向上
3. **一貫性の確保**: 新しい形式のみをサポートすることで実装の一貫性を確保
4. **復活リスクの防止**: 古いコードが将来的に復活して使用されるリスクを防止
5. **セキュリティ基準の徹底**: 逸脱した実装が混入するリスクを排除

## 実装サンプル

```python
def generate_unique_filename(base_dir='./output', prefix='encrypted', ext='.json'):
    """一意なファイル名を生成する関数
    初期化するたびに新しいUUIDを持つファイルを生成

    Args:
        base_dir: 出力ディレクトリパス
        prefix: ファイル名の接頭辞
        ext: ファイル拡張子
    """
    # ディレクトリが存在しない場合は作成
    os.makedirs(base_dir, exist_ok=True)

    # 常に新たなUUIDを生成（既存ファイルは上書きしない）
    file_uuid = str(uuid.uuid4())

    # ファイル名を組み立て（ファイル種別は含めない）
    filename = f"{prefix}_{file_uuid}{ext}"

    # 完全なパスを返す
    return os.path.join(base_dir, filename)
```

### コマンドライン引数の改善

コマンドラインインターフェースを変更して、出力ファイル名の自動生成をサポートします：

```python
## 4. 初期化コマンドの例
parser.add_argument('--output-dir', '-o', default='./output',
                    help='出力ディレクトリパス。デフォルトは ./output/')

## 4. 引数処理部分
output_dir = args.output_dir
os.makedirs(output_dir, exist_ok=True)

## 4. 常に新しいUUIDを持つファイルを生成
output_path = generate_unique_filename(base_dir=output_dir)
print(f"暗号ファイルを生成しました: {output_path}")
```

### ヘッダー構造の統一

初期化ファイルと暗号化ファイルの内部構造を完全に統一するため、両方のファイルタイプで同一のヘッダー構造を使用します：

```python
## 4. 両ファイルタイプで同一の最小化ヘッダー構造
file_header = {
    "salt": salt_base64
}

## 4. 初期化ファイルと暗号化ファイルの両方で同じ構造を使用
file_structure = {
    "header": file_header,
    "values": values_array
}
```

### 過去形式コードの削除

過去形式のファイル名生成や処理に関連するコードは完全に削除します：

```python
## 4. 以下のような関数はコードベースから完全に削除します
## 4. これは削除すべき関数の例であり、実際にこのコードを実装してはいけません

## 4. def generate_timestamp_filename():
## 4.     # 時間情報を含むファイル名を生成（削除すべき）
## 4.     ...

## 4. def process_v1_file(filename):
## 4.     # V1形式のファイルを処理（削除すべき）
## 4.     ...

## 4. def process_v2_file(filename):
## 4.     # V2形式のファイルを処理（削除すべき）
## 4.     ...
```

この命名規則により、初期化するたびに新たな UUID を持つ暗号ファイルが生成され、既存ファイルが上書きされることはありません。必要最小限の情報のみを含めるという設計理念に完全に準拠し、ファイル名からも情報漏洩が発生しないよう配慮されています。また、ファイル A とファイル B が同一の暗号ファイル内に混在保管される仕組みをシステムレベルで実装し、ファイル管理の一貫性と安全性を高めています。さらに、初期化ファイルと暗号化済みファイルが外部から区別できないよう、ファイル名とヘッダー構造を統一し、どのファイルに実データが含まれているかという情報漏洩を防止します。

過去形式に関連するすべてのコード関数を完全に削除することで、セキュリティリスクのある古い実装が誤って使用されるリスクを排除し、クリーンで安全なコードベースを確保します。これにより、システム全体のセキュリティが向上し、設計理念に完全準拠した実装が実現します。



## 5. 実装計画と優先順位

## 設計理念への準拠を確保する実装手順

設計書の「多段 MAP」と「パーティション空間設計」に厳密に準拠するため、以下の順序で実装します：

1. **セキュリティ準拠の新しい形式実装** - 設計理念に完全準拠した新しいファイル形式を実装（後方互換性は一切考慮しない）
2. **初期化時の暗号化ファイル生成** - 初期化するたびに新たな UUID を持つ暗号ファイルを生成
3. **UUID によるファイル命名** - 利便性改善とセキュリティリスク低減
4. **ファイル A・B の混在保管実装** - 設計理念に忠実なファイル混在保管の明示的実装
5. **過去形式関連コードの完全削除** - 過去形式に関連するコードを完全に削除し、コードベースを浄化

## 過去形式関連コードの完全削除

セキュリティリスクを排除するため、過去形式に関連するコードとその関数は**コードベース内に一切残さない**こととします：

- **削除対象関数の例**:

  - `create_v1_format()`
  - `create_v2_format()`
  - `read_v1_format()`
  - `read_v2_format()`
  - `convert_v1_to_v2()`
  - `is_v1_format()`
  - `is_v2_format()`
  - その他、過去形式に関連するすべてのヘルパー関数

- **新しい形式のみの実装**:
  - 新たに`create_encrypted_format()`、`read_encrypted_format()`などの関数のみを実装
  - 変換関数も一切実装しない
  - 変換機能を要求するエラーが発生した場合はシステム移行手順書を別途用意

過去形式関連コードの一切が残っていないことを確認するため、次のコードレビュー手順を実施します：

```python
## 5. 実装後のコードレビューで確認すべき項目
def code_review_remove_old_formats():
    """
    過去形式に関連するコードが完全に削除されていることを確認する
    """
    # 1. 過去形式の関数が存在しないことを確認
    assert not hasattr(module, "create_v1_format")
    assert not hasattr(module, "create_v2_format")
    assert not hasattr(module, "read_v1_format")
    assert not hasattr(module, "read_v2_format")

    # 2. 過去形式への変換関数が存在しないことを確認
    assert not hasattr(module, "convert_v1_to_v2")
    assert not hasattr(module, "convert_format")

    # 3. インポート文やコメントにも過去形式への言及がないことを確認
    source_code = inspect.getsource(module)
    assert "v1_format" not in source_code
    assert "v2_format" not in source_code

    # 4. 過去形式の識別コードが存在しないことを確認
    assert not hasattr(module, "is_v1_format")
    assert not hasattr(module, "is_v2_format")

    print("成功: すべての過去形式関連コードが完全に削除されています")
```

これにより、コードベース内に過去形式のコードが一切残らず、セキュリティリスクのある実装が混入する可能性を排除します。

## 最小限のヘッダー情報

シェアフォーマットにおいては、必要最小限のヘッダー情報のみを保持します：

1. **salt**: シェア生成に使用したソルト値

以下のメタデータは不要であり、セキュリティリスクとなるため含めません：

- **magic**: 固定値は暗号ファイルの特性を示す手がかりになるため削除
- **created_at**: 作成時刻はファイル解析の手がかりとなるリスクがある
- **share_id_space**: 配列のサイズから計算可能
- **total_chunks**: MAP からの導出または配列サイズで算出可能
- **threshold**: 多段 MAP から取得可能で、内部的にも導出できるため不要
- **file_type**: ファイル種別（A/B）はパーティションキーから導出可能であり、ファイルに含める必要がない
- **version**: 互換性は別の方法で処理するため不要

## 詳細実装手順

### ステップ 1: セキュリティ準拠の新しい形式実装

1. `create_encrypted_format()` 関数を作成し、新しい形式の暗号化ファイルを新規作成する機能を実装
2. `get_share_index()` 関数を作成し、多段 MAP から一次元配列内の位置を算出
3. share_id_space と total_chunks を MAP から取得するロジックを実装
4. 過去形式のファイルに対するエラーハンドリングを追加（変換は行わない）
5. 新しい形式のみをサポートする明確なエラーメッセージを実装
6. 過去形式関連の全コードを完全に削除

### ステップ 2: 初期化時の暗号化ファイル生成

1. `generate_empty_encrypted_file()` 関数を最小限ヘッダーの新しい形式で実装
2. 初期化のたびに新たな UUID を持つ暗号ファイルを生成する仕組みを実装
3. `init` コマンドにこの機能を統合
4. メタデータマネージャーの更新

### ステップ 3: UUID ファイル命名の実装

1. `generate_unique_filename()` 関数を `utils.py` に追加
2. すべてのファイル出力関数（暗号化、更新）にこの関数を適用
3. 時間情報を含まないファイル名形式を実装
4. コマンドライン引数の処理を更新

### ステップ 4: ファイル A・B の混在保管実装

1. `is_share_in_file_partition()` 関数を追加し、ファイル種別に応じたシェア領域をチェック
2. ファイル A とファイル B を同一の暗号ファイル内に混在して保管する機能を実装
3. コマンドラインインターフェースに `--file-type` オプションを追加
4. 暗号ファイル内でのファイル種別に応じたシェア保存機能を実装

### ステップ 5: 過去形式コードの削除確認

1. コードベース全体を検索し、過去形式関連の関数を特定
2. 該当する関数とそれに関連するすべてのコードを削除
3. インポート文やコメントを含め、過去形式への参照をすべて削除
4. 単体テストから過去形式のテストも削除
5. `code_review_remove_old_formats()` を実行して削除完了を確認

## 情報漏洩リスクの低減対策

実装全体を通して、以下の情報漏洩リスク低減対策を徹底します：

1. **ファイル内メタデータの最小化**: 必要最小限のヘッダー情報のみを保持
2. **ファイル名からの情報漏洩防止**: 時間情報を含まない UUID 命名の採用
3. **パーティションキーの非保存**: システム側でパーティションキーを一切保存しない
4. **多段 MAP 実装の徹底**: 全てのシェア位置を MAP から決定論的に導出
5. **ファイル種別の隠蔽**: ファイル名からファイル種別を識別できないようにする
6. **初期化・暗号化ファイルの区別不能**: 外部から初期化ファイルと暗号化済みファイルが区別できないようにする
7. **過去形式コードの完全排除**: コードベース内に過去形式関連コードを一切残さない

## 設計理念との整合性確認

各機能の実装後に以下の確認を行います：

1. **多段 MAP 決定論的生成確認**:

   - パーティションキーとパスワードのみからシェア位置が正確に特定できることを検証
   - 最小限ヘッダーのみで復号が正常に機能することを確認

2. **統計的区別不可能性検証**:

   - 初期化ファイルと実データ含有ファイルの統計的特性を比較
   - ファイル A/B/未割当の区別が統計的に不可能なことを検証

3. **パーティションキー非保存原則とメタデータ最小化**:

   - パーティションキーが一切システムに保存されないことを確認
   - 必要最小限のヘッダー情報のみでシステムが正常に動作することを確認
   - created_at やその他の冗長情報なしで正確にシェア位置が特定できることを検証

4. **ファイル混在保管の確認**:

   - ファイル A とファイル B が同一の暗号ファイル内に混在保管される仕組みが正しく機能することを確認
   - 各ファイル種別に対応するシェア領域が正しくマッピングされていることを検証
   - ファイル名からファイル種別が識別できないことを確認

5. **過去形式排除の確認**:

   - 過去形式のファイルが適切に拒否されることを確認
   - 過去形式から新しい形式への変換が提供されていないことを確認
   - 過去形式についての明確なエラーメッセージが表示されることを確認
   - コードベース内に過去形式関連コードが一切残っていないことを確認

6. **初期化・暗号化ファイル区別不能性の確認**:

   - 外部観察者が初期化ファイルと暗号化済みファイルを統計的・構造的に区別できないことを検証
   - ヘッダー情報のみから両ファイルタイプが識別できないことを確認
   - ファイルサイズや内部構造から区別できないことを検証

## テスト計画

1. **ユニットテスト**:

   - 各新機能に対するユニットテストを作成
   - 新しい形式によるファイル生成と読み取りテスト
   - MAP からの share_id_space と total_chunks 導出を検証
   - ファイル種別に応じたシェア配置の正確性を検証
   - 過去形式ファイルに対する適切なエラー処理の検証
   - 過去形式コードが削除されていることの検証

2. **統合テスト**:

   - 新しい形式のみを使用した暗号化 → 更新 → 復号のフルサイクルテスト
   - セキュリティ理念に準拠した実装テスト
   - 統計的区別不可能性テスト
   - ファイル A とファイル B の混在保管機能テスト
   - 初期化ファイルと暗号化ファイルの区別不能性テスト

3. **セキュリティテスト**:

   - 統計的区別不可能性のテスト
   - ファイルサイズ一貫性の検証
   - サイドチャネル耐性テスト
   - メタデータ最小化による情報漏洩防止効果の検証
   - ファイル名からの情報漏洩リスク検証
   - ファイル種別の隠蔽検証
   - 初期化ファイルと暗号化ファイルの区別不能性検証
   - 過去形式コードが完全に削除されていることの検証

## 成功基準

1. シェアフォーマットのサイズ効率: 新しい形式によるサイズ削減率 40%以上
2. セキュリティ基準への準拠度: 100%
3. 設計理念への準拠度: 100%
4. ユニットテスト成功率: 100%
5. 統計的区別不可能性: 未初期化/A/B/A+B 間の区別が統計的に不可能
6. 最小限ヘッダーのみでの正常動作: 100%
7. ファイル名からの情報漏洩リスク: 0%
8. ファイル混在保管の実装: ファイル A とファイル B が同一の暗号ファイル内に正しく保管されること
9. 過去形式の排除: 完全排除（変換機能なし）
10. 初期化・暗号化ファイルの区別不能性: 外部から両タイプのファイルが完全に区別不能であること
11. 過去形式コードの削除率: 100%（コードベースから完全に削除）

以上の実装により、システムのセキュリティと効率性が大幅に向上し、設計書の理念に完全準拠したシステムが実現します。過去形式との互換性を完全に排除することで、セキュリティ基準から逸脱した実装がシステムに混入することを防ぎます。最小限のメタデータのみを含むことで情報漏洩リスクが低減し、真に安全な暗号化システムが構築されます。また、ファイル A とファイル B が同一の暗号ファイル内に混在して保管される仕組みを明示的に実装することで、設計理念との一貫性を確保し、システムの意図通りの使用を促進します。さらに、初期化するたびに新たな UUID を持つ暗号ファイルが生成される設計により、誤って既存ファイルが上書きされるリスクを排除します。初期化ファイルと暗号化済みファイルが外部から区別できないようにすることで、システムのセキュリティをさらに強化し、どのファイルが実データを含んでいるかという情報漏洩を防止します。コードベース内からすべての過去形式関連コードを完全に削除することで、セキュリティ上の欠陥を含む古い実装が誤って使用されるリスクを排除し、クリーンで安全なコードベースを確保します。


## 結論

この改善計画では、シャミア秘密分散法による複数平文暗号化システムの初期化プロセスと暗号化ファイルのフォーマットを改善します。システムは暗号書庫として機能し、ファイル A とファイル B が同一の暗号ファイル内に混在して保管されます。この設計上の制約として、**ファイル種別ごとに1つのファイルしか暗号化できない**（ファイル A は1つ、ファイル B は1つ）ことを明示的に実装し、設計理念との一貫性を確保します。また、初期化ファイルと暗号化済みファイルが外部から区別できないようファイル構造とヘッダー情報を統一することで、システムのセキュリティと効率性が向上し、情報漏洩リスクが低減します。
