# 準同型暗号マスキング方式（Method 8: Homomorphic Encryption Masking）

この方式は、同一の暗号文から異なる鍵を使用して異なる平文を復号できる「区別不能性」を持つ暗号化方式です。
暗号文や鍵に明示的なフラグは存在せず、外部からはどちらの平文が復号されるかを判別できません。

## 技術的原理

この方式は以下の技術的性質に基づいています：

1. **XOR 演算の可換性と準同型性**: XOR（排他的論理和）演算は、`A ⊕ B = B ⊕ A` および `(A ⊕ B) ⊕ C = A ⊕ (B ⊕ C)` という性質を持ちます。
2. **鍵の識別不能性**: 鍵は外見上区別がつかず、内部的にはハッシュ値の偶数/奇数性によって区別されます。
3. **データ変換**: 2 つの異なるデータが同一の暗号文に変換されるように、一方のデータに差分を適用します。

## 暗号化プロセス

簡易版の実装では以下のように動作します：

1. 2 つの平文データ（P_a, P_b）を用意します。
2. マスターシードから 2 つの鍵（K_a, K_b）を生成します。
   - K_a のハッシュ値は偶数になるように生成
   - K_b のハッシュ値は奇数になるように生成
3. 各鍵からマスク（M_a, M_b）を導出します。
4. 中間暗号文を計算：
   - C_a = P_a ⊕ M_a
   - C_b = P_b ⊕ M_b
5. 差分 D を計算：D = C_a ⊕ C_b
6. 平文 P_b を変換した P_b'を計算：P_b' = P_b ⊕ D
7. 最終暗号文 C = C_a = P_a ⊕ M_a = P_b' ⊕ M_b を出力します。

これにより、同一の暗号文 C から、鍵 K_a を使うと P_a が、鍵 K_b を使うと P_b が復号されます。

## 復号プロセス

1. 暗号文 C と鍵 K を入力として受け取ります。
2. 鍵 K のハッシュ値が偶数か奇数かを確認します。
3. 鍵 K からマスク M を導出します。
4. 偶数の場合（データセット A）：
   - P = C ⊕ M
5. 奇数の場合（データセット B）：
   - P' = C ⊕ M
   - 差分 D を適用して P = P' ⊕ D

## セキュリティ特性

この方式は以下のセキュリティ特性を持ちます：

1. **区別不能性**: 暗号文からは、その暗号文が本来どのデータを暗号化したものかを判別できません。
2. **鍵の識別不能性**: 鍵自体も外見上は区別がつかず、内部的なハッシュ値の性質によってのみ区別されます。
3. **マスクの一方向性**: マスク生成は SHA-256 などの暗号学的ハッシュ関数を使用するため、マスクから鍵を逆算することは計算困難です。

## 使い方

### 暗号化（通常版）

```bash
python3 homomorphic_encrypt.py <ファイルA> <ファイルB> --output <暗号化ファイル>
```

### 暗号化（簡易版）

```bash
python3 simple_homomorphic_encrypt.py <ファイルA> <ファイルB> <暗号化ファイル>
```

### 復号（通常版）

```bash
python3 homomorphic_decrypt.py <暗号化ファイル> <鍵ファイル> --output <復号ファイル> [--debug]
```

### 復号（簡易版）

```bash
python3 simple_homomorphic_decrypt.py <暗号化ファイル> <鍵ファイル> --output <復号ファイル> [--debug]
```

## 実装例

1. 2 つのファイル（f.text, t.text）を暗号化します：

   ```bash
   python3 simple_homomorphic_encrypt.py f.text t.text encrypted.henc
   ```

2. 鍵 A を使って復号（「偽」のテキストが出力されます）：

   ```bash
   python3 simple_homomorphic_decrypt.py encrypted.henc keys/simple_key_a.json --output decrypted_a.txt
   ```

3. 鍵 B を使って復号（「真」のテキストが出力されます）：
   ```bash
   python3 simple_homomorphic_decrypt.py encrypted.henc keys/simple_key_b.json --output decrypted_b.txt
   ```

## 応用例

1. **セキュアな情報共有**: 同一の暗号文から権限に応じて異なる情報を取得する仕組み
2. **データコントロール**: データ所有者は完全な情報を、他のユーザーには限定的な情報を提供
3. **信頼性の確保**: 盗聴や傍受があっても、どの情報が正確なものかを隠蔽できる

## 注意点

1. この方式は真の準同型暗号ではなく、XOR を使った準同型性の模倣です。
2. 複数の鍵が漏洩すると、差分解析により本来の平文を推測できる可能性があります。
3. 暗号文と共に差分情報も保存されるため、この情報も適切に保護する必要があります。

## 発展可能性

1. **多層化**: 3 つ以上のデータセットを同一の暗号文から復号可能にする拡張。
2. **部分復号**: データの一部だけを選択的に復号する機能の追加。
3. **真の準同型暗号との統合**: より高度な準同型暗号アルゴリズムとの統合。

## 主要な特徴

- **識別不能性（Indistinguishability）**: 暗号文から「真」と「偽」のどちらのファイルが復号されるかを区別できません
- **準同型性（Homomorphism）**: Paillier 準同型暗号を採用し、暗号文に対する演算が平文に反映される特性を活用
- **鍵による 2 通りの復号**: 同じ暗号文から「真」「偽」の 2 種類のファイルを復号可能
- **ハニーポット戦略**: 意図的に「正規」鍵を漏洩させ、偽情報を信じ込ませる戦略が実装可能
- **リバーストラップ**: 本当に重要な情報を「非正規」側に隠す戦略も可能
- **複数の形式対応**: テキスト、JSON、CSV、バイナリなど様々なデータ形式に対応

## 実装改善点

最新のアップデートでは、以下の点を改善しました：

1. **循環インポート問題の解決**: モジュール間の循環参照を解消し、安定性を向上
2. **データ形式処理の強化**: 各種データ形式の変換・処理処理を改善
3. **バイト変換の正確化**: 整数 ↔ バイト変換の処理を強化し、データ欠損を防止
4. **ヌルバイト処理の最適化**: 先頭のヌルバイトのみを削除し、末尾のヌルバイトを保持するよう修正
5. **改行処理の修正**: 不要な改行の追加を防止し、元のデータ形式を維持
6. **鍵判定の堅牢化**: 鍵解析アルゴリズムを改善し、より安全な判定を実現

## 使用方法

### 暗号化

```bash
python encrypt.py <真ファイル> <偽ファイル> --output <出力ファイル> [オプション]
```

#### 主なオプション

- `--verbose` または `-v`: 詳細なログを出力
- `--save-keys`: 鍵ファイルを保存
- `--indistinguishable`: 識別不能性を強化

### 復号

```bash
python decrypt.py <暗号化ファイル> --key <鍵> --output <出力ファイル> [オプション]
```

#### 主なオプション

- `--verbose` または `-v`: 詳細なログを出力
- `--data-type`: 復号データの形式を指定（デフォルト: 自動検出）
- `--use-enhanced-security`: セキュリティ強化版の機能を使用（デフォルト）

## モジュール構成

- `encrypt.py`: 暗号化用メインスクリプト
- `decrypt.py`: 復号用メインスクリプト
- `homomorphic.py`: 準同型暗号の実装
- `crypto_mask.py`: マスク関数の実装
- `crypto_adapters.py`: データ形式変換アダプター
- `indistinguishable.py`: 識別不能性機能
- `indistinguishable_ext.py`: 識別不能性の拡張機能
- `config.py`: 設定パラメータ
- `key_analyzer.py`: 鍵解析機能

## セキュリティ強化版の特徴

セキュリティ強化版では、以下の機能を提供しています：

1. **高度な統計的攻撃への耐性**: 統計的な特徴分析による攻撃を防止する追加対策を実装
2. **ロバストな鍵解析**: 環境や実装の違いに影響されにくい鍵判定アルゴリズム
3. **エラー耐性の向上**: 様々なエラー状況でも堅牢に動作するよう改善
4. **データ完全性の維持**: データの欠損や変形を最小限に抑える処理

## 使用例

### UTF-8 テキストファイルの暗号化・復号

```bash
# 暗号化
python encrypt.py document.txt fake_document.txt --output encrypted.henc --verbose

# 復号（真のファイルを取得）
python decrypt.py encrypted.henc --key <真の鍵> --output decrypted_true.txt --verbose

# 復号（偽のファイルを取得）
python decrypt.py encrypted.henc --key <偽の鍵> --output decrypted_false.txt --verbose
```

### JSON ファイルの暗号化・復号

```bash
# 暗号化
python encrypt.py data.json fake_data.json --output encrypted.henc --verbose

# 復号
python decrypt.py encrypted.henc --key <鍵> --output decrypted.json --verbose
```

### CSV ファイルの暗号化・復号

```bash
# 暗号化
python encrypt.py data.csv fake_data.csv --output encrypted.henc --verbose

# 復号
python decrypt.py encrypted.henc --key <鍵> --output decrypted.csv --verbose
```

## 注意事項

- どちらのキーが「正規」か「非正規」かはシステム上の区別ではなく、使用者の意図によって決まります
- 暗号化・復号には CPU やメモリリソースを消費するため、特に大きなファイルの処理には注意が必要です
- まれに、特定のコンテンツ（特殊な形式のテキストなど）で完全一致の復号ができない場合があります

## ライセンス

Copyright (c) 2025 暗号化方式研究
