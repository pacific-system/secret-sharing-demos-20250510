# シャミア秘密分散法による複数平文復号システム - 実装プロンプト

## 実装者のペルソナ

あなたは暗号学とセキュアコーディングに精通した優秀なPython開発者です。
シャミア秘密分散法に関する深い知識を持ち、セキュリティシステムの実装経験が豊富です。
「統計的区別不可能性」「定数時間処理」「サイドチャネル攻撃への対策」などの概念を熟知しています。
また、Pythonにおけるベストプラクティスを遵守し、効率的で保守性の高いコードを作成します。

以下の設計に基づいて、シャミア秘密分散法による複数平文復号システムをPythonで実装してください。
システムの核心は「複数の平文を単一の暗号ファイルに格納し、別々のパスワードでそれぞれ復号可能にする」ことです。

---

# シャミア秘密分散法による複数平文復号システム - 実装プロンプト

## システム概要と目的

あなたは暗号学とセキュアコーディングに精通した開発者です。シャミア秘密分散法を応用した「複数平文復号システム」を実装してください。このシステムは単一の暗号化ファイルから異なるパスワードを使用して異なる平文（JSON 文書）を復号可能にするものです。

**核心技術**: 「シェア ID による可能性の限定とパスワードによるマップ生成」という多段 MAP 方式

**重要な原則**: このシステムはケルクホフの原理に厳格に従います。アルゴリズムが完全に公開されてもパスワード（鍵）が秘匿されている限りセキュリティが保たれるよう設計してください。

## システムアーキテクチャ

### 基本原理

1. **シャミア秘密分散法**: 閾値暗号の一種。秘密情報を複数のシェアに分散し、一定数以上のシェアで元の情報を復元
2. **多段 MAP 方式**: シェア ID による第 1 段階の絞り込みとパスワードによる第 2 段階のマッピング
3. **統計的区別不可能性**: 異なる文書のシェアや未割当領域のシェアが統計的に区別できない
4. **直線的処理**: 復号処理中に評価や条件分岐を一切含まない

### 多段 MAP 方式の詳細

1. **第 1 段階（シェア ID による限定）**:

   - ユーザーが保持するシェア ID セットにより、全シェア空間から復号候補となるシェアの範囲を限定
   - この段階で不要なシェアの大部分を除外

2. **第 2 段階（パスワードによるマッピング）**:
   - パスワードから鍵導出関数を用いてマップデータを生成
   - 第 1 段階で限定された範囲内のシェアだけを対象にマッピングを適用
   - マッピング結果に基づき、実際に復号に使用するシェアを特定

## 実装上の絶対条件

### 1. セキュリティモデルの厳守

- **条件分岐の禁止**: 復号処理中に条件分岐を含めないこと（タイミング攻撃対策）
- **定数時間処理**: 全ての操作が入力値に関係なく一定時間で処理されること
- **統計的区別不可能性**: シェアの種類（A/B/未割当）が統計的に区別できないこと

### 2. シェア ID 空間設計

- **分割比率**: A 用 30-40%、B 用 30-40%、未割当 20-40%
- **分散配置**: 連続範囲や単純パターンを避け、バラバラに配置
- **実装方法**: 擬似乱数生成器で初期化、割り当て判別には 4 要素（パスワード A、B、シェア ID セット A、B）が全て必要

### 3. データ構造設計原則

- **最小情報の原則**: 復号に必須の情報のみを保存
- **識別情報の排除**: 文書種別の識別子（A/B 等）を含めない
- **構造的匿名性**: データ構造自体から情報が漏洩しないよう設計
- **冗長性の最小化**: 同じ情報を複数箇所に保存しない

### 4. 禁止事項

- ベストプラクティスに反する実装
- バックドアの設置や復号偽装
- 大原則（統計的区別不可能性、直線的処理等）を回避する設計

## 全体構成と依存関係

実装は次の 3 つの主要コンポーネントに分割されます:

1. **暗号化モジュール**: 複数の JSON 文書を単一の暗号化ファイルにエンコード
2. **復号化モジュール**: シェア ID とパスワードを用いて暗号化ファイルから特定の JSON 文書を復元
3. **更新モジュール**: 既存の暗号化ファイルの特定文書部分のみを安全に更新

これらのモジュールは CLI インターフェースから呼び出されます。
それぞれのモジュールの詳細実装は各ファイルを参照してください。

## 実装言語とライブラリ

- 実装言語: **Python**
- 推奨暗号ライブラリ:
  - KDF: `hashlib.pbkdf2_hmac` または `argon2-cffi`
  - 乱数生成: `secrets`モジュール
  - 有限体演算: `gmpy2`（必要な場合）
# 暗号化モジュール実装ガイド

## 暗号化モジュールの目的

このモジュールは複数の JSON 文書（通常は A 文書と B 文書）を単一の暗号化ファイルに変換します。核心となる多段 MAP 方式とシャミア秘密分散法を用いて、異なるパスワードで異なる文書を復号できるようにします。

## 主要な機能と要件

### 1. 多段エンコードプロセス

JSON 文書は以下の多段エンコードプロセスを適用します：

1. UTF-8 テキスト（元の JSON）
2. Latin-1 へのエンコード変換
3. Base64 エンコード
4. 常に圧縮（条件判断なし）

### 2. シャミア秘密分散法の実装

- 多項式の次数と閾値：実用的な値として閾値`t=3`～`5`
- 有限体の選択：大きな素数`p`を用いた有限体 GF(p)上での計算
- 推奨： 文書サイズに応じて十分大きい素数を選択（例：2^256-189）

### 3. シェア ID 空間の設計と管理

- A 用と B 用のシェア ID は予め分割し、暗号化時にはそれらを使用するだけ
- 未割当領域には統計的に区別不能なランダムデータを生成
- シェア ID の分布は特定のパターンを形成しないよう設計（交互配置など）

### 4. 暗号化プロセスの全体フロー

```
データの前処理（多段エンコード）
↓
データをチャンクに分割
↓
各チャンクをシャミア秘密分散でシェア化
↓
未割当領域にゴミデータを生成
↓
シェアをシャッフル
↓
メタデータを追加して暗号化ファイル生成
```

## 実装時の制約とガイドライン

### 絶対条件

1. **識別情報の排除**:

   - どのシェアがどの文書（A または B）に属するかを示す情報を格納しない
   - すべてのメタデータは A/B 区別なく同一形式

2. **シェア値の統計的区別不可能性**:

   - A 文書のシェア、B 文書のシェア、未割当領域のゴミデータが統計的に区別できないこと
   - これは情報理論的安全性のために必須

3. **保存データの最小化**:
   - シャミア秘密分散法で生成されたシェア値
   - 塩値（再計算不可能な乱数）
   - 復号に必要な最小限のメタデータ（閾値など）
   - シェア ID はユーザー入力として提供されるため保存不要
   - マッピング情報はパスワードとシェア ID から計算で再生成可能なため保存不要

### 主要関数の実装ガイド

#### 1. シャミア秘密分散法の実装

```python
def generate_polynomial(secret, degree, p):
    """degree次の多項式を生成"""
    # 係数配列を生成（最初の要素は秘密値）
    # 乱数を用いて残りの係数を生成

def evaluate_polynomial(coef, x, p):
    """多項式の評価"""
    # 係数配列と評価点xから多項式の値を計算

def generate_shares(secret, t, n, p):
    """n個のシェアを生成、閾値はt"""
    # 多項式を生成し、各シェアIDに対する値を計算
```

#### 2. 暗号化関数

```python
def encrypt(json_docs, passwords, share_id_sets, unassigned_ids, threshold=3):
    """
    複数のJSON文書を暗号化

    Args:
        json_docs: 文書のリスト [json_doc_A, json_doc_B]
        passwords: パスワードのリスト [password_A, password_B]
        share_id_sets: シェアIDセットのリスト [share_ids_A, share_ids_B]
        unassigned_ids: 未割当のシェアIDリスト
        threshold: シェア復元に必要な閾値

    Returns:
        暗号化されたファイル構造（辞書型）
    """
    # 1. 各JSON文書に対してエンコード処理
    # 2. チャンクに分割
    # 3. 各チャンクをシェア化（識別不能に）
    # 4. 未割当領域にゴミデータ生成
    # 5. シェアをシャッフル
    # 6. メタデータを追加
```

#### 3. 補助関数

```python
def preprocess_data(json_doc):
    """JSON文書の前処理（多段エンコード）"""
    # UTF-8 → Latin-1 → Base64の多段エンコード

def split_into_chunks(data, chunk_size=64):
    """データを固定長チャンクに分割"""
    # データをチャンクに分割

def generate_chunk_shares(secret, threshold, share_ids, p):
    """チャンクのシェア生成"""
    # シャミアの多項式を使ってシェアを生成

def generate_garbage_shares(unassigned_ids, num_real_shares, p):
    """未割当領域のゴミデータ生成"""
    # 統計的に区別できないランダムデータ生成
```

### 出力形式

暗号化の結果は以下の形式の辞書型データとします：

```python
{
    'metadata': {
        'salt': 'ランダム生成された塩値',
        'total_chunks': チャンク数,
        'threshold': 閾値,
        # その他必要な情報（A/B識別情報は含まない）
    },
    'shares': [
        {
            'chunk_index': チャンクインデックス,
            'share_id': シェアID,
            'value': シェア値
        },
        # ... 他のシェア
    ]
}
```

## 実装上の注意点

1. **セキュアな乱数生成**:

   - `secrets`モジュールを使用して暗号学的に安全な乱数を生成

2. **素数の選択**:

   - 有限体演算に使用する素数は十分に大きく選ぶ
   - 素数サイズは扱うデータサイズに合わせて調整

3. **効率性とメモリ使用量**:

   - 大きなファイルでもメモリ効率よく処理できるよう設計
   - 入力サイズの 3-4 倍程度のメモリ使用に抑える

4. **エラー処理**:
   - 例外を投げる場合でも内部状態や部分的な暗号化情報が漏洩しないよう注意
# 復号化モジュール実装ガイド

## 復号化モジュールの目的

このモジュールは暗号化されたファイルから、特定のシェア ID セットとパスワードを用いて単一の JSON 文書を復元します。多段 MAP 方式の特徴を活かし、パスワードによって異なる文書が復号される仕組みです。

## 重要なセキュリティ要件

### 1. 直線的処理の厳格な実装

復号処理において最も重要な要件は「直線的処理」です：

- **条件分岐の禁止**: どのような状況でも入力値による条件分岐を行わない
- **定数時間処理**: 全ての処理が入力値に関わらず同じ時間で実行される
- **タイミング攻撃耐性**: 処理時間から入力情報が推測できないようにする

### 2. 多段 MAP 方式の正確な実装

1. **第 1 段階（シェア ID による限定）**:

   - 入力されたシェア ID セットで候補シェアを限定
   - 該当しないシェア ID のシェアは完全に除外

2. **第 2 段階（パスワードによるマッピング）**:
   - パスワードと塩値から KDF でマップキーを生成
   - 各シェア ID に決定論的にマッピング値を生成
   - マッピング値でソート後、閾値分のシェアを選択

## 主要関数の実装ガイド

### 1. 多段 MAP の実装

```python
def stage1_map(share_ids):
    """シェアIDによる第1段階MAP生成

    Args:
        share_ids: ユーザー入力のシェアIDセット

    Returns:
        シェアID候補セット
    """
    # シェアIDセットをセットとして返す（単純フィルタとして機能）
    return set(share_ids)

def stage2_map(password, candidate_ids, salt):
    """パスワードによる第2段階MAP生成

    Args:
        password: ユーザー入力のパスワード
        candidate_ids: 第1段階で限定されたシェアIDのセット
        salt: 暗号化時に生成された塩値

    Returns:
        シェアIDからマッピング値へのマップ辞書
    """
    # パスワードからKDFを用いてキーを導出
    # 各シェアIDに対するマッピング値をHMACで決定論的に生成
    # {share_id: mapping_value} 形式の辞書を返す
```

### 2. シェア選択と復元

```python
def select_shares(all_shares, share_ids, password, salt, threshold):
    """多段MAPを用いたシェア選択

    Args:
        all_shares: 全シェアリスト
        share_ids: ユーザー入力のシェアIDセット
        password: ユーザー入力のパスワード
        salt: 暗号化時に生成された塩値
        threshold: 閾値（必要シェア数）

    Returns:
        選択されたシェアのリスト
    """
    # 第1段階：シェアID空間の限定
    # 第2段階：パスワードによるマッピング
    # マッピング値でソート
    # 閾値分のシェアを選択（必ず同じ数を処理）
```

### 3. シャミア秘密分散法による復元

```python
def lagrange_interpolation(shares, p):
    """ラグランジュ補間によるシークレット復元

    Args:
        shares: (x, y)形式のシェアリスト
        p: 有限体の素数

    Returns:
        復元された秘密値
    """
    # ラグランジュ補間によるシークレット復元を実装
    # 有限体GF(p)上での計算に注意
```

### 4. 復号関数

```python
def decrypt(encrypted_file, share_ids, password):
    """暗号化ファイルの復号

    Args:
        encrypted_file: 暗号化されたファイル構造
        share_ids: ユーザー入力のシェアIDセット
        password: ユーザー入力のパスワード

    Returns:
        復元されたJSON文書またはデコードに失敗した場合は生データ
    """
    # メタデータ取得
    # 多段MAPを用いたシェア選択
    # 選択されたシェアを用いてチャンク別に秘密を復元
    # 復元されたデータに多段デコードを適用
    # JSONとして解析
```

### 5. 多段デコードと復元処理

```python
def try_decrypt(all_shares, share_ids, password, salt, threshold):
    """シェアを復号（A/B判定なしの直線的処理）

    Args:
        all_shares: 全シェアリスト
        share_ids: ユーザー入力のシェアIDセット
        password: ユーザー入力のパスワード
        salt: 暗号化時に生成された塩値
        threshold: 閾値（必要シェア数）

    Returns:
        復元されたバイトデータ
    """
    # 多段MAPの適用
    # チャンク別にシェアを整理
    # 各チャンクの復元（条件分岐なしの直線的処理）
    # 復元データの結合

def decode_data(data):
    """多段デコード処理

    Args:
        data: 復元されたバイトデータ

    Returns:
        デコードされたJSON文書または例外発生時のデータ
    """
    # Base64デコード
    # Latin-1からUTF-8へのエンコード変換
    # JSON解析
```

## 実装上の制約と注意点

### 1. 条件分岐の禁止と定数時間処理の実装

以下のパターンは条件分岐によるサイドチャネル攻撃を防止するために必須です。すべての条件分岐を含むコードパターンは**禁止**されます。

```python
# ⛔ 禁止: 条件分岐を使った選択
result = value_a if condition else value_b

# ✅ 推奨: ビット演算を用いた定数時間選択
mask = -(condition & 1)  # True -> -1 (all bits 1), False -> 0
result = (value_a & mask) | (value_b & ~mask)

# ⛔ 禁止: 早期リターンによる処理
for share in shares:
    if is_valid(share):
        return share

# ✅ 推奨: 全要素を処理しつつ条件を満たすものを記録
selected = None
for i, share in enumerate(shares):
    is_valid_share = is_valid(share)
    is_first_valid = is_valid_share and (selected is None)
    # ビット演算で条件分岐せずに選択
```

### 2. エラーハンドリング

- **失敗の特定を避ける**: 復号に失敗したか成功したかを外部から判別させない
- **例外処理の統一**: 例外を投げる場合も定数時間で処理
- **エラー情報の最小化**: エラーメッセージによる情報漏洩を防止

### 3. パフォーマンスとメモリ使用

- **チャンク単位の処理**: メモリ効率を高めるため、チャンク単位で処理
- **予測可能なメモリアロケーション**: メモリ使用パターンが入力によって大きく変わらないよう設計
- **カタストロフィックバックトラッキング対策**: 正規表現処理などでバックトラッキングによる処理時間増大を防止

## 復号成功・失敗の判定

復号結果の判定における重要なポイントは、成功・失敗の判定自体がタイミング攻撃につながる可能性があることです。

- **同一処理フローの維持**: 結果の正当性にかかわらず同じ処理を実行
- **条件分岐なしの結果返却**: 成功・失敗の判断基準を内部で持たない
- **エラー伝播の最小化**: 後続処理で JSON 解析失敗などが発生しても情報を漏洩させない

復号プロセスは常に同じステップを実行し、結果が正しい JSON かどうかの判断はこのモジュール外で行います。
# 更新モジュール実装ガイド

## 更新モジュールの目的

このモジュールは既存の暗号化ファイルに対して、特定のシェア ID セットとパスワードに対応する JSON 文書のみを更新します。更新処理は原子的に行われ、他の文書のシェアやメタデータに影響を与えません。

## 主要な機能と要件

### 1. 更新プロセスの安全性確保

- **原子的更新**: 更新が完了するまで元のファイルが損なわれない
- **他文書の保護**: 更新対象でない文書部分（シェア）に影響を与えない
- **コンカレンシーハンドリング**: 複数プロセスによる同時更新を安全に処理

### 2. 一時作業領域の管理

- **一時ファイルの確保**: 更新用の一時ファイルを別途生成し、UUID 付与で一意性確保
- **ロックファイルの管理**: 実行中プロセスを明示し、操作の衝突を防止
- **孤立リソースの検出と削除**: 完了・タイムアウトしたプロセスの一時ファイルを安全に削除

## 主要関数の実装ガイド

### 1. 更新関数の全体構造

```python
def update(encrypted_file, json_doc, password, share_ids):
    """
    暗号化ファイルの特定文書部分を更新

    Args:
        encrypted_file: 既存の暗号化ファイル構造
        json_doc: 新しいJSON文書
        password: 文書に対応するパスワード
        share_ids: 文書に対応するシェアIDセット

    Returns:
        更新された暗号化ファイル構造
    """
    # 一時ファイルとロックファイルの生成
    # 古い一時ファイルのクリーンアップ
    # 新しいシェア生成
    # 対象シェアIDの範囲内のシェアのみを更新
    # 検証と適用
    # 一時ファイルとロックの解放
```

### 2. 一時ファイル管理

```python
def create_temp_resources(operation="update"):
    """
    更新用の一時リソースを作成

    Args:
        operation: 操作種別("update"など)

    Returns:
        (process_uuid, temp_file_path, lock_file_path)のタプル
    """
    # プロセス固有UUIDの生成
    # 一時ファイルとロックファイルのパス生成
    # ロックファイル作成（PIDとタイムスタンプを記録）

def cleanup_stale_temp_files(directory, timeout_seconds=3600):
    """
    期限切れ/孤立した一時ファイルを削除

    Args:
        directory: 一時ファイルが格納されているディレクトリ
        timeout_seconds: プロセスがタイムアウトとみなされる秒数
    """
    # 現在時刻の取得
    # ロックファイルを検索
    # プロセスIDの存在確認
    # タイムスタンプ確認
    # 条件を満たす場合、関連ファイルを削除

def safe_remove_file(file_path):
    """
    ファイルを安全に削除（例外をキャッチして処理継続）

    Args:
        file_path: 削除するファイルのパス
    """
    # ファイルの存在確認
    # 安全な削除処理（例外をキャッチ）
```

### 3. シェア生成と更新

```python
def generate_new_shares(json_doc, threshold, share_ids, p):
    """
    新しいJSON文書からシェアを生成

    Args:
        json_doc: 新しいJSON文書
        threshold: 閾値
        share_ids: 更新対象のシェアIDセット
        p: 有限体の素数

    Returns:
        生成されたシェアのリスト
    """
    # JSON文書のエンコード処理
    # チャンクに分割
    # 各チャンクをシェア化
    # シェアのリストを返却

def update_shares(encrypted_file, new_shares, share_ids):
    """
    暗号化ファイル内の特定シェアを更新

    Args:
        encrypted_file: 既存の暗号化ファイル構造
        new_shares: 新しいシェアのリスト
        share_ids: 更新対象のシェアIDセット

    Returns:
        更新された暗号化ファイル構造
    """
    # 対象シェアIDの範囲内のシェアのみを更新
    # その他のシェアはそのまま保持
    # メタデータの更新（total_chunksなど）
```

### 4. 例外処理と原子性確保

```python
def safe_update(encrypted_file, json_doc, password, share_ids):
    """
    例外処理と原子性を確保した更新処理

    Args:
        encrypted_file: 既存の暗号化ファイル構造
        json_doc: 新しいJSON文書
        password: 文書に対応するパスワード
        share_ids: 文書に対応するシェアIDセット

    Returns:
        更新された暗号化ファイル構造または例外
    """
    # 一時リソースの確保
    # try-exceptブロックで更新処理
    # 例外発生時も一時ファイルとロックを確実に解放
    # 成功時のみ更新を適用
```

## 実装上の制約と注意点

### 1. 並行実行の安全性

- **PID チェック**: プロセス ID の存在確認によるロックの有効性検証
- **タイムスタンプベースのタイムアウト**: 長時間実行プロセスの検出と処理
- **ロックファイル形式の標準化**: JSON を用いたロック情報の構造化保存

```python
# ロックファイルの内容例
{
    'pid': 現在のプロセスID,
    'timestamp': 現在のタイムスタンプ,
    'operation': '操作種別（update等）'
}
```

### 2. エラー回復メカニズム

- **トランザクション的アプローチ**: 全ての更新が成功するか、全く変更が適用されないか
- **検証ステップ**: 変更適用前に新シェアが正しく復号可能か検証
- **ロールバック機能**: 問題が発生した場合に変更を取り消す処理

### 3. 一時ファイルの管理ベストプラクティス

- **一意な名前空間**: プロセス UUID を用いた一時ファイル名の一意性確保
- **場所の固定**: アプリケーション固有の一時ディレクトリを使用
- **有効期限ポリシー**: 一定時間経過後の自動クリーンアップ
- **権限設定**: 安全なアクセス権設定による保護

### 4. リソースリークの防止

- **try-finally パターン**: 例外発生時もリソースを確実に解放
- **明示的なクリーンアップ**: 処理成功時も明示的に一時リソースを解放
- **定期的なスキャン**: アプリケーション起動時などに孤立リソースをチェック

## 更新プロセスの全体フロー

```
一時作業領域の確保
↓
古い一時ファイルのクリーンアップ
↓
新シェアの生成
↓
一時ファイルに中間状態を保存
↓
対象シェアIDの範囲内のシェアのみを更新
↓
メタデータの更新
↓
更新された暗号化ファイルの生成
↓
一時ファイルとロックファイルの削除
```

## パフォーマンスとスケーラビリティ

更新処理のパフォーマンスとスケーラビリティを確保するための指針：

1. **インクリメンタル処理**: 大きなファイルでもメモリ効率よく処理
2. **シェア選択の最適化**: 更新対象シェアの効率的な選択アルゴリズム
3. **ロックの粒度**: 必要最小限の範囲のみロック
4. **バックグラウンド処理**: 長時間実行が予想される場合の非同期処理
# CLI インターフェース実装ガイド

## CLI の目的

この CLI インターフェースは、シャミア秘密分散法による複数平文復号システムの 3 つの主要機能（暗号化・復号・更新）を利用しやすくするためのコマンドラインツールです。セキュリティを確保しつつ、ユーザーフレンドリーな操作性を提供します。

## コマンド設計

### 1. ヘルプとサブコマンド構造

ツールは以下のサブコマンドを持ちます：

```
shamir-multi-crypt [グローバルオプション] <サブコマンド> [サブコマンドオプション]

サブコマンド:
  - init      : 新規暗号化ファイルを作成し、複数のJSON文書を暗号化
  - decrypt   : 暗号化ファイルから特定のJSON文書を復号
  - update    : 暗号化ファイル内の特定文書を更新
  - generate  : シェアIDセットを生成
  - help      : ヘルプを表示
```

### 2. 主要コマンドの詳細

#### 2.1. シェア ID 生成コマンド

```
shamir-multi-crypt generate --size <シェア数> --output <ファイル名>

オプション:
  --size, -s      : 生成するシェアIDの数 (デフォルト: 100)
  --output, -o    : 出力ファイル名 (デフォルト: shares-{timestamp}.json)
  --ratio, -r     : A:B:未割当の比率 (デフォルト: "35:35:30")
```

このコマンドは以下の処理を行います：

- 指定数のシェア ID を生成
- 比率に基づいて A 用、B 用、未割当に分類
- JSON ファイルに保存（パスワードでの保護も可能）

#### 2.2. 暗号化コマンド

```
shamir-multi-crypt init --file-a <JSON_A> --file-b <JSON_B> --shares-a <シェアIDファイルA> --shares-b <シェアIDファイルB> --output <暗号化ファイル>

オプション:
  --file-a, -a    : 文書AのJSONファイルパス
  --file-b, -b    : 文書BのJSONファイルパス
  --shares-a      : 文書A用のシェアIDリストファイル
  --shares-b      : 文書B用のシェアIDリストファイル
  --output, -o    : 出力暗号化ファイル名
  --threshold, -t : 閾値（デフォルト: 3）
  --password-a    : 文書Aのパスワード（指定しない場合はプロンプト）
  --password-b    : 文書Bのパスワード（指定しない場合はプロンプト）
```

このコマンドは以下の処理を行います：

- 2 つの JSON 文書を読み込み
- シェア ID リストを読み込み
- パスワードをプロンプト（指定されていない場合）
- 暗号化処理を実行し、指定された出力パスに保存

#### 2.3. 復号コマンド

```
shamir-multi-crypt decrypt --input <暗号化ファイル> --shares <シェアIDファイル> --output <出力JSONファイル>

オプション:
  --input, -i     : 暗号化ファイルパス
  --shares, -s    : シェアIDリストファイル
  --output, -o    : 出力JSONファイル名（デフォルト: decrypted-{timestamp}.json）
  --password, -p  : パスワード（指定しない場合はプロンプト）
```

このコマンドは以下の処理を行います：

- 暗号化ファイルとシェア ID リストを読み込み
- パスワードをプロンプト（指定されていない場合）
- 復号処理を実行し、指定された出力パスに JSON を保存

#### 2.4. 更新コマンド

```
shamir-multi-crypt update --input <暗号化ファイル> --file <新JSONファイル> --shares <シェアIDファイル> --output <更新後ファイル>

オプション:
  --input, -i     : 元の暗号化ファイルパス
  --file, -f      : 新しいJSON文書ファイル
  --shares, -s    : シェアIDリストファイル
  --output, -o    : 更新後の暗号化ファイル名（デフォルト: 上書き）
  --password, -p  : パスワード（指定しない場合はプロンプト）
  --backup, -b    : 元ファイルのバックアップを作成（デフォルト: true）
```

このコマンドは以下の処理を行います：

- 元の暗号化ファイル、新しい JSON 文書、シェア ID リストを読み込み
- パスワードをプロンプト（指定されていない場合）
- 必要に応じて元ファイルのバックアップを作成
- 更新処理を実行し、結果を保存

### 3. グローバルオプション

全コマンド共通のオプション：

```
--verbose, -v   : 詳細なログ出力を有効化
--quiet, -q     : 出力を最小限に抑える
--log-file      : ログの出力先ファイル
--help, -h      : ヘルプを表示
--version       : バージョン情報を表示
```

## 実装ガイドライン

### 1. パスワード入力の安全な処理

```python
def prompt_password(prompt_text="パスワードを入力してください: "):
    """
    パスワードを安全にプロンプト

    Args:
        prompt_text: プロンプト表示テキスト

    Returns:
        入力されたパスワード
    """
    # getpassモジュールを使用して画面に表示せずにパスワード入力
    import getpass
    return getpass.getpass(prompt_text)
```

### 2. シェア ID リストの処理

```python
def load_share_ids(share_file):
    """
    シェアIDリストファイルを読み込み

    Args:
        share_file: シェアIDリストのJSONファイルパス

    Returns:
        シェアIDのリスト
    """
    # ファイル読み込み
    # JSONとして解析
    # シェアIDのリストを返却
```

### 3. ファイル処理の安全性確保

```python
def safe_write_file(data, output_path, backup=False):
    """
    ファイルの安全な書き込み

    Args:
        data: 書き込むデータ
        output_path: 出力先パス
        backup: 既存ファイルのバックアップを作成するか

    Returns:
        成功時True
    """
    # バックアップが有効な場合、既存ファイルをバックアップ
    # 一時ファイルに書き込み
    # 書き込み成功後、目的のパスに移動/リネーム
```

### 4. メイン CLI 関数

```python
def main():
    """CLI エントリーポイント"""
    # コマンドライン引数のパース
    # サブコマンドに応じた処理の分岐
    # エラーハンドリングと適切なステータスコードでの終了
```

### 5. コマンド実装例

```python
def encrypt_command(args):
    """init サブコマンドの実装"""
    # 引数の検証
    # 必要なファイルの読み込み
    # パスワードプロンプト（必要な場合）
    # 暗号化モジュールの呼び出し
    # 結果の保存
    # 成功メッセージの表示

def decrypt_command(args):
    """decrypt サブコマンドの実装"""
    # 引数の検証
    # 必要なファイルの読み込み
    # パスワードプロンプト（必要な場合）
    # 復号モジュールの呼び出し
    # 結果の保存
    # 成功メッセージの表示
```

## セキュリティ上の注意点

### 1. パスワード取り扱い

- **メモリ保持の最小化**: パスワードはメモリ上に保持する時間を最小限に
- **環境変数の禁止**: パスワードを環境変数に保存しない
- **ヒストリー対策**: コマンドラインオプションより対話的入力を優先
- **安全なプロンプト**: `getpass`モジュールなどを使用して画面に表示しない

### 2. エラーメッセージと情報漏洩

- **汎用エラーメッセージ**: エラーの詳細が機密情報を漏らさないよう注意
- **常に一定時間実行**: 無効なパスワードなどでも処理時間が変わらないよう考慮
- **同一失敗メッセージ**: 異なる失敗原因でも同じメッセージを表示

### 3. ファイル処理

- **アトミック操作**: ファイル更新は常にアトミックに行う
- **一時ファイルの保護**: 適切なパーミッションでの一時ファイル作成
- **残留データの防止**: 処理完了後に一時ファイルやメモリを適切にクリーンアップ

## ユーザービリティ

### 1. プログレス表示

```python
def show_progress(current, total, prefix='', suffix='', bar_length=50):
    """
    プログレスバーを表示

    Args:
        current: 現在の進捗
        total: 全体量
        prefix: プレフィックステキスト
        suffix: サフィックステキスト
        bar_length: バーの長さ
    """
    # プログレスバー表示ロジック
```

### 2. 色付き出力

```python
class Colors:
    """ANSI カラーコード"""
    HEADER = '\033[95m'
    BLUE = '\033[94m'
    GREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'

def colorize(text, color):
    """テキストに色を付ける"""
    return f"{color}{text}{Colors.ENDC}"
```

### 3. ヘルプメッセージ

明確で詳細なヘルプメッセージを各コマンドに提供します：

```python
# コマンドの説明例
init_parser = subparsers.add_parser(
    'init',
    help='新規暗号化ファイルを作成し、複数のJSON文書を暗号化',
    description='2つのJSON文書（A・B）と各シェアIDセットを用いて暗号化ファイルを生成します。'
             '生成されたファイルは各パスワードとシェアIDセットで復号可能です。'
)
```

### 4. エラー処理とフィードバック

```python
def handle_error(error, verbose=False):
    """
    エラーを適切に処理して表示

    Args:
        error: 発生したエラー/例外
        verbose: 詳細表示モードか
    """
    # エラータイプに応じた処理
    # verboseモードの場合は詳細表示
    # 適切なエラーコードで終了
```

## リリースとパッケージング

### 1. バージョン管理

```python
__version__ = '1.0.0'

def show_version():
    """バージョン情報を表示"""
    print(f"shamir-multi-crypt version {__version__}")
    print("シャミア秘密分散法による複数平文復号システム")
```

### 2. エントリーポイント定義

`setup.py` または `pyproject.toml` でのエントリーポイント定義：

```python
# setup.py の例
setup(
    # ...その他の設定...
    entry_points={
        'console_scripts': [
            'shamir-multi-crypt=shamir_multi_crypt.cli:main',
        ],
    },
)
```

---

## 実装の追加指示

1. このシステムは情報理論的安全性を持つよう設計されています。すべての実装においてこの原則に忠実であることが最重要です。
2. タイミング攻撃を防ぐため、条件分岐の禁止と定数時間処理は絶対に守ってください。
3. 暗号処理において、設計書にあるアルゴリズムから逸脱しないでください。
4. 「正しいパスワードによる復号」に見せかけたバックドアを仕掛けないでください。
5. 「統計的区別不可能性」を確保するためのA/B/未割当シェア分布を維持してください。

実装を開始してください。モジュール分割と正しいインポート関係を考慮したファイル構成から検討することをお勧めします。

備考：このシステムの主要な技術的特徴（多段MAP方式とシャミアベースの多重復号）は、研究目的での実装です。

制約条件：すべての原則を守りつつ実現できない場合は、何が達成できて何が難しいかを説明してください。
その際、セキュリティの実現が最優先です。機能を制限してでもセキュリティ原則を守ってください。

実装完了後は、コードの概要と使用方法を簡潔に説明してください。
