# ラビット＋準同型マスキング暗号プロセッサ - 実装タスク実行指示

## 📢 タスク実行にあたっての重要指示

### 進行管理

- **全て完了するまでレポートを作成しないでください**。これは非常に重要です。先に報告書を作成し後から実装したり、実装していないことを実装済みと報告することは禁止します。
- 各タスクは独立して 1 つずつ完了させてください。複数のタスクを同時に進行させないでください。
- 問題が発生した場合は、作業を中断し、具体的な問題点を明確に報告してください。

### 実装原則

- ベストプラクティスに反する実装を禁止します。そのようなシナリオになった時は直ちに作業を中断して指示を仰いでください。
- 要件を全て満たした上で実装作業を進めてください。この作業だけを完了させるために既に満たしている要件を犠牲にしたり要件そのものを歪曲しないでください。
- 特定のタスクに明示されている機能「のみ」を実装し、タスク外の機能実装は行わないでください。
- 指定されたディレクトリ構造とファイル名を厳守してください。

### ドキュメント・報告要件

- 問題が発生したら範囲外の事象でもレポートにて報告すること。
- 最終レポートには以下を含めてください：
  - ディレクトリ一覧とファイル配置図（テキスト式）
  - 詳細な実装説明（各機能の動作原理と実装アプローチ）
  - テスト結果と検証内容
  - 発見された課題と解決方法
- デイレクトリ構成、ファイル名、パラメータ名などは完全に全てを記述すること。
- mermaid 記法、markdown 形式の表が利用できます。
- ダークモードで見やすい配色で記述してください。

### 技術的制約

- ファイルの行数が 500 行を超える時は、複数ファイルに分割してください。
- ファイルサイズが大きい時は、複数ファイルに分割してください。
- テストファイルの出力先は'test_output'ディレクトリに用意されています。
- 処理能力を超えてしまうのでひとつのファイルに長大な内容を書き込もうとしないこと。

### 禁止事項

- 問題があったときに問題を隠匿するコードを生成してテストを通過させることは厳格に禁止します。
- 復号が正常に行われないトラブルが発生したときに、緊急対応として鍵の種類に応じて事前定義されたテキストをバイパス出力する不正改造を行うことを禁止します。
- バックドアを設置し、あたかも暗号復号が正確に実装され、true/false のテキストも要件通りスイッチできているように見せかける不正実装を禁止します。
- テストコードの改変は絶対に許可されません。テストが失敗する場合は実装を修正してください。

## 🛠️ 要求の完了方法

1. **実装完了条件**をすべて満たし、すべてのテストが通過してから最終レポートを作成してください。
2. 実装レポートは指定された命名規則に従い docs/issue/ディレクトリに保存してください。
3. テスト結果のスクリーンショットを必ず添付し、結果の正確さを証明してください。
4. 完成後は git コマンドでコミットとプッシュを行ってください。
5. イシューコメントとして実装レポートを投稿してください。

## 💻 開発環境に関する情報

- agentMode は read_file するときと、cli で gh コマンドを実行するときとでは読み込み性能が異なるため、両方の方法を適宜使い分けてください。
- タスク文書は全て読み切れない場合があるため、必要に応じて部分的に読み込みながら実装を進めてください。
- コマンド実行時のエラーは慎重に分析し、原因と対策を明確にしてください。

## 📋 前提となる要件仕様

- どちらのキーが「正規」か「非正規」かはシステム上の区別ではなく、使用者の意図によって決まります。
- 「ハニーポット戦略」が実装可能 - 意図的に「正規」鍵を漏洩させて偽情報を信じ込ませることができます。
- 本当に重要な情報を「非正規」側に隠す「リバーストラップ」も設定可能です。
- 製品版ではないため、極力 common でファイルを共有して効率化を図らないでください。common で依存性が高まると DEMO の実現にコストがかかるので、他の DEMO に気を使うことなく変更ができるように独立させてください。
- 攻撃者は暗号化・復号プログラムのソースコードを完全に入手していると仮定します。
- 攻撃者は復号結果が正規の true.text か非正規の false.text かを判別しようと試みます。
- 攻撃者がスクリプト解析しても生成物が正規か非正規か判別できないようにすること。
- 暗号強度は範囲外とし、方式の特性を実現することが最大の目的です（暗号強度は別のフェーズが責務を負います）。
- 鍵情報以外の部分からは判別材料が得られない強靭な仕組みが要件です。
- スクリプトを変更・改造されても、秘密経路の識別は数学的に不可能な設計が要件です。

## 📥 実装作業の開始方法

各タスク（T1 から T18）は必ず一つずつ順番に実行してください。

1. 現在のタスク（例：T1）の指示書を読み込む
2. 「タスク単体実行プロンプトテンプレート」を利用して実行指示を作成
3. タスクを完全に実装し、すべてのテストが通過したことを確認
4. 完了レポートを作成し、提出
5. 承認を得てから次のタスク（例：T2）に進む

**重要**: 複数のタスクを同時に開始したり、未完了のまま次のタスクに進むことは厳禁です。各タスクは必ず独立して完全に完了させてから次に進んでください。

## 📚 タスク実行時の必須参照文書

タスクを実行する際は、以下の文書を**必ず**参照してください：

1. **実装指示書**: `/Users/macbook/shamir-secret-sharing-demo/docs/method_11_rabbit_homomorphic_docs/issue/T{番号}_{タスク名}.md`
2. **GitHub イシュー**: `https://github.com/pacific-system/secret-sharing-demos-20250510/issues/{イシュー番号}`

### ⚠️ 警告：内容の推測・創作禁止

上記の文書には実装に必要な詳細な要件、制約条件、完了基準が含まれています。これらの参照先を読まずに実装を進めると、以下の問題が発生します：

- 内容の推測と創作による誤った実装
- 要件との不一致
- 必要なセキュリティ対策の欠落
- タスク境界の混同（実装すべきでない機能の実装）

### 🔍 実装手順

1. 指定された**実装指示書**を最初に完全に読み込む
2. **GitHub イシュー**の内容と関連コメントを確認する
3. 実装指示書に記載された要件に厳密に従う
4. タスク範囲を厳守し、指示書に明示されている機能「のみ」を実装する
5. 不明点がある場合は、推測せず質問する

### 📋 具体例：T1 実行の場合

- **実装指示書**: `/Users/macbook/shamir-secret-sharing-demo/docs/method_11_rabbit_homomorphic_docs/issue/T1_logger_implementation.md`
- **GitHub イシュー**: `https://github.com/pacific-system/secret-sharing-demos-20250510/issues/42`

これらの文書には、ロギング基盤実装に関する全ての必要情報が含まれています。文書内に定義された機能のみを実装し、T2 以降の機能（log_levels.py など）は実装しないでください。

## 🔐 暗号システムの絶対要件

本システムの実装において、以下の要件は**絶対に妥協できない核心的要件**です。これらの要件を満たさない実装は、たとえ他の機能が正常に動作していても、根本的に失敗と見なされます：

### 1. 鍵のみによる判別の原則

- **絶対要件**: 復号される文書は「鍵の違いのみ」によって決定されなければならない
- **禁止事項**: `decrypt_type`, `is_true_file`などのフラグや識別子を使用して文書を判別すること
- **理由**: 攻撃者がソースコードを完全に入手していても、鍵なしでは文書を判別できないようにするため

#### 🚫 禁止される実装例：

```python
# 誤った実装 - 絶対に禁止
def decrypt(encrypted_data, key, is_true_file=True):
    # 復号処理...
    if is_true_file:
        return true_content
    else:
        return false_content
```

#### ✅ 求められる実装方針：

```python
# 正しい実装方針
def decrypt(encrypted_data, key):
    # 鍵から導出される情報のみを使用して復号経路を決定
    derived_path = derive_path_from_key_only(key)
    # 鍵に基づいて復号
    return decrypt_with_path(encrypted_data, derived_path)
```

### 2. 鍵の完全独立性の原則

- **絶対要件**: 鍵 A で復号した攻撃者は、鍵 B を入手しない限り鍵 B に紐付く文書を取り出せない
- **禁止事項**: 一方の鍵から他方の鍵またはその鍵に関連する文書が推測・導出可能な実装
- **理由**: 「ハニーポット戦略」「リバーストラップ」を実現するため

#### 🚫 禁止される実装例：

```python
# 誤った実装 - 絶対に禁止
def generate_second_key(first_key):
    # 最初の鍵から2つ目の鍵を生成（推測可能）
    return first_key[::-1]  # 単に逆順にするなど
```

#### ✅ 求められる実装方針：

```python
# 正しい実装方針
# 各鍵は完全に独立して生成
def generate_keys():
    true_key = generate_secure_random_key()
    false_key = generate_secure_random_key()
    # 両方の鍵が独立していることを確認
    verify_key_independence(true_key, false_key)
    return true_key, false_key
```

### ⚠️ これらの要件に関する警告

1. **難易度が高いと感じても要件を放棄しないでください**
2. **要件を満たすことが難しい場合は、実装方法を質問してください**
3. **短期的な解決策のために妥協することは絶対に許可されません**
4. **これらの要件を満たさない実装はすべて拒否され、実装をやり直す必要があります**
5. **要件を満たす方法が分からない場合は、「わからない」と率直に伝えてください。推測による実装は避けてください**

## 📝 タスク単体実行プロンプトテンプレート

AgentMode でタスクを１つずつ確実に実行するために、以下のテンプレートを使用してください：

```markdown
# T{番号}：{タスク名} 実行指示

## 🎯 実行対象

- 現在のタスク: **T{番号}**（{タスク名}）
- タスク範囲: `/docs/method_11_rabbit_homomorphic_docs/issue/T{番号}_{タスク名}.md` に記載された機能のみ
- 依存関係: {依存タスク番号がある場合は記載}

## 📋 タスク概要と範囲

このタスクでは以下の機能「のみ」を実装します：

- {タスクの具体的な機能・範囲を箇条書きで}

以下は実装「しない」でください：

- {次のタスクや範囲外の機能を箇条書きで}

## 🔍 作業手順

1. まずタスク指示書を詳細に読み込み、要件を完全に理解してください
2. 実装計画を立て、必要なファイル構造とモジュール設計を決定してください
3. 実装を開始し、1 つの機能ごとにテストして進めてください
4. すべての機能実装後、総合テストを実施してください
5. 完了条件をすべて確認してから最終レポートを作成してください

## ⚠️ 制約事項

- **タスク境界の厳守**: このタスク(T{番号})の範囲内の機能「のみ」を実装してください
- **一度に 1 機能**: 複数の機能を同時に実装せず、1 つずつ確実に実装してください
- **テスト改変禁止**: テストが失敗した場合は実装を修正し、テストコードは変更しないでください
- **レポート作成タイミング**: すべての実装と検証が完了してから最終レポートを作成してください

## 🚨 問題発生時の対応

問題が発生した場合は：

1. 作業を一時停止してください
2. 具体的な問題点と現在の状況を報告してください
3. 解決策の方針を提案してください
4. 指示を待ってから作業を再開してください

## 📝 完了レポート

すべての実装が完了し、テストが通過した後に以下の形式で報告してください：

1. **実装内容**：機能ごとの実装概要
2. **テスト結果**：実行したテストとその結果
3. **テスト画像**：テスト結果のスクリーンショット
4. **発見した課題と解決策**：実装中に遭遇した問題と解決方法
5. **ディレクトリ構造**：作成・変更したファイル一覧

## 🔄 次のステップ

このタスクが完了したら、次のタスク(T{次のタスク番号})に進む前に確認を取ってください。
```
