# シャミア秘密分散法による複数平文復号システム - 実装プロンプト

## 実装者のペルソナ

あなたは暗号学とセキュアコーディングに精通した優秀なPython開発者です。
シャミア秘密分散法に関する深い知識を持ち、セキュリティシステムの実装経験が豊富です。
「統計的区別不可能性」「定数時間処理」「サイドチャネル攻撃への対策」などの概念を熟知しています。
また、Pythonにおけるベストプラクティスを遵守し、効率的で保守性の高いコードを作成します。

以下の設計に基づいて、シャミア秘密分散法による複数平文復号システムをPythonで実装してください。
システムの核心は「複数の平文を単一の暗号ファイルに格納し、別々のパスワードでそれぞれ復号可能にする」ことです。

---

# シャミア秘密分散法による複数平文復号システム - 実装プロンプト

## システム概要と目的

あなたは暗号学とセキュアコーディングに精通した開発者です。シャミア秘密分散法を応用した「複数平文復号システム」を実装してください。このシステムは単一の暗号化ファイルから異なるパスワードを使用して異なる平文（JSON 文書）を復号可能にするものです。

**核心技術**: 「シェア ID による可能性の限定とパスワードによるマップ生成」という多段 MAP 方式

**重要な原則**: このシステムはケルクホフの原理に厳格に従います。アルゴリズムが完全に公開されてもパスワード（鍵）が秘匿されている限りセキュリティが保たれるよう設計してください。

## システムアーキテクチャ

### 基本原理

1. **シャミア秘密分散法**: 閾値暗号の一種。秘密情報を複数のシェアに分散し、一定数以上のシェアで元の情報を復元
2. **多段 MAP 方式**: シェア ID による第 1 段階の絞り込みとパスワードによる第 2 段階のマッピング
3. **統計的区別不可能性**: 異なる文書のシェアや未割当領域のシェアが統計的に区別できない
4. **直線的処理**: 復号処理中に評価や条件分岐を一切含まない

### 多段 MAP 方式の詳細

1. **第 1 段階（シェア ID による限定）**:

   - ユーザーが保持するシェア ID セットにより、全シェア空間から復号候補となるシェアの範囲を限定
   - この段階で不要なシェアの大部分を除外

2. **第 2 段階（パスワードによるマッピング）**:
   - パスワードから鍵導出関数を用いてマップデータを生成
   - 第 1 段階で限定された範囲内のシェアだけを対象にマッピングを適用
   - マッピング結果に基づき、実際に復号に使用するシェアを特定

## 実装上の絶対条件

### 1. セキュリティモデルの厳守

- **条件分岐の禁止**: 復号処理中に条件分岐を含めないこと（タイミング攻撃対策）
- **定数時間処理**: 全ての操作が入力値に関係なく一定時間で処理されること
- **統計的区別不可能性**: シェアの種類（A/B/未割当）が統計的に区別できないこと

### 2. シェア ID 空間設計

- **分割比率**: A 用 30-40%、B 用 30-40%、未割当 20-40%
- **分散配置**: 連続範囲や単純パターンを避け、バラバラに配置
- **実装方法**: 擬似乱数生成器で初期化、割り当て判別には 4 要素（パスワード A、B、シェア ID セット A、B）が全て必要

### 3. データ構造設計原則

- **最小情報の原則**: 復号に必須の情報のみを保存
- **識別情報の排除**: 文書種別の識別子（A/B 等）を含めない
- **構造的匿名性**: データ構造自体から情報が漏洩しないよう設計
- **冗長性の最小化**: 同じ情報を複数箇所に保存しない

### 4. 禁止事項

- ベストプラクティスに反する実装
- バックドアの設置や復号偽装
- 大原則（統計的区別不可能性、直線的処理等）を回避する設計

## 全体構成と依存関係

実装は次の 3 つの主要コンポーネントに分割されます:

1. **暗号化モジュール**: 複数の JSON 文書を単一の暗号化ファイルにエンコード
2. **復号化モジュール**: シェア ID とパスワードを用いて暗号化ファイルから特定の JSON 文書を復元
3. **更新モジュール**: 既存の暗号化ファイルの特定文書部分のみを安全に更新

これらのモジュールは CLI インターフェースから呼び出されます。
それぞれのモジュールの詳細実装は各ファイルを参照してください。

## 実装言語とライブラリ

- 実装言語: **Python**
- 推奨暗号ライブラリ:
  - KDF: `hashlib.pbkdf2_hmac` または `argon2-cffi`
  - 乱数生成: `secrets`モジュール
  - 有限体演算: `gmpy2`（必要な場合）
# 初期化モジュール実装ガイド

## 初期化モジュールの目的

このモジュールはシステムの初期設定を行い、シェア ID 空間を構築します。シェア ID を A 文書用、B 文書用、未割当に分割し、それぞれをセキュアに管理するための基盤を提供します。

## 主要な機能と要件

### 1. シェア ID 空間の設計と分割

- **分割比率**: A 用 30-40%、B 用 30-40%、未割当 20-40%
- **分散配置**: 連続範囲や偶数/奇数などの単純パターンを避け、ランダムに分散
- **安全性**: どの部分を切り取っても、A、B、未割当の識別が統計的に不可能

### 2. 出力データの独立性と安全性

- **セキュリティ分離**: A 文書と B 文書の両方を俯瞰できるマスターデータは出力しない
- **独立出力**: A 用シェア ID と B 用シェア ID は別々のファイルとして出力
- **高度暗号化**: シェアデータは高度に暗号化されたバイナリファイル形式で保存
- **パスワード保護**: 各シェアファイルはそれぞれ独立したパスワードで保護

### 3. シェア生成とランダム性の確保

- **暗号学的乱数**: 安全な乱数生成器を使用してシェア ID 空間を構築
- **反復検証**: 生成された分布の統計的特性を検証し、偏りがないことを確認
- **不可逆性**: 生成プロセスは一方向であり、シェアから元の割り当てを推測不可能

## 主要関数の実装ガイド

### 1. シェア ID 空間の生成

```python
def generate_share_id_space(total_shares, ratio_a, ratio_b, ratio_unassigned):
    """
    シェアID空間を生成して分割

    Args:
        total_shares (int): 生成するシェアID総数
        ratio_a (int): A用シェアの比率
        ratio_b (int): B用シェアの比率
        ratio_unassigned (int): 未割当シェアの比率

    Returns:
        tuple: (a_ids, b_ids, unassigned_ids) - 各カテゴリのシェアIDリスト
    """
    # 1. 全IDの生成（1からtotal_sharesまでの整数）
    # 2. シャッフルして順序をランダム化
    # 3. 比率に基づいて分割
    # 4. 各セットを返却
```

### 2. シェアファイルの暗号化出力

```python
def encrypt_share_file(share_ids, password, output_path):
    """
    シェアIDリストを暗号化してファイルに保存

    Args:
        share_ids (list): 暗号化するシェアIDのリスト
        password (str): 暗号化に使用するパスワード
        output_path (str): 出力ファイルパス

    Returns:
        bool: 成功した場合はTrue
    """
    # 1. シェアIDリストをバイナリ形式にシリアライズ
    # 2. パスワードから強力な鍵を導出
    # 3. 乱数IV(初期化ベクトル)を生成
    # 4. AES-GCMなど認証付き暗号化を適用
    # 5. メタデータ（バージョン、アルゴリズム情報）を追加
    # 6. バイナリファイルとして保存
```

### 3. シェアファイルの検証

```python
def verify_share_file(file_path, password):
    """
    暗号化されたシェアファイルを検証

    Args:
        file_path (str): 検証するファイルのパス
        password (str): 復号用パスワード

    Returns:
        bool: ファイルが有効な場合はTrue
    """
    # 1. ファイルからメタデータを読み取り
    # 2. パスワードから鍵を再導出
    # 3. 認証を検証
    # 4. 内容を復号
    # 5. フォーマット確認
```

## 実装上の制約とガイドライン

### 1. セキュリティ要件

- **識別不能性**: A 用、B 用、未割当のシェア ID が統計的に区別できないこと
- **マスターデータの排除**: A、B 両方のシェア ID 情報を含むマスターファイルを出力しない
- **暗号強度**: 最低でも AES-256 レベルの暗号強度を確保
- **キーストレッチング**: パスワードからの鍵導出には強力な KDF（Argon2 など）を使用

### 2. ファイル出力形式

- **独立ファイル**: A 用、B 用のシェアは別々のファイルに保存
- **バイナリ形式**: JSON ではなく、バイナリ形式で保存
- **認証タグ**: データの完全性と認証を確保するためのタグを含める
- **ファイル構造**: ヘッダ（メタデータ）、IV、暗号文、認証タグの構成

### 3. バックアップと冗長性

- **バックアップ推奨**: 初期化後のシェアファイルは安全にバックアップすることを強く推奨
- **エクスポート機能**: 必要に応じてプレーンテキスト形式でエクスポート可能（開発者オプション）
- **リカバリーメカニズム**: シェアファイル損失時のリカバリー手段を提供しない（セキュリティ上の理由）

## 出力ファイル形式の詳細

初期化モジュールが出力するシェアファイルは、以下の構造を持つバイナリファイルです：

```
[ファイルマジック (8バイト)] - 固定識別子
[バージョン (2バイト)] - ファイル形式バージョン
[アルゴリズム識別子 (2バイト)] - 使用暗号化アルゴリズム
[KDFパラメータ (可変長)] - 鍵導出関数のパラメータ
[IV (16バイト)] - 初期化ベクトル
[暗号化データ (可変長)] - 暗号化されたシェアIDリスト
[認証タグ (16バイト)] - GCMモード認証タグ
```

**重要**: このバイナリファイル形式は JSON 形式よりも解析が困難で、内容が暗号化されているため、不正アクセスから保護されます。
# 暗号化モジュール実装ガイド

## 暗号化モジュールの目的

このモジュールは一度に一つの JSON 文書（A 文書または B 文書）を暗号化ファイルに変換します。核心となる多段 MAP 方式とシャミア秘密分散法を用いて、異なるパスワードで異なる文書を復号できるようにします。

**重要**: 両方の文書を一度に暗号化する処理は一切実装禁止です。必ず一文書ずつ個別に暗号化してください。

## 主要な機能と要件

### 1. 多段エンコードプロセス

JSON 文書は以下の多段エンコードプロセスを適用します：

1. UTF-8 テキスト（元の JSON）
2. Latin-1 へのエンコード変換
3. Base64 エンコード
4. 常に圧縮（条件判断なし）

### 2. シャミア秘密分散法の実装

- 多項式の次数と閾値：実用的な値として閾値`t=3`～`5`
- 有限体の選択：大きな素数`p`を用いた有限体 GF(p)上での計算
- 推奨： 文書サイズに応じて十分大きい素数を選択（例：2^256-189）

### 3. シェア ID 空間の設計と管理

- A 用と B 用のシェア ID は予め分割し、暗号化時にはそれらを使用するだけ
- 未割当領域には統計的に区別不能なランダムデータを生成
- シェア ID の分布は特定のパターンを形成しないよう設計（交互配置など）

### 4. 暗号化プロセスの全体フロー

```
データの前処理（多段エンコード）
↓
データをチャンクに分割
↓
各チャンクをシャミア秘密分散でシェア化
↓
未割当領域にゴミデータを生成
↓
シェアをシャッフル
↓
メタデータを追加して高度に暗号化されたファイル生成
```

## 実装時の制約とガイドライン

### 絶対条件

1. **識別情報の排除**:

   - どのシェアがどの文書（A または B）に属するかを示す情報を格納しない
   - すべてのメタデータは A/B 区別なく同一形式

2. **シェア値の統計的区別不可能性**:

   - A 文書のシェア、B 文書のシェア、未割当領域のゴミデータが統計的に区別できないこと
   - これは情報理論的安全性のために必須

3. **保存データの最小化と高度暗号化**:

   - シャミア秘密分散法で生成されたシェア値
   - 塩値（再計算不可能な乱数）
   - 復号に必要な最小限のメタデータ（閾値など）
   - シェア ID はユーザー入力として提供されるため保存不要
   - マッピング情報はパスワードとシェア ID から計算で再生成可能なため保存不要
   - 全データはバイナリ形式で高度に暗号化して保存

4. **UUID の使用**:
   - 暗号化ファイル、復号化ファイル、シェアなどには UUID を付与する
   - ファイル名に UUID を含めて重複による上書きを防止
   - 一時ファイルやバックアップファイルにも一意の識別子を使用

### 主要関数の実装ガイド

#### 1. シャミア秘密分散法の実装

```python
def generate_polynomial(secret, degree, p):
    """degree次の多項式を生成"""
    # 係数配列を生成（最初の要素は秘密値）
    # 乱数を用いて残りの係数を生成

def evaluate_polynomial(coef, x, p):
    """多項式の評価"""
    # 係数配列と評価点xから多項式の値を計算

def generate_shares(secret, t, n, p):
    """n個のシェアを生成、閾値はt"""
    # 多項式を生成し、各シェアIDに対する値を計算
```

#### 2. 暗号化関数

```python
def encrypt(json_doc, password, share_ids, unassigned_ids, threshold=3):
    """
    単一のJSON文書を暗号化

    Args:
        json_doc: 暗号化するJSON文書（A文書またはB文書の一方のみ）
        password: 文書に対応するパスワード
        share_ids: 文書に対応するシェアIDセット
        unassigned_ids: 未割当のシェアIDリスト
        threshold: シェア復元に必要な閾値

    Returns:
        bytes: 高度に暗号化されたバイナリデータ（UUIDを含む識別子付き）
    """
    # 1. 単一JSON文書のエンコード処理
    # 2. チャンクに分割
    # 3. 各チャンクをシェア化（識別不能に）
    # 4. 未割当領域にゴミデータ生成
    # 5. シェアをシャッフル
    # 6. UUIDを生成しメタデータに含める
    # 7. 全体を二次暗号化して高度なセキュリティを確保
```

#### 3. 補助関数

```python
def preprocess_data(json_doc):
    """JSON文書の前処理（多段エンコード）"""
    # UTF-8 → Latin-1 → Base64の多段エンコード

def split_into_chunks(data, chunk_size=64):
    """データを固定長チャンクに分割"""
    # データをチャンクに分割

def generate_chunk_shares(secret, threshold, share_ids, p):
    """チャンクのシェア生成"""
    # シャミアの多項式を使ってシェアを生成

def generate_garbage_shares(unassigned_ids, num_real_shares, p):
    """未割当領域のゴミデータ生成"""
    # 統計的に区別できないランダムデータ生成

def encrypt_file_data(data, master_key):
    """データを高度に暗号化"""
    # AES-GCMなどの認証付き暗号化を適用
    # ファイルフォーマットを構築

def generate_file_uuid():
    """ファイル用のUUIDを生成"""
    # UUID v4を生成
    # ファイル識別に適した文字列形式に変換
```

### 出力形式

暗号化の結果は高度に暗号化されたバイナリファイル形式で、以下の構造を持ちます：

```
[ファイルマジック (8バイト)] - 固定識別子
[UUID (16バイト)] - ファイル固有識別子
[バージョン (2バイト)] - ファイル形式バージョン
[アルゴリズム識別子 (2バイト)] - 使用暗号化アルゴリズム
[KDFパラメータ (可変長)] - 鍵導出関数のパラメータ
[IV (16バイト)] - 初期化ベクトル
[暗号化メタデータ (可変長)] - 暗号化された復号必須情報
[暗号化シェアデータ (可変長)] - 暗号化されたシェア情報
[認証タグ (16バイト)] - GCMモード認証タグ
```

この暗号化されたメタデータには次の情報が含まれます（暗号化されている）:

```
- 塩値（Salt）
- チャンク総数
- 閾値
- 使用素数
- その他必要な情報（A/B識別情報は含まない）
```

## 実装上の注意点

1. **セキュアな乱数生成**:

   - `secrets`モジュールを使用して暗号学的に安全な乱数を生成

2. **素数の選択**:

   - 有限体演算に使用する素数は十分に大きく選ぶ
   - 素数サイズは扱うデータサイズに合わせて調整

3. **効率性とメモリ使用量**:

   - 大きなファイルでもメモリ効率よく処理できるよう設計
   - 入力サイズの 3-4 倍程度のメモリ使用に抑える

4. **二重暗号化**:

   - データ本体の暗号化に加え、ファイル全体を二次暗号化することで安全性を強化
   - パスワードと乱数ソルトから導出した鍵を使用

5. **カナリア値**:

   - 復号検証用のカナリア値を埋め込み、正しい復号を確認できるようにする
   - カナリア値自体も暗号化して格納

6. **ファイル命名と衝突回避**:
   - 出力ファイル名に UUID を含める（例: `encrypted-{uuid}.bin`）
   - 一時ファイルとバックアップファイルにも異なる UUID を付与
   - UUID 生成には Python の`uuid`モジュールを使用
# 復号化モジュール実装ガイド

## 復号化モジュールの目的

このモジュールは高度に暗号化されたバイナリファイルから、特定のシェア ID セットとパスワードを用いて単一の JSON 文書を復元します。多段 MAP 方式の特徴を活かし、パスワードによって異なる文書が復号される仕組みです。

## 重要なセキュリティ要件

### 1. 直線的処理の厳格な実装

復号処理において最も重要な要件は「直線的処理」です：

- **条件分岐の禁止**: どのような状況でも入力値による条件分岐を行わない
- **定数時間処理**: 全ての処理が入力値に関わらず同じ時間で実行される
- **タイミング攻撃耐性**: 処理時間から入力情報が推測できないようにする

### 2. 多段 MAP 方式の正確な実装

1. **第 1 段階（シェア ID による限定）**:

   - 入力されたシェア ID セットで候補シェアを限定
   - 該当しないシェア ID のシェアは完全に除外

2. **第 2 段階（パスワードによるマッピング）**:
   - パスワードと塩値から KDF でマップキーを生成
   - 各シェア ID に決定論的にマッピング値を生成
   - マッピング値でソート後、閾値分のシェアを選択

### 3. 暗号化バイナリファイルの処理

- **二重復号**: ファイル全体の暗号化を解除した後、内部データを処理
- **ファイル構造解析**: バイナリフォーマットを適切に解析して各セクションを抽出
- **認証検証**: 認証タグを検証してファイルの完全性を確保
- **UUID 検証**: ファイルに含まれる UUID を確認し、一意性を検証

## 主要関数の実装ガイド

### 1. バイナリファイルの復号と解析

```python
def decrypt_encrypted_file(encrypted_data, password):
    """
    暗号化されたバイナリファイルを復号

    Args:
        encrypted_data (bytes): 暗号化されたバイナリデータ
        password (str): 復号用パスワード

    Returns:
        tuple: (メタデータ, シェアデータ, ファイルUUID) または復号失敗時はNone
    """
    # 1. ファイルヘッダーを解析（UUID含む）
    # 2. パスワードからマスターキーを導出
    # 3. 認証付き暗号の検証と復号
    # 4. 復号されたデータからメタデータとシェアデータを抽出
```

### 2. 多段 MAP の実装

```python
def stage1_map(share_ids):
    """シェアIDによる第1段階MAP生成

    Args:
        share_ids: ユーザー入力のシェアIDセット

    Returns:
        シェアID候補セット
    """
    # シェアIDセットをセットとして返す（単純フィルタとして機能）
    return set(share_ids)

def stage2_map(password, candidate_ids, salt):
    """パスワードによる第2段階MAP生成

    Args:
        password: ユーザー入力のパスワード
        candidate_ids: 第1段階で限定されたシェアIDのセット
        salt: 暗号化時に生成された塩値

    Returns:
        シェアIDからマッピング値へのマップ辞書
    """
    # パスワードからKDFを用いてキーを導出
    # 各シェアIDに対するマッピング値をHMACで決定論的に生成
    # {share_id: mapping_value} 形式の辞書を返す
```

### 3. シェア選択と復元

```python
def select_shares(all_shares, share_ids, password, salt, threshold):
    """多段MAPを用いたシェア選択

    Args:
        all_shares: 全シェアリスト
        share_ids: ユーザー入力のシェアIDセット
        password: ユーザー入力のパスワード
        salt: 暗号化時に生成された塩値
        threshold: 閾値（必要シェア数）

    Returns:
        選択されたシェアのリスト
    """
    # 第1段階：シェアID空間の限定
    # 第2段階：パスワードによるマッピング
    # マッピング値でソート
    # 閾値分のシェアを選択（必ず同じ数を処理）
```

### 4. シャミア秘密分散法による復元

```python
def lagrange_interpolation(shares, p):
    """ラグランジュ補間によるシークレット復元

    Args:
        shares: (x, y)形式のシェアリスト
        p: 有限体の素数

    Returns:
        復元された秘密値
    """
    # ラグランジュ補間によるシークレット復元を実装
    # 有限体GF(p)上での計算に注意
```

### 5. 復号関数

```python
def decrypt(encrypted_data, share_ids, password):
    """暗号化ファイルの復号

    Args:
        encrypted_data (bytes): 暗号化されたバイナリデータ
        share_ids (list): ユーザー入力のシェアIDセット
        password (str): ユーザー入力のパスワード

    Returns:
        tuple: (dict, str) 復元されたJSON文書とファイルUUID、またはデコードに失敗した場合は(None, None)
    """
    # 1. 暗号化ファイルを復号してメタデータ、シェアデータ、UUIDを取得
    # 2. 多段MAPを用いたシェア選択
    # 3. 選択されたシェアを用いてチャンク別に秘密を復元
    # 4. 復元されたデータに多段デコードを適用
    # 5. JSONとして解析
    # 6. JSON文書とUUIDをタプルで返却
```

### 6. 多段デコードと復元処理

```python
def try_decrypt(all_shares, share_ids, password, salt, threshold, prime):
    """シェアを復号（A/B判定なしの直線的処理）

    Args:
        all_shares: 全シェアリスト
        share_ids: ユーザー入力のシェアIDセット
        password: ユーザー入力のパスワード
        salt: 暗号化時に生成された塩値
        threshold: 閾値（必要シェア数）
        prime: 有限体の素数

    Returns:
        bytes: 復元されたバイトデータ
    """
    # 多段MAPの適用
    # チャンク別にシェアを整理
    # 各チャンクの復元（条件分岐なしの直線的処理）
    # 復元データの結合

def decode_data(data):
    """多段デコード処理

    Args:
        data (bytes): 復元されたバイトデータ

    Returns:
        dict or None: デコードされたJSON文書または例外発生時はNone
    """
    # 1. 解凍（圧縮されている場合）
    # 2. Base64デコード
    # 3. Latin-1からUTF-8へのエンコード変換
    # 4. JSON解析
```

## 実装上の制約と注意点

### 1. 条件分岐の禁止と定数時間処理の実装

以下のパターンは条件分岐によるサイドチャネル攻撃を防止するために必須です。すべての条件分岐を含むコードパターンは**禁止**されます。

```python
# ⛔ 禁止: 条件分岐を使った選択
result = value_a if condition else value_b

# ✅ 推奨: ビット演算を用いた定数時間選択
mask = -(condition & 1)  # True -> -1 (all bits 1), False -> 0
result = (value_a & mask) | (value_b & ~mask)

# ⛔ 禁止: 早期リターンによる処理
for share in shares:
    if is_valid(share):
        return share

# ✅ 推奨: 全要素を処理しつつ条件を満たすものを記録
selected = None
for i, share in enumerate(shares):
    is_valid_share = is_valid(share)
    is_first_valid = is_valid_share and (selected is None)
    # ビット演算で条件分岐せずに選択
```

### 2. カナリア値の検証

カナリア値の検証は復号が正しく行われたことを確認するのに役立ちますが、検証自体が情報漏洩につながらないよう注意が必要です。

```python
def verify_canary(decrypted_data, expected_canary_pattern):
    """
    カナリア値を定数時間で検証

    Args:
        decrypted_data (bytes): 復号されたデータ
        expected_canary_pattern (bytes): 期待されるカナリアパターン

    Returns:
        bool: 検証結果（常に固定時間で実行）
    """
    # パターンの抽出
    # 定数時間での比較を実行
    # 結果を返却（タイミング攻撃を防ぐ）
```

### 3. エラーハンドリング

- **失敗の特定を避ける**: 復号に失敗したか成功したかを外部から判別させない
- **例外処理の統一**: 例外を投げる場合も定数時間で処理
- **エラー情報の最小化**: エラーメッセージによる情報漏洩を防止

### 4. パフォーマンスとメモリ使用

- **チャンク単位の処理**: メモリ効率を高めるため、チャンク単位で処理
- **予測可能なメモリアロケーション**: メモリ使用パターンが入力によって大きく変わらないよう設計
- **カタストロフィックバックトラッキング対策**: 正規表現処理などでバックトラッキングによる処理時間増大を防止

### 5. UUID の処理

- **自動命名**: 復号結果ファイルの保存時には元の暗号化ファイルの UUID を使用
- **UUID の検証**: ファイルの一意性を確認するため UUID を検証
- **衝突回避**: 同じ UUID のファイルが存在する場合は上書きを防止

## 復号成功・失敗の判定

復号結果の判定における重要なポイントは、成功・失敗の判定自体がタイミング攻撃につながる可能性があることです。

- **同一処理フローの維持**: 結果の正当性にかかわらず同じ処理を実行
- **条件分岐なしの結果返却**: 成功・失敗の判断基準を内部で持たない
- **エラー伝播の最小化**: 後続処理で JSON 解析失敗などが発生しても情報を漏洩させない

復号プロセスは常に同じステップを実行し、結果が正しい JSON かどうかの判断はこのモジュール外で行います。
# 更新モジュール実装ガイド

## 更新モジュールの目的

このモジュールは既存の高度に暗号化されたバイナリファイルに対して、特定のシェア ID セットとパスワードに対応する JSON 文書のみを更新します。更新処理は原子的に行われ、他の文書のシェアやメタデータに影響を与えません。

**重要**: 一度の更新操作で処理できるのは一つの文書のみです。複数の文書を同時に更新することは一切許可されていません。

## 主要な機能と要件

### 1. 更新プロセスの安全性確保

- **原子的更新**: 更新が完了するまで元のファイルが損なわれない
- **他文書の保護**: 更新対象でない文書部分（シェア）に影響を与えない
- **コンカレンシーハンドリング**: 複数プロセスによる同時更新を安全に処理
- **完全性検証**: 暗号化ファイルの完全性を常に検証し維持

### 2. 一時作業領域の管理

- **一時ファイルの確保**: 更新用の一時ファイルを別途生成し、UUID 付与で一意性確保
- **ロックファイルの管理**: 実行中プロセスを明示し、操作の衝突を防止
- **孤立リソースの検出と削除**: 完了・タイムアウトしたプロセスの一時ファイルを安全に削除
- **暗号化保護**: 一時ファイル自体も暗号化して保護

### 3. UUID の継承と検証

- **UUID の保持**: 更新後も元のファイルの UUID を維持
- **バックアップファイルの識別**: バックアップファイルには元の UUID に加えてタイムスタンプを付与
- **一時ファイルの一意性**: 一時ファイルには処理固有の UUID を付与

## 主要関数の実装ガイド

### 1. 更新関数の全体構造

```python
def update(encrypted_data, json_doc, password, share_ids):
    """
    暗号化バイナリファイルの特定文書部分を更新

    Args:
        encrypted_data (bytes): 既存の暗号化バイナリデータ
        json_doc (dict): 新しいJSON文書
        password (str): 文書に対応するパスワード
        share_ids (list): 文書に対応するシェアIDセット

    Returns:
        bytes: 更新された暗号化バイナリデータ（元のUUIDを維持）
    """
    # 1. 暗号化ファイルの復号と解析（UUIDを取得）
    # 2. 一時ファイルとロックファイルの生成（プロセス固有のUUID付与）
    # 3. 古い一時ファイルのクリーンアップ
    # 4. 新しいシェア生成
    # 5. 対象シェアIDの範囲内のシェアのみを更新
    # 6. 変更の検証
    # 7. 更新データを再暗号化（元のUUIDを維持）
    # 8. 一時ファイルとロックの解放
```

### 2. 一時ファイル管理

```python
def create_temp_resources(file_uuid, operation="update"):
    """
    更新用の一時リソースを作成

    Args:
        file_uuid (str): 元の暗号化ファイルのUUID
        operation (str): 操作種別("update"など)

    Returns:
        tuple: (process_uuid, temp_file_path, lock_file_path)のタプル
    """
    # プロセス固有UUIDの生成
    # 元ファイルUUIDとプロセスUUIDを含む一時ファイル名の生成
    # ロックファイルのパス生成
    # ロックファイル作成（PIDとタイムスタンプを記録）

def cleanup_stale_temp_files(directory, timeout_seconds=3600):
    """
    期限切れ/孤立した一時ファイルを削除

    Args:
        directory (str): 一時ファイルが格納されているディレクトリ
        timeout_seconds (int): プロセスがタイムアウトとみなされる秒数
    """
    # 現在時刻の取得
    # ロックファイルを検索
    # プロセスIDの存在確認
    # タイムスタンプ確認
    # 条件を満たす場合、関連ファイルを削除

def safe_remove_file(file_path):
    """
    ファイルを安全に削除（例外をキャッチして処理継続）

    Args:
        file_path (str): 削除するファイルのパス
    """
    # ファイルの存在確認
    # 安全な削除処理（例外をキャッチ）
```

### 3. バイナリファイル処理と更新

```python
def decrypt_and_extract(encrypted_data, password):
    """
    暗号化バイナリファイルを復号してメタデータとシェアを抽出

    Args:
        encrypted_data (bytes): 暗号化バイナリデータ
        password (str): 復号用パスワード

    Returns:
        tuple: (メタデータ, シェアデータ, ファイルUUID, ファイルヘッダ情報)
    """
    # ファイルヘッダを解析（UUIDを含む）
    # パスワードから鍵を導出
    # 認証と復号
    # データの抽出と返却

def generate_new_shares(json_doc, threshold, share_ids, prime):
    """
    新しいJSON文書からシェアを生成

    Args:
        json_doc (dict): 新しいJSON文書
        threshold (int): 閾値
        share_ids (list): 更新対象のシェアIDセット
        prime (int): 有限体の素数

    Returns:
        list: 生成されたシェアのリスト
    """
    # JSON文書のエンコード処理
    # チャンクに分割
    # 各チャンクをシェア化
    # シェアのリストを返却

def update_shares(all_shares, new_shares, share_ids):
    """
    シェアデータ内の特定シェアを更新

    Args:
        all_shares (list): 既存の全シェアリスト
        new_shares (list): 新しいシェアのリスト
        share_ids (list): 更新対象のシェアIDセット

    Returns:
        list: 更新された全シェアリスト
    """
    # 対象シェアIDの範囲内のシェアのみを更新
    # その他のシェアはそのまま保持
    # 更新されたシェアリストを返却

def encrypt_updated_data(metadata, updated_shares, file_uuid, file_header, password):
    """
    更新されたデータを暗号化

    Args:
        metadata (dict): メタデータ
        updated_shares (list): 更新されたシェアリスト
        file_uuid (str): 保持すべき元ファイルのUUID
        file_header (dict): 元ファイルのヘッダ情報
        password (str): 暗号化パスワード

    Returns:
        bytes: 暗号化されたバイナリデータ
    """
    # データの構造化
    # 元のUUIDを維持
    # パスワードから鍵を導出
    # 認証付き暗号化の適用
    # ヘッダ情報の追加
    # 暗号化データの返却
```

### 4. 例外処理と原子性確保

```python
def safe_update(encrypted_data, json_doc, password, share_ids):
    """
    例外処理と原子性を確保した更新処理

    Args:
        encrypted_data (bytes): 既存の暗号化バイナリデータ
        json_doc (dict): 新しいJSON文書
        password (str): 文書に対応するパスワード
        share_ids (list): 文書に対応するシェアIDセット

    Returns:
        bytes: 更新された暗号化バイナリデータ
    """
    # ファイルUUIDの取得
    # 一時リソースの確保（プロセス固有UUID付与）
    # try-exceptブロックで更新処理
    # 例外発生時も一時ファイルとロックを確実に解放
    # 成功時のみ更新を適用

def update_file(input_path, output_path, json_doc, password, share_ids, backup=True):
    """
    ファイルに対する更新処理

    Args:
        input_path (str): 入力ファイルパス
        output_path (str): 出力ファイルパス
        json_doc (dict): 新しいJSON文書
        password (str): 文書に対応するパスワード
        share_ids (list): 文書に対応するシェアIDセット
        backup (bool): 既存ファイルのバックアップを作成するか

    Returns:
        bool: 成功した場合はTrue
    """
    # 入力ファイル読み込み
    # ファイルUUIDの取得
    # 更新処理の実行
    # 原子的なファイル書き込み
    # バックアップ処理（元UUID＋タイムスタンプ形式）
```

## 実装上の制約と注意点

### 1. 並行実行の安全性

- **PID チェック**: プロセス ID の存在確認によるロックの有効性検証
- **タイムスタンプベースのタイムアウト**: 長時間実行プロセスの検出と処理
- **ロックファイル形式の標準化**: バイナリ形式のロック情報を構造化保存
- **ファイルロック**: OS レベルのファイルロック機構も併用

### 2. セキュリティ強化

- **一時ファイルの暗号化**: 更新中の一時データも強力に暗号化
- **メモリの消去**: 機密データ処理後のメモリを明示的に消去
- **認証タグの検証**: バイナリファイルの完全性を常に検証

### 3. エラー回復メカニズム

- **トランザクション的アプローチ**: 全ての更新が成功するか、全く変更が適用されないか
- **検証ステップ**: 変更適用前に新シェアが正しく復号可能か検証
- **ロールバック機能**: 問題が発生した場合に変更を取り消す処理
- **バックアップの自動保持**: 元ファイルのバックアップを確実に取得

### 4. 一時ファイルの管理ベストプラクティス

- **一意な名前空間**: プロセス UUID を用いた一時ファイル名の一意性確保
- **場所の固定**: アプリケーション固有の一時ディレクトリを使用
- **有効期限ポリシー**: 一定時間経過後の自動クリーンアップ
- **権限設定**: 安全なアクセス権設定による保護

### 5. リソースリークの防止

- **try-finally パターン**: 例外発生時もリソースを確実に解放
- **明示的なクリーンアップ**: 処理成功時も明示的に一時リソースを解放
- **定期的なスキャン**: アプリケーション起動時などに孤立リソースをチェック

### 6. UUID の取り扱い

- **UUID の検証**: 入力ファイルの UUID を必ず検証
- **UUID の保持**: 更新処理後も元の UUID を維持（変更しない）
- **命名規則の統一**: 一時ファイル名に含める UUID の形式を標準化
- **衝突回避**: UUID のランダム性を確保し、衝突確率を最小化

## 更新プロセスの全体フロー

```
暗号化ファイルの復号と解析（UUID取得）
↓
一時作業領域の確保（プロセス固有UUID付与）
↓
古い一時ファイルのクリーンアップ
↓
新シェアの生成
↓
一時ファイルに中間状態を保存（暗号化）
↓
対象シェアIDの範囲内のシェアのみを更新
↓
メタデータの更新（元のUUID維持）
↓
更新データの再暗号化
↓
暗号化ファイルの書き込み（原子的操作）
↓
一時ファイルとロックファイルの安全な削除
```

## パフォーマンスとスケーラビリティ

更新処理のパフォーマンスとスケーラビリティを確保するための指針：

1. **インクリメンタル処理**: 大きなファイルでもメモリ効率よく処理
2. **シェア選択の最適化**: 更新対象シェアの効率的な選択アルゴリズム
3. **ロックの粒度**: 必要最小限の範囲のみロック
4. **バックグラウンド処理**: 長時間実行が予想される場合の非同期処理
5. **選択的再暗号化**: 変更された部分のみを再暗号化して効率化

```

```
# CLI インターフェース実装ガイド

## CLI の目的

この CLI インターフェースは、シャミア秘密分散法による複数平文復号システムの 4 つの主要機能（初期化・暗号化・復号・更新）を利用しやすくするためのコマンドラインツールです。セキュリティを確保しつつ、ユーザーフレンドリーな操作性を提供します。

**重要な制約**: 暗号化および更新処理は必ず一つの文書ずつ行い、複数文書の同時処理は行いません。

## コマンド設計

### 1. ヘルプとサブコマンド構造

ツールは以下のサブコマンドを持ちます：

```
shamir-multi-crypt [グローバルオプション] <サブコマンド> [サブコマンドオプション]

サブコマンド:
  - initialize : システムを初期化し、シェアID空間を分割
  - encrypt    : 新規暗号化ファイルを作成し、JSON文書を暗号化
  - decrypt    : 暗号化ファイルから特定のJSON文書を復号
  - update     : 暗号化ファイル内の特定文書を更新
  - generate   : シェアIDセットを生成
  - help       : ヘルプを表示
```

### 2. 主要コマンドの詳細

#### 2.1. 初期化コマンド

```
shamir-multi-crypt initialize --size <シェア数> --ratio <比率> --output-a <Aシェアファイル> --output-b <Bシェアファイル>

オプション:
  --size, -s       : 生成するシェアIDの総数 (デフォルト: 100)
  --ratio, -r      : A:B:未割当の比率 (デフォルト: "35:35:30")
  --output-a       : A用シェアの出力ファイル名 (デフォルト: shares-a-{uuid}.bin)
  --output-b       : B用シェアの出力ファイル名 (デフォルト: shares-b-{uuid}.bin)
  --password-a     : A用シェアファイルのパスワード（指定しない場合はプロンプト）
  --password-b     : B用シェアファイルのパスワード（指定しない場合はプロンプト）
```

このコマンドは以下の処理を行います：

- 指定数のシェア ID を生成
- 比率に基づいて A 用、B 用、未割当に分類
- A 用と B 用のシェアを別々の高度に暗号化されたバイナリファイルに保存
- AB を俯瞰できるマスターデータは出力しない
- 各ファイルに一意の UUID を付与して重複を防止

#### 2.2. シェア ID 生成コマンド

```
shamir-multi-crypt generate --size <シェア数> --output <ファイル名>

オプション:
  --size, -s      : 生成するシェアIDの数 (デフォルト: 100)
  --output, -o    : 出力ファイル名 (デフォルト: shares-{uuid}.bin)
  --ratio, -r     : A:B:未割当の比率 (デフォルト: "35:35:30")
  --password, -p  : 出力ファイルを暗号化するパスワード（指定しない場合はプロンプト）
```

このコマンドは以下の処理を行います：

- 指定数のシェア ID を生成
- 比率に基づいて A 用、B 用、未割当に分類
- 高度に暗号化されたバイナリファイルに保存
- ファイルに一意の UUID を付与

#### 2.3. 暗号化コマンド

```
shamir-multi-crypt encrypt --file <JSONファイル> --shares <シェアIDファイル> --output <暗号化ファイル> --type <タイプ>

オプション:
  --file, -f      : 暗号化するJSON文書ファイルパス
  --shares, -s    : 文書用のシェアIDリストファイル
  --output, -o    : 出力暗号化ファイル名 (デフォルト: encrypted-{uuid}.bin)
  --type, -t      : 文書タイプ（"a"または"b"）
  --threshold     : 閾値（デフォルト: 3）
  --password, -p  : 暗号化に使用するパスワード（指定しない場合はプロンプト）
  --shares-password: シェアファイルのパスワード（指定しない場合はプロンプト）
```

**注意**: このコマンドは一度に一つの文書のみを処理します。両方の文書を同時に暗号化することはできません。

このコマンドは以下の処理を行います：

- 単一の JSON 文書を読み込み
- 暗号化されたシェア ID ファイルを復号して読み込み
- パスワードをプロンプト（指定されていない場合）
- 暗号化処理を実行し、指定された出力パスに高度に暗号化されたバイナリファイルとして保存
- 出力ファイルに一意の UUID を付与

#### 2.4. 復号コマンド

```
shamir-multi-crypt decrypt --input <暗号化ファイル> --shares <シェアIDファイル> --output <出力JSONファイル>

オプション:
  --input, -i     : 暗号化ファイルパス
  --shares, -s    : シェアIDリストファイル
  --output, -o    : 出力JSONファイル名（デフォルト: decrypted-{uuid}.json）
  --password, -p  : 暗号化ファイルのパスワード（指定しない場合はプロンプト）
  --shares-password: シェアファイルのパスワード（指定しない場合はプロンプト）
```

このコマンドは以下の処理を行います：

- 暗号化バイナリファイルとシェア ID ファイルを読み込み
- パスワードをプロンプト（指定されていない場合）
- 復号処理を実行し、指定された出力パスに JSON を保存
- 出力ファイル名に元の暗号化ファイルの UUID を含める

#### 2.5. 更新コマンド

```
shamir-multi-crypt update --input <暗号化ファイル> --file <新JSONファイル> --shares <シェアIDファイル> --output <更新後ファイル>

オプション:
  --input, -i     : 元の暗号化ファイルパス
  --file, -f      : 新しいJSON文書ファイル
  --shares, -s    : シェアIDリストファイル
  --output, -o    : 更新後の暗号化ファイル名（デフォルト: 上書き）
  --password, -p  : 暗号化ファイルのパスワード（指定しない場合はプロンプト）
  --shares-password: シェアファイルのパスワード（指定しない場合はプロンプト）
  --backup, -b    : 元ファイルのバックアップを作成（デフォルト: true）
```

このコマンドは以下の処理を行います：

- 元の暗号化ファイル、新しい JSON 文書、シェア ID ファイルを読み込み
- パスワードをプロンプト（指定されていない場合）
- 必要に応じて元ファイルのバックアップを作成（UUID ＋タイムスタンプ形式）
- 更新処理を実行し、結果を保存
- 元の UUID を維持して更新ファイルを生成

### 3. グローバルオプション

全コマンド共通のオプション：

```
--verbose, -v   : 詳細なログ出力を有効化
--quiet, -q     : 出力を最小限に抑える
--log-file      : ログの出力先ファイル
--help, -h      : ヘルプを表示
--version       : バージョン情報を表示
```

## 実装ガイドライン

### 1. パスワード入力の安全な処理

```python
def prompt_password(prompt_text="パスワードを入力してください: "):
    """
    パスワードを安全にプロンプト

    Args:
        prompt_text: プロンプト表示テキスト

    Returns:
        入力されたパスワード
    """
    # getpassモジュールを使用して画面に表示せずにパスワード入力
    import getpass
    return getpass.getpass(prompt_text)
```

### 2. 暗号化ファイルの処理

```python
def read_encrypted_file(file_path, password=None):
    """
    暗号化バイナリファイルを読み込み

    Args:
        file_path: 暗号化ファイルのパス
        password: パスワード（Noneの場合はプロンプト）

    Returns:
        tuple: (復号されたデータ, ファイルUUID)
    """
    # ファイル読み込み
    # パスワードが必要ならプロンプト
    # ファイルヘッダを解析（UUID含む）
    # 復号と返却
```

### 3. シェア ID リストの処理

```python
def load_share_ids(share_file, password=None):
    """
    暗号化されたシェアIDリストファイルを読み込み

    Args:
        share_file: シェアIDリストの暗号化バイナリファイルパス
        password: パスワード（Noneの場合はプロンプト）

    Returns:
        tuple: (シェアIDのリスト, ファイルUUID)
    """
    # ファイル読み込み
    # パスワードが必要ならプロンプト
    # 復号と解析
    # シェアIDのリストとUUIDを返却
```

### 4. ファイル処理の安全性確保

```python
def safe_write_file(data, output_path, uuid=None, backup=False, binary=True):
    """
    ファイルの安全な書き込み

    Args:
        data: 書き込むデータ
        output_path: 出力先パス
        uuid: ファイルUUID（Noneの場合は新規生成）
        backup: 既存ファイルのバックアップを作成するか
        binary: バイナリモードで書き込むか

    Returns:
        str: 書き込まれたファイルのUUID
    """
    # UUIDが指定されていなければ新規生成
    # バックアップが有効な場合、既存ファイルをUUID+タイムスタンプ形式でバックアップ
    # 一時ファイルに書き込み
    # 書き込み成功後、目的のパスに移動/リネーム
    # 使用したUUIDを返却
```

### 5. 初期化コマンド実装

```python
def initialize_command(args):
    """initialize サブコマンドの実装"""
    # 引数の検証
    # シェアID空間の生成
    # A/B/未割当シェアに分割
    # A用シェアをUUID付きで暗号化して保存
    # B用シェアをUUID付きで暗号化して保存
    # 成功メッセージの表示
```

### 6. メイン CLI 関数

```python
def main():
    """CLI エントリーポイント"""
    # コマンドライン引数のパース
    # サブコマンドに応じた処理の分岐
    # エラーハンドリングと適切なステータスコードでの終了
```

### 7. 暗号化コマンド実装例

```python
def encrypt_command(args):
    """encrypt サブコマンドの実装"""
    # 引数の検証
    # --file が指定されていることを確認
    # --type が "a" または "b" であることを確認
    # JSON文書の読み込み（単一文書のみ処理可能）
    # シェアIDファイルの読み込み
    # パスワードプロンプト（必要な場合）
    # UUIDの生成と保存（ファイル名の一部として使用）
    # 暗号化モジュールの呼び出し（単一文書のみ処理）
    # 結果の保存（UUIDを含むファイル名で）
    # 成功メッセージの表示
```

## セキュリティ上の注意点

### 1. パスワード取り扱い

- **メモリ保持の最小化**: パスワードはメモリ上に保持する時間を最小限に
- **環境変数の禁止**: パスワードを環境変数に保存しない
- **ヒストリー対策**: コマンドラインオプションより対話的入力を優先
- **安全なプロンプト**: `getpass`モジュールなどを使用して画面に表示しない

### 2. バイナリファイルのセキュリティ

- **認証暗号化**: AEAD モード（GCM, ChaCha20-Poly1305 など）を使用
- **鍵導出関数**: パスワードからの鍵導出には Argon2 や PBKDF2 を使用
- **ファイルフォーマット**: バージョン、UUID、ソルト、ノンスなどのメタデータを含むヘッダ形式を採用
- **ファイル完全性**: 認証タグでデータ改ざんを検出

### 3. エラーメッセージと情報漏洩

- **汎用エラーメッセージ**: エラーの詳細が機密情報を漏らさないよう注意
- **常に一定時間実行**: 無効なパスワードなどでも処理時間が変わらないよう考慮
- **同一失敗メッセージ**: 異なる失敗原因でも同じメッセージを表示

### 4. ファイル処理

- **アトミック操作**: ファイル更新は常にアトミックに行う
- **一時ファイルの保護**: 適切なパーミッションでの一時ファイル作成
- **残留データの防止**: 処理完了後に一時ファイルやメモリを適切にクリーンアップ
- **UUID による識別**: 全てのファイルに UUID を付与して一意性を確保

## ユーザービリティ

### 1. プログレス表示

```python
def show_progress(current, total, prefix='', suffix='', bar_length=50):
    """
    プログレスバーを表示

    Args:
        current: 現在の進捗
        total: 全体量
        prefix: プレフィックステキスト
        suffix: サフィックステキスト
        bar_length: バーの長さ
    """
    # プログレスバー表示ロジック
```

### 2. 色付き出力

```python
class Colors:
    """ANSI カラーコード"""
    HEADER = '\033[95m'
    BLUE = '\033[94m'
    GREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'

def colorize(text, color):
    """テキストに色を付ける"""
    return f"{color}{text}{Colors.ENDC}"
```

### 3. ヘルプメッセージ

明確で詳細なヘルプメッセージを各コマンドに提供します：

```python
# コマンドの説明例
initialize_parser = subparsers.add_parser(
    'initialize',
    help='システムを初期化し、シェアID空間を分割',
    description='システムを初期化し、シェアID空間をA用、B用、未割当に分割します。'
             'A用とB用のシェアIDは別々の暗号化ファイルに保存され、マスターデータは出力されません。'
             '各ファイルにはUUIDが付与され、重複による上書きを防止します。'
)

encrypt_parser = subparsers.add_parser(
    'encrypt',
    help='新規暗号化ファイルを作成し、JSON文書を暗号化',
    description='一つのJSON文書とシェアIDセットを用いて暗号化ファイルを生成します。'
             '生成されたファイルは該当するパスワードとシェアIDセットで復号可能です。'
             '重要: このコマンドは一度に一つの文書のみを処理します。'
)
```

### 4. エラー処理とフィードバック

```python
def handle_error(error, verbose=False):
    """
    エラーを適切に処理して表示

    Args:
        error: 発生したエラー/例外
        verbose: 詳細表示モードか
    """
    # エラータイプに応じた処理
    # verboseモードの場合は詳細表示
    # 適切なエラーコードで終了
```

### 5. UUID 関連のヘルパー関数

```python
def generate_uuid():
    """新しいUUIDを生成"""
    import uuid
    return str(uuid.uuid4())

def make_filename_with_uuid(base_name, extension, uuid_str=None):
    """UUIDを含むファイル名を生成"""
    if uuid_str is None:
        uuid_str = generate_uuid()
    return f"{base_name}-{uuid_str}.{extension}"
```

## リリースとパッケージング

### 1. バージョン管理

```python
__version__ = '1.0.0'

def show_version():
    """バージョン情報を表示"""
    print(f"shamir-multi-crypt version {__version__}")
    print("シャミア秘密分散法による複数平文復号システム")
```

### 2. エントリーポイント定義

`setup.py` または `pyproject.toml` でのエントリーポイント定義：

```python
# setup.py の例
setup(
    # ...その他の設定...
    entry_points={
        'console_scripts': [
            'shamir-multi-crypt=shamir_multi_crypt.cli:main',
        ],
    },
)
```

---

## 実装の追加指示

1. このシステムは情報理論的安全性を持つよう設計されています。すべての実装においてこの原則に忠実であることが最重要です。
2. タイミング攻撃を防ぐため、条件分岐の禁止と定数時間処理は絶対に守ってください。
3. 暗号処理において、設計書にあるアルゴリズムから逸脱しないでください。
4. 「正しいパスワードによる復号」に見せかけたバックドアを仕掛けないでください。
5. 「統計的区別不可能性」を確保するためのA/B/未割当シェア分布を維持してください。
6. シェアデータは必ず高度に暗号化されたバイナリファイルとして出力し、平文のJSONは使用しないでください。
7. 初期化時にはABを俯瞰できるマスターデータは絶対に出力せず、A用、B用のシェアを別々に出力してください。

実装を開始してください。モジュール分割と正しいインポート関係を考慮したファイル構成から検討することをお勧めします。

備考：このシステムの主要な技術的特徴（多段MAP方式とシャミアベースの多重復号）は、研究目的での実装です。

制約条件：すべての原則を守りつつ実現できない場合は、何が達成できて何が難しいかを説明してください。
その際、セキュリティの実現が最優先です。機能を制限してでもセキュリティ原則を守ってください。

実装完了後は、コードの概要と使用方法を簡潔に説明してください。
