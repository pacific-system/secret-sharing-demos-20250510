# CLI インターフェース実装ガイド

## CLI の目的

この CLI インターフェースは、シャミア秘密分散法による複数平文復号システムの 4 つの主要機能（初期化・暗号化・復号・更新）を利用しやすくするためのコマンドラインツールです。セキュリティを確保しつつ、ユーザーフレンドリーな操作性を提供します。

**重要な制約**: 暗号化および更新処理は必ず一つの文書ずつ行い、複数文書の同時処理は行いません。

## コマンド設計

### 1. ヘルプとサブコマンド構造

ツールは以下のサブコマンドを持ちます：

```
shamir-multi-crypt [グローバルオプション] <サブコマンド> [サブコマンドオプション]

サブコマンド:
  - initialize : システムを初期化し、シェアトークン空間を分割
  - encrypt    : 新規暗号化ファイルを作成し、JSON文書を暗号化
  - decrypt    : 暗号化ファイルから特定のJSON文書を復号
  - update     : 暗号化ファイル内の特定文書を更新
  - generate   : シェアトークンを生成
  - help       : ヘルプを表示
```

### 2. 主要コマンドの詳細

#### 2.1. 初期化コマンド

```
shamir-multi-crypt initialize --size <シェア数> --ratio <比率> --output-a <Aシェアファイル> --output-b <Bシェアファイル>

オプション:
  --size, -s       : 生成するシェアトークンの総数 (デフォルト: 100)
  --ratio, -r      : A:B:未割当の比率 (デフォルト: "35:35:30")
  --output-a       : A用シェアトークンの出力ファイル名 (デフォルト: shares-a-{uuid}.bin)
  --output-b       : B用シェアトークンの出力ファイル名 (デフォルト: shares-b-{uuid}.bin)
  --password-a     : A用シェアファイルのパスワード（指定しない場合はプロンプト）
  --password-b     : B用シェアファイルのパスワード（指定しない場合はプロンプト）
```

このコマンドは以下の処理を行います：

- 指定数のシェアトークンを生成
- 比率に基づいて A 用、B 用、未割当に分類
- A 用と B 用のシェアトークンを別々の高度に暗号化されたバイナリファイルに保存
- AB を俯瞰できるマスターデータは出力しない
- 各ファイルに一意の UUID を付与して重複を防止

#### 2.2. シェアトークン生成コマンド

```
shamir-multi-crypt generate --size <シェア数> --output <ファイル名>

オプション:
  --size, -s      : 生成するシェアトークンの数 (デフォルト: 100)
  --output, -o    : 出力ファイル名 (デフォルト: shares-{uuid}.bin)
  --ratio, -r     : A:B:未割当の比率 (デフォルト: "35:35:30")
  --password, -p  : 出力ファイルを暗号化するパスワード（指定しない場合はプロンプト）
```

このコマンドは以下の処理を行います：

- 指定数のシェアトークンを生成
- 比率に基づいて A 用、B 用、未割当に分類
- 高度に暗号化されたバイナリファイルに保存
- ファイルに一意の UUID を付与

#### 2.3. 暗号化コマンド

```
shamir-multi-crypt encrypt --file <JSONファイル> --token <シェアトークン> --output <暗号化ファイル> --type <タイプ>

オプション:
  --file, -f      : 暗号化するJSON文書ファイルパス
  --token, -t     : 文書用のシェアトークン
  --output, -o    : 出力暗号化ファイル名 (デフォルト: encrypted-{uuid}.bin)
  --type, -y      : 文書タイプ（"a"または"b"）
  --threshold     : 閾値（デフォルト: 3）
  --password, -p  : 暗号化に使用するパスワード（指定しない場合はプロンプト）
  --token-password: シェアトークンファイルのパスワード（指定しない場合はプロンプト）
```

**注意**: このコマンドは一度に一つの文書のみを処理します。両方の文書を同時に暗号化することはできません。

このコマンドは以下の処理を行います：

- 単一の JSON 文書を読み込み
- 暗号化されたシェアトークンファイルを復号して読み込み
- パスワードをプロンプト（指定されていない場合）
- 暗号化処理を実行し、指定された出力パスに高度に暗号化されたバイナリファイルとして保存
- 出力ファイルに一意の UUID を付与

#### 2.4. 復号コマンド

```
shamir-multi-crypt decrypt --input <暗号化ファイル> --token <シェアトークン> --output <出力JSONファイル>

オプション:
  --input, -i     : 暗号化ファイルパス
  --token, -t     : シェアトークン
  --output, -o    : 出力JSONファイル名（デフォルト: decrypted-{uuid}.json）
  --password, -p  : 暗号化ファイルのパスワード（指定しない場合はプロンプト）
  --token-password: シェアトークンファイルのパスワード（指定しない場合はプロンプト）
```

このコマンドは以下の処理を行います：

- 暗号化バイナリファイルとシェアトークンファイルを読み込み
- パスワードをプロンプト（指定されていない場合）
- 復号処理を実行し、指定された出力パスに JSON を保存
- 出力ファイル名に元の暗号化ファイルの UUID を含める

#### 2.5. 更新コマンド

```
shamir-multi-crypt update --input <暗号化ファイル> --file <新JSONファイル> --token <シェアトークン> --output <更新後ファイル>

オプション:
  --input, -i     : 元の暗号化ファイルパス
  --file, -f      : 新しいJSON文書ファイル
  --token, -t     : シェアトークン
  --output, -o    : 更新後の暗号化ファイル名（デフォルト: 上書き）
  --password, -p  : 暗号化ファイルのパスワード（指定しない場合はプロンプト）
  --token-password: シェアトークンファイルのパスワード（指定しない場合はプロンプト）
  --backup, -b    : 元ファイルのバックアップを作成（デフォルト: true）
```

このコマンドは以下の処理を行います：

- 元の暗号化ファイル、新しい JSON 文書、シェアトークンファイルを読み込み
- パスワードをプロンプト（指定されていない場合）
- 必要に応じて元ファイルのバックアップを作成（UUID ＋タイムスタンプ形式）
- 更新処理を実行し、結果を保存
- 元の UUID を維持して更新ファイルを生成

### 3. グローバルオプション

全コマンド共通のオプション：

```
--verbose, -v   : 詳細なログ出力を有効化
--quiet, -q     : 出力を最小限に抑える
--log-file      : ログの出力先ファイル
--help, -h      : ヘルプを表示
--version       : バージョン情報を表示
```

## 実装ガイドライン

### 1. パスワード入力の安全な処理

```python
def prompt_password(prompt_text="パスワードを入力してください: "):
    """
    パスワードを安全にプロンプト

    Args:
        prompt_text: プロンプト表示テキスト

    Returns:
        入力されたパスワード
    """
    # getpassモジュールを使用して画面に表示せずにパスワード入力
    import getpass
    return getpass.getpass(prompt_text)
```

### 2. 暗号化ファイルの処理

```python
def read_encrypted_file(file_path, password=None):
    """
    暗号化バイナリファイルを読み込み

    Args:
        file_path: 暗号化ファイルのパス
        password: パスワード（Noneの場合はプロンプト）

    Returns:
        tuple: (復号されたデータ, ファイルUUID)
    """
    # ファイル読み込み
    # パスワードが必要ならプロンプト
    # ファイルヘッダを解析（UUID含む）
    # 復号と返却
```

### 3. シェアトークンの処理

```python
def load_share_token(token_file, password=None):
    """
    暗号化されたシェアトークンファイルを読み込み

    Args:
        token_file: シェアトークンファイルパス
        password: パスワード（Noneの場合はプロンプト）

    Returns:
        tuple: (シェアトークン, ファイルUUID)
    """
    # ファイル読み込み
    # パスワードが必要ならプロンプト
    # 復号と解析
    # シェアトークンとUUIDを返却
```

### 4. ファイル処理の安全性確保

```python
def safe_write_file(data, output_path, uuid=None, backup=False, binary=True):
    """
    ファイルの安全な書き込み

    Args:
        data: 書き込むデータ
        output_path: 出力先パス
        uuid: ファイルUUID（Noneの場合は新規生成）
        backup: 既存ファイルのバックアップを作成するか
        binary: バイナリモードで書き込むか

    Returns:
        str: 書き込まれたファイルのUUID
    """
    # UUIDが指定されていなければ新規生成
    # バックアップが有効な場合、既存ファイルをUUID+タイムスタンプ形式でバックアップ
    # 一時ファイルに書き込み
    # 書き込み成功後、目的のパスに移動/リネーム
    # 使用したUUIDを返却
```

### 5. 初期化コマンド実装

```python
def initialize_command(args):
    """initialize サブコマンドの実装"""
    # 引数の検証
    # シェアトークン空間の生成
    # A/B/未割当シェアに分割
    # A用シェアトークンをUUID付きで暗号化して保存
    # B用シェアトークンをUUID付きで暗号化して保存
    # 成功メッセージの表示
```

### 6. メイン CLI 関数

```python
def main():
    """CLI エントリーポイント"""
    # コマンドライン引数のパース
    # サブコマンドに応じた処理の分岐
    # エラーハンドリングと適切なステータスコードでの終了
```

### 7. 暗号化コマンド実装例

```python
def encrypt_command(args):
    """encrypt サブコマンドの実装"""
    # 引数の検証
    # --file が指定されていることを確認
    # --type が "a" または "b" であることを確認
    # JSON文書の読み込み（単一文書のみ処理可能）
    # シェアトークンファイルの読み込み
    # パスワードプロンプト（必要な場合）
    # UUIDの生成と保存（ファイル名の一部として使用）
    # 暗号化モジュールの呼び出し（単一文書のみ処理）
    # 結果の保存（UUIDを含むファイル名で）
    # 成功メッセージの表示
```

## セキュリティ上の注意点

### 1. パスワード取り扱い

- **メモリ保持の最小化**: パスワードはメモリ上に保持する時間を最小限に
- **環境変数の禁止**: パスワードを環境変数に保存しない
- **ヒストリー対策**: コマンドラインオプションより対話的入力を優先
- **安全なプロンプト**: `getpass`モジュールなどを使用して画面に表示しない

### 2. バイナリファイルのセキュリティ

- **認証暗号化**: AEAD モード（GCM, ChaCha20-Poly1305 など）を使用
- **鍵導出関数**: パスワードからの鍵導出には Argon2 や PBKDF2 を使用
- **ファイルフォーマット**: バージョン、UUID、ソルト、ノンスなどのメタデータを含むヘッダ形式を採用
- **ファイル完全性**: 認証タグでデータ改ざんを検出

### 3. エラーメッセージと情報漏洩

- **汎用エラーメッセージ**: エラーの詳細が機密情報を漏らさないよう注意
- **常に一定時間実行**: 無効なパスワードなどでも処理時間が変わらないよう考慮
- **同一失敗メッセージ**: 異なる失敗原因でも同じメッセージを表示

### 4. ファイル処理

- **アトミック操作**: ファイル更新は常にアトミックに行う
- **一時ファイルの保護**: 適切なパーミッションでの一時ファイル作成
- **残留データの防止**: 処理完了後に一時ファイルやメモリを適切にクリーンアップ
- **UUID による識別**: 全てのファイルに UUID を付与して一意性を確保

## ユーザービリティ

### 1. プログレス表示

```python
def show_progress(current, total, prefix='', suffix='', bar_length=50):
    """
    プログレスバーを表示

    Args:
        current: 現在の進捗
        total: 全体量
        prefix: プレフィックステキスト
        suffix: サフィックステキスト
        bar_length: バーの長さ
    """
    # プログレスバー表示ロジック
```

### 2. 色付き出力

```python
class Colors:
    """ANSI カラーコード"""
    HEADER = '\033[95m'
    BLUE = '\033[94m'
    GREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'

def colorize(text, color):
    """テキストに色を付ける"""
    return f"{color}{text}{Colors.ENDC}"
```

### 3. ヘルプメッセージ

明確で詳細なヘルプメッセージを各コマンドに提供します：

```python
# コマンドの説明例
initialize_parser = subparsers.add_parser(
    'initialize',
    help='システムを初期化し、シェアトークン空間を分割',
    description='システムを初期化し、シェアトークン空間をA用、B用、未割当に分割します。'
             'A用とB用のシェアトークンは別々の暗号化ファイルに保存され、マスターデータは出力されません。'
             '各ファイルにはUUIDが付与され、重複による上書きを防止します。'
)

encrypt_parser = subparsers.add_parser(
    'encrypt',
    help='新規暗号化ファイルを作成し、JSON文書を暗号化',
    description='一つのJSON文書とシェアトークンを用いて暗号化ファイルを生成します。'
             '生成されたファイルは該当するパスワードとシェアトークンで復号可能です。'
             '重要: このコマンドは一度に一つの文書のみを処理します。'
)
```

### 4. エラー処理とフィードバック

```python
def handle_error(error, verbose=False):
    """
    エラーを適切に処理して表示

    Args:
        error: 発生したエラー/例外
        verbose: 詳細表示モードか
    """
    # エラータイプに応じた処理
    # verboseモードの場合は詳細表示
    # 適切なエラーコードで終了
```

### 5. UUID 関連のヘルパー関数

```python
def generate_uuid():
    """新しいUUIDを生成"""
    import uuid
    return str(uuid.uuid4())

def make_filename_with_uuid(base_name, extension, uuid_str=None):
    """UUIDを含むファイル名を生成"""
    if uuid_str is None:
        uuid_str = generate_uuid()
    return f"{base_name}-{uuid_str}.{extension}"
```

## リリースとパッケージング

### 1. バージョン管理

```python
__version__ = '1.0.0'

def show_version():
    """バージョン情報を表示"""
    print(f"shamir-multi-crypt version {__version__}")
    print("シャミア秘密分散法による複数平文復号システム")
```

### 2. エントリーポイント定義

`setup.py` または `pyproject.toml` でのエントリーポイント定義：

```python
# setup.py の例
setup(
    # ...その他の設定...
    entry_points={
        'console_scripts': [
            'shamir-multi-crypt=shamir_multi_crypt.cli:main',
        ],
    },
)
```
