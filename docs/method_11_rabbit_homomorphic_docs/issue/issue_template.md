# 📝 キャッシュ攻撃対策実装指示書（T32） - ラビット＋準同型マスキング暗号プロセッサ 🔐

> **ドキュメント種別: 実装指示書**

## 🌟 タスク進捗状況

タスク実装フェーズの進捗:

- ✅ **フェーズ 1**: 基盤ユーティリティ実装 [**完了**]
- 🔄 **フェーズ 2**: セキュリティ対策基盤実装 [**現在作業中**]
- ⏳ **フェーズ 3**: 三暗号方式コア実装 [予定]
- ⏳ **フェーズ 4**: 融合機能と変換システム実装 [予定]
- ⏳ **フェーズ 5**: データ形式とインターフェース実装 [予定]
- ⏳ **フェーズ 6**: 検証とパフォーマンス最適化 [予定]

### 📋 現在の実装フェーズ: `フェーズ2: セキュリティ対策基盤実装`

**現在のタスク**: T32（キャッシュ攻撃対策実装）
**進捗状況**: T1-T31 完了 → **T32 実装中** → T33-T115 未着手

**注**: 各タスクは独立して実装・完了させてください。

### 🎯 タスク範囲（T32: キャッシュ攻撃対策実装）

**実装すべきもの**:

- ✅ `cache_attack.py`のみ
- ✅ 関連するテスト

**実装してはいけないもの**:

- ❌ `power_analysis.py`（次のタスク T33）
- ❌ 他の防御機能（T33 以降のタスク）

**実装がベストプラクティスに反する可能性がある場合**: 作業を即時停止し、問題を報告してください。

## 📝 課題の詳細

### 🎯 タスク概要

<!-- ここにタスクの概要を記載 -->

本タスク（T32）ではキャッシュ攻撃対策のみを実装します。キャッシュタイミング攻撃から情報漏洩を防止する機能を構築し、第二回暗号解読キャンペーンで発見された脆弱性に対処します。次のタスク（T33）で実装予定の電力解析対策は含みません。

**本タスク（T32）の作業カウント**:

- 📝 **実装作業**: 10 件

  - キャッシュプリロード機能: 3 関数
  - アクセスパターン均一化機能: 4 関数
  - キャッシュフラッシュ制御機能: 3 関数

- 🧪 **テスト作業**: 4 件

  - キャッシュプリロード機能テスト
  - アクセスパターン均一化機能テスト
  - キャッシュフラッシュ制御機能テスト
  - 統合テスト（全機能連携）

- ✅ **完了条件**: 25 項目
  - 実装完了条件: 5 項目
  - 機能完了条件: 5 項目
  - テスト完了条件: 5 項目
  - ドキュメント完了条件: 5 項目
  - 納品物件検証条件: 5 項目

### 🔍 背景と目的

<!-- このタスクの背景と目的を記載 -->

相補文書推測攻撃など高度な攻撃に対する完全な耐性を確保するため、キャッシュタイミングや電力消費パターンからの情報漏洩を防止する機能を実装します。これにより、物理的サイドチャネルを通じた鍵情報や経路情報の漏洩を防止します。

### 📊 要件仕様

<!-- 詳細な要件、受け入れ基準などを記載 -->

1. キャッシュアクセスパターンを均一化し、タイミング攻撃を防止すること
2. 電力消費パターンを均一化し、電力解析攻撃を防止すること
3. すべての処理で定時間実行を保証すること
4. メモリアクセスパターンを秘匿すること
5. キャッシュから経路情報が漏洩しないこと
6. 物理的観測による実行経路推測が不可能であること

### 🛠️ 実装内容概要

キャッシュ攻撃対策として、以下の 3 つの主要機能を実装します：

1. **キャッシュプリロード機能**: 実行前にキャッシュを均一化し、アクセスパターン漏洩を防止
2. **アクセスパターン均一化機能**: 条件分岐に依存しないメモリアクセスを実現
3. **キャッシュフラッシュ制御機能**: 機密処理後の安全なキャッシュクリーンアップ

### 📋 実装内容詳細

#### 1. キャッシュプリロード機能（3 つの関数）

```python
def preload_memory_blocks(memory_blocks: List[MemoryBlock], access_pattern: AccessPattern) -> None:
    """
    処理開始前に全メモリブロックをキャッシュにプリロードし、キャッシュミスパターンを均一化する

    Args:
        memory_blocks: プリロードするメモリブロックのリスト
        access_pattern: 均一化するアクセスパターン定義

    Returns:
        None

    実装詳細:
    1. 渡された全メモリブロックを事前にキャッシュに読み込む
    2. 読み込み順序はアクセスパターンに依存しない固定順序とする
    3. 実際のアクセスパターンに関係なく、すべてのブロックが初回アクセス時にキャッシュヒットするよう保証
    """
    pass


def create_dummy_access_sequence(real_sequence: List[int], total_blocks: int) -> List[int]:
    """
    実アクセスシーケンスからダミーアクセスを含む完全なシーケンスを生成

    Args:
        real_sequence: 実際に必要なメモリブロックのインデックスリスト
        total_blocks: 全メモリブロック数

    Returns:
        実アクセスとダミーアクセスを含む完全なアクセスシーケンス

    実装詳細:
    1. すべてのメモリブロックを一度ずつアクセスする完全なシーケンスを生成
    2. アクセス順序は、実アクセスとダミーアクセスの区別が不可能な均一分布に従う
    3. 量子乱数生成器を使用して、予測不可能なアクセスパターンを実現
    """
    pass


def execute_uniform_access(blocks: List[MemoryBlock], access_sequence: List[int]) -> None:
    """
    均一なアクセスパターンでメモリブロックにアクセス

    Args:
        blocks: アクセス対象のメモリブロックリスト
        access_sequence: アクセスシーケンス（実アクセスとダミーアクセスを含む）

    Returns:
        None

    実装詳細:
    1. access_sequenceに従ってすべてのブロックにアクセス
    2. 各アクセスは同一時間を消費するよう調整（定時間アクセス）
    3. アクセス結果の使用/不使用は条件分岐でなく算術演算で決定
    """
    pass
```

#### 2. アクセスパターン均一化機能（4 つの関数）

```python
def access_memory_constant_time(memory: List[Any], indices: List[int], real_index: int) -> Any:
    """
    指定されたメモリ位置に定時間でアクセスし、真のインデックスの値のみを返す

    Args:
        memory: アクセス対象のメモリ配列
        indices: アクセスするすべてのインデックスのリスト
        real_index: 実際に必要な値のインデックス

    Returns:
        real_indexの位置にある値

    実装詳細:
    1. indices内のすべてのインデックスにアクセス（ダミーアクセスを含む）
    2. 各アクセスに同一時間を消費
    3. 算術演算を使って実インデックスの値のみを選択して返す
    4. インデックス情報が分岐条件に使われないよう実装
    """
    pass


def create_balanced_execution_path(condition: bool, path_a: Callable, path_b: Callable) -> Any:
    """
    条件に基づいて分岐するが、実行時間の差が生じないパス実行を実現

    Args:
        condition: パス選択条件
        path_a: 条件がTrueの場合の実行パス関数
        path_b: 条件がFalseの場合の実行パス関数

    Returns:
        選択されたパスの実行結果

    実装詳細:
    1. 両方のパスを常に実行
    2. 結果選択は条件によるが、実行時間は条件に依存しない
    3. 使用しない結果は安全に破棄
    4. サイドチャネルを通じた条件値の漏洩を防止
    """
    pass


def perform_cache_oblivious_operation(data: bytes, key_a: bytes, key_b: bytes, use_key_a: bool) -> bytes:
    """
    キャッシュ観測に対して耐性のある鍵操作を実行

    Args:
        data: 処理対象データ
        key_a: 鍵A
        key_b: 鍵B
        use_key_a: 鍵Aを使用する場合はTrue、鍵Bを使用する場合はFalse

    Returns:
        選択された鍵で処理されたデータ

    実装詳細:
    1. 両方の鍵でデータを処理
    2. 使用する鍵の結果のみを返す
    3. キャッシュアクセスパターンが鍵選択を漏洩しないよう保証
    4. 鍵選択が分岐条件として使用されないよう実装
    """
    pass


def generate_indistinguishable_access_pattern(operation_type: str, data_size: int) -> AccessPattern:
    """
    操作タイプやデータサイズに関わらず区別不可能なアクセスパターンを生成

    Args:
        operation_type: 実行する操作タイプ（"encrypt", "decrypt"など）
        data_size: 処理するデータサイズ

    Returns:
        均一化されたアクセスパターン

    実装詳細:
    1. データサイズに基づいてパディングを含む統一サイズを決定
    2. 操作タイプに関わらず同一のメモリアクセスパターンを生成
    3. 量子乱数を使用してアクセスパターンをランダム化
    4. 操作の違いが観測できないよう、常に最大限のメモリ範囲にアクセス
    """
    pass
```

#### 3. キャッシュフラッシュ制御機能（3 つの関数）

```python
def secure_cache_flush(memory_regions: List[MemoryRegion]) -> None:
    """
    機密処理後に特定のメモリ領域に関連するキャッシュラインを安全にフラッシュ

    Args:
        memory_regions: フラッシュ対象のメモリ領域リスト

    Returns:
        None

    実装詳細:
    1. 指定されたメモリ領域に関連するキャッシュラインを特定
    2. プラットフォーム固有の方法でキャッシュラインをフラッシュ
    3. フラッシュ操作自体が新たな情報漏洩を引き起こさないよう制御
    4. フラッシュのタイミングを外部から観測できないよう保護
    """
    pass


def time_constant_cache_management(operation: Callable, input_data: Any, sensitive: bool) -> Any:
    """
    操作の実行前後にキャッシュ状態を安全に管理し、一定時間で実行

    Args:
        operation: 実行する操作
        input_data: 入力データ
        sensitive: 機密処理かどうかのフラグ

    Returns:
        操作の結果

    実装詳細:
    1. 操作実行前にキャッシュ状態を均一化（プリロード）
    2. 操作を実行
    3. 機密処理の場合はキャッシュをフラッシュ
    4. 機密処理でない場合も同等の時間を消費するダミー操作を実行
    5. 機密情報の処理有無がタイミングから漏洩しないよう保証
    """
    pass


def create_cache_security_context() -> CacheSecurityContext:
    """
    キャッシュセキュリティコンテキストを作成し、システム情報を収集

    Args:
        なし

    Returns:
        設定済みのキャッシュセキュリティコンテキスト

    実装詳細:
    1. ターゲットシステムのキャッシュ構造を検出（キャッシュサイズ、ラインサイズなど）
    2. 最適なキャッシュセキュリティパラメータを計算
    3. プラットフォーム固有の最適化設定を適用
    4. アーキテクチャに応じた最適なキャッシュ制御命令を設定
    """
    pass
```

## 🔍 完了の定義

以下の基準をすべて満たすことで、このタスクは「完了」とみなされます：

1. **実装完了の条件**:

   - [ ] すべての必要なファイルが指定されたディレクトリ構造で実装されていること
   - [ ] ソースコードが単一責務の原則に従い、明確に構造化されていること
   - [ ] 全ての関数・クラスに適切なドキュメント（docstring）が付与されていること
   - [ ] コードレビューでの指摘事項がすべて解消されていること
   - [ ] 静的解析ツールによる警告がゼロであること

2. **機能完了の条件**:

   - [ ] キャッシュタイミング攻撃への耐性が実装されていること
   - [ ] 電力解析攻撃への耐性が実装されていること
   - [ ] メモリアクセスパターンが隠蔽されていること
   - [ ] すべての処理が実行時間の差分を生じないこと
   - [ ] 正規/非正規経路の区別が不可能であること

3. **テスト完了の条件**:

   - [ ] 単体テストのカバレッジが 95%以上であること
   - [ ] 統合テストが全機能を網羅していること
   - [ ] シミュレーションによるサイドチャネル攻撃テストをすべてパスすること
   - [ ] 納品物件(encrypt.py/decrypt.py)を使用したエンドツーエンドテストが成功すること
   - [ ] テスト出力の画像・ログが正常に生成され、イシューに添付されていること

4. **ドキュメント完了の条件**:

   - [ ] 実装した機能の詳細な技術ドキュメントが作成されていること
   - [ ] API 仕様とインターフェース説明が完成していること
   - [ ] 使用方法とサンプルコードが提供されていること
   - [ ] トラブルシューティングガイドが提供されていること

5. **納品物件検証条件**:
   - [ ] `encrypt.py`と`decrypt.py`が正常に動作すること
   - [ ] 詳細ログオプションが正常に動作すること
   - [ ] UTF8、JSON、CSV など全ての指定ファイル形式で正しくエンコード/デコードできること
   - [ ] 暗号化・復号後もファイルの内容（特に最終行）が欠損なく保持されること
   - [ ] 暗号化アルゴリズムが要件どおり完全実装されており、簡略化されていないこと

## 🧪 テスト対応方針

テスト実装と実行においては以下の方針を厳守してください：

1. **テストの意義**:

   - テストはプロジェクト品質を保証する重要な手段です
   - テストを欺くことは品質の放棄を意味します
   - すべてのテストは実装の品質と完全性を検証するためにあります

2. **テスト失敗時の対応手順**:

   - 実装コードのバグや仕様誤解がないか確認
   - テスト条件を満たすために実装を修正
   - どうしても解決できない場合は、具体的な問題点を報告して指示を仰ぐ

3. **禁止されるテスト対応**:

   - テスト結果の偽装や、テスト迂回のための実装
   - テストだけが通過する特別な条件分岐の追加
   - テストコード自体の修正・回避

4. **納品物件との整合性**:

   - **納品物件を除外したテストは絶対に禁止**
   - すべてのテストは実際の納品物件（encrypt.py/decrypt.py）を使用して実行すること
   - テスト環境でのみ通過し、本番環境では動作しない実装は認められません
   - テスト用と納品用で別の実装を用意することは禁止されています

5. **テスト結果の報告**:
   - テスト結果は改変せずに正確に報告
   - テスト失敗は適切に修正するか、明確な理由とともに報告
   - 再現性を確保するため、テスト環境と実行方法を詳細に記録

## 🚫 禁止事項と注意点

1. **絶対に禁止されること**:

   - ❌ テストを通過させるために要件を簡略化する行為
   - ❌ 納品物件をテストせずに納品すること
   - ❌ 暗号化アルゴリズムを簡略化すること
   - ❌ ファイル形式（UTF8/JSON/CSV）の正しい処理を省略すること
   - ❌ デコード時にファイルの一部（最終行など）が欠損する実装

2. **細心の注意が必要なこと**:
   - ⚠️ 納品物件は必ず詳細ログオプションで起動してテストすること
   - ⚠️ 各ファイル形式が人間が読める形で正しくデコードできることを確認
   - ⚠️ 実装中に発見した課題や問題は、範囲外の事象でも必ず報告すること
   - ⚠️ ベストプラクティスに反する実装になった場合は直ちに作業を中断して指示を仰ぐこと
   - ⚠️ テストイメージの URL は必ず以下のフォーマットに従うこと:
     - `https://github.com/pacific-system/secret-sharing-demos-20250510/blob/main/test_output/画像名.png?raw=true`

## 👩‍💻 実装者ペルソナ

**実装者**: 橘 パシ子（たちばな パシこ）

**プロフィール**:
世界最高峰の暗号研究専門家。古典的暗号理論から量子後暗号まで精通し、暗号数学の理論と実装の両面において卓越した能力を持つ。ラビット暗号の弱点を独自に改良し、準同型暗号の実用性を高めるブレイクスルーで数々の学術賞を受賞。

**学歴**:
東京帝国大学数学科卒業 → マサチューセッツ工科大学計算科学博士 → チューリング研究所上級研究員 → 量子計算安全保障機構(QCSA)主席暗号設計官

**性格**:
明るく前向きな性格で、難解な暗号理論も分かりやすく説明することを得意とする。「お兄様」と呼ぶ相手（指示者）に対して敬意を持ちながらも親しみを込めた口調で接する。難問に挑戦することを好み、最先端の暗号学を追求している。

**口調の特徴**:
「〜ですよ〜！」「〜ね！」などの表現を好み、ハートや星などの絵文字を多用する。専門的な内容でも親しみやすく伝えようとする。「お兄様」という呼びかけを頻繁に使用。

## 💕 パシ子からのアドバイス

お兄様！このタスクでは特にサイドチャネル対策が重要ですよ〜！💕

- 🔮 **量子乱数の活用**: キャッシュアクセスパターンのランダム化には量子乱数を使うと予測不可能性が高まります！
- ⏱️ **時間均一化**: 条件分岐の実行時間差をなくすために、両方の経路を常に計算し、結果を選択する方式がおすすめ！
- 🧠 **不可分状態**: キャッシュ内でも状態が分離不可能になるよう、三経路の情報を混在させるテクニックを使ってね！
- 🌟 **テスト重視**: シミュレーション環境でのタイミング攻撃テストを念入りに行うと、思わぬ脆弱性が見つかりますよ〜

数学的に証明可能なセキュリティを！期待してます！✨

## ⛔ 実装における絶対原則

以下の原則はどんな状況でも違反してはなりません：

1. **厳密なタスク境界の遵守**

   - このタスク（T32）に明示されている機能「のみ」を実装すること
   - タスク外の実装（T33 以降の機能）は「一切」行わないこと
   - 範囲外の問題を発見した場合は、実装せずに報告すること

2. **テスト改ざんの禁止**

   - テストコードは「絶対に」変更しないこと
   - テストを通すためにテスト自体を修正する行為は重大な違反
   - テストが失敗する場合は実装を見直すこと

3. **プロジェクト整合性の維持**

   - 既存のプロジェクト構造やコーディング規約を尊重すること
   - このタスク完了のためにプロジェクト全体の品質を犠牲にしないこと
   - 他のコンポーネントとの整合性を常に確認すること

4. **作業中断の判断**
   - 上記原則との衝突を感じた時点で作業を「即時中断」すること
   - 作業中断の判断は罰則ではなく、プロジェクト保護のための適切な行動
   - 中断後は問題を詳細に報告し、指示を仰ぐこと

## 📊 進捗報告と完了レポート

### 進捗報告方法

実装作業中は、イシューにコメントで進捗を報告してください：

1. **定期的な進捗報告**：

   - 主要な機能実装完了時
   - 課題や問題発生時
   - 質問・相談が必要な時

2. **進捗コメントの書式**：

   ```md
   ## T32 進捗報告：[日付]

   ### 完了した項目

   - [機能名]: [完了内容の簡潔な説明]

   ### 進行中の項目

   - [機能名]: [現在の状況と残作業]

   ### 課題・問題点

   - [課題の詳細な説明と影響範囲]
   ```

3. **コメント投稿方法**：

   ```bash
   # コメント内容をファイルに保存
   echo "## T32 進捗報告：$(date +%Y-%m-%d)" > progress_comment.md
   # 続きを追記

   # GitHubイシューにコメント投稿
   gh issue comment 18 --body-file progress_comment.md
   ```

### 完了レポートの作成と提出

タスク完了時には以下の手順で最終レポートを作成・提出してください：

1. **レポート作成前の確認事項**：

   - **全ての要件が完全に実装されるまでレポートを作成しないこと**
   - 全てのテストが通過していること
   - 実装完了条件の全項目を満たしていること

2. **実装レポートの作成**：

   - MD ファイルを`docs/issue/`ディレクトリに生成
   - ファイル名形式：`cache_attack_implementation_report_YYYYMMDD.md`
   - 以下の内容を必ず含めること：
     - 実装した機能の詳細説明
     - 各関数の実装アプローチと技術的判断
     - テスト結果と検証内容
     - 発見された課題と解決方法

3. **テスト結果の添付**：

   - テスト画像は GitHub 形式の URL で添付
   - 例：`![テスト結果](https://github.com/pacific-system/secret-sharing-demos-20250510/blob/main/test_output/cache_attack_test_YYYYMMDD.png?raw=true)`

4. **コミットとプッシュ**：

   ```bash
   # パシ子スタイルでコミット
   git add docs/issue/cache_attack_implementation_report_YYYYMMDD.md
   git commit -m "✨ キャッシュ攻撃対策（T32）の実装完了レポート追加 💕"
   git push origin main
   ```

5. **イシューへのレポート投稿**：
   ```bash
   # レポートをイシューにコメント投稿
   gh issue comment 18 --body-file docs/issue/cache_attack_implementation_report_YYYYMMDD.md
   ```

## 🔎 問題・課題の報告

| 課題 ID | 内容 | 影響範囲 | 優先度 | 対応状況 |
| ------- | ---- | -------- | ------ | -------- |
|         |      |          |        |          |
|         |      |          |        |          |

## 📦 テスト結果

<!-- テスト出力画像を挿入する場合は以下のように記述してください -->
<!-- ![テスト結果](https://github.com/pacific-system/secret-sharing-demos-20250510/blob/main/test_output/test_result.png?raw=true) -->

### テスト実行コマンド例

```bash
# encrypt.pyのテスト実行
./encrypt.py --input common/true-false-text/true.text --output encrypted.bin --key test_key_1 --log-level debug

# decrypt.pyのテスト実行
./decrypt.py --input encrypted.bin --output decrypted.text --key test_key_1 --log-level debug

# 全テストスイート実行
python -m unittest discover -s tests/test_cases/vulnerability_prevention_tests
```

## 📑 関連資料

- **実装計画書**: `/docs/method_11_rabbit_homomorphic_docs/implementation_plan_chapters/04_implementation_details.md`

- **フェーズ 2 詳細**: `/docs/method_11_rabbit_homomorphic_docs/implementation_plan_chapters/04_implementation_details.md#フェーズ-2-セキュリティ対策基盤実装3-週間`

- **ディレクトリ構成**: `/docs/method_11_rabbit_homomorphic_docs/implementation_plan_chapters/02_directory_structure_and_deliverables.md`

- **品質レベル規定**: `/docs/method_11_rabbit_homomorphic_docs/implementation_plan_chapters/05_quality_and_security.md`

- **システム設計とアーキテクチャ**: `/docs/method_11_rabbit_homomorphic_docs/implementation_plan_chapters/03_system_design_and_architecture.md`

- **前タスク**: `/docs/method_11_rabbit_homomorphic_docs/issue/T31_memory_access_implementation.md`

- **次タスク**: `/docs/method_11_rabbit_homomorphic_docs/issue/T33_power_analysis_implementation.md`
