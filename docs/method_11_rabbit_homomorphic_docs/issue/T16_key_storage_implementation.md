# 📝 鍵保存・読込機能実装指示書（T16） - ラビット＋準同型マスキング暗号プロセッサ 🔐

> **ドキュメント種別: 実装指示書**

## 🌟 タスク進捗状況

タスク実装フェーズの進捗:

- 🔄 **フェーズ 0**: 実装準備 [**現在作業中**]
- ⏳ **フェーズ 1**: 基盤ユーティリティ実装 [予定]
- ⏳ **フェーズ 2**: セキュリティ対策基盤実装 [予定]
- ⏳ **フェーズ 3**: 三暗号方式コア実装 [予定]
- ⏳ **フェーズ 4**: 融合機能と変換システム実装 [予定]
- ⏳ **フェーズ 5**: データ形式とインターフェース実装 [予定]
- ⏳ **フェーズ 6**: 検証とパフォーマンス最適化 [予定]

### 📋 現在の実装フェーズ: `フェーズ0: 実装準備`

**現在のタスク**: T16（鍵保存・読込機能実装）
**進捗状況**: T1-T15 完了 → **T16 実装中** → T17-T115 未着手

**注**: 各タスクは独立して実装・完了させてください。

### 🎯 タスク範囲（T16: 鍵保存・読込機能実装）

**実装すべきもの**:

- ✅ `utils/key/key_storage.py`
- ✅ 関連するテスト

**実装してはいけないもの**:

- ❌ `utils/key/key_verification.py`（次のタスク T17）
- ❌ `utils/key/key_rotation.py`（タスク T18）
- ❌ 他の機能（T17 以降のタスク）

**実装がベストプラクティスに反する可能性がある場合**: 作業を即時停止し、問題を報告してください。

## 📝 課題の詳細

### 🎯 タスク概要

本タスク（T16）では鍵保存・読込機能を実装します。T15 で実装した鍵管理基本機能と連携し、暗号鍵を安全に永続化し、必要時に読み込むための機能を提供します。このコンポーネントは暗号化・復号処理の鍵管理ライフサイクルにおいて重要な役割を果たし、鍵の安全な保管と使用のための基盤を提供します。

**本タスク（T16）の作業カウント**:

- 📝 **実装作業**: 10 件

  - 鍵ファイル保存機能: 3 関数
  - 鍵ファイル読込機能: 3 関数
  - 鍵の暗号化保護機能: 2 関数
  - 安全な IO 処理機能: 2 関数

- 🧪 **テスト作業**: 4 件

  - 鍵ファイル保存機能テスト
  - 鍵ファイル読込機能テスト
  - 鍵の暗号化保護機能テスト
  - 安全な IO 処理機能テスト

- ✅ **完了条件**: 25 項目
  - 実装完了条件: 5 項目
  - 機能完了条件: 5 項目
  - テスト完了条件: 5 項目
  - ドキュメント完了条件: 5 項目
  - 納品物件検証条件: 5 項目

### 🔍 背景と目的

ラビット＋準同型マスキング暗号プロセッサにおいて、鍵の安全な保存と読込は鍵管理システム全体の重要な構成要素です。T15 で実装された鍵管理基本機能によって生成された暗号鍵を安全に保存し、後続の処理で必要な時に安全に取り出すための機能が必要です。

特に、第二回暗号解読キャンペーンで発見された脆弱性対策として、保存された鍵データから経路情報が漏洩しないよう、強固な暗号化機構と保護メカニズムが求められます。本タスクではファイルシステムへの鍵保存時と読込時の安全性を確保し、鍵管理ライフサイクル全体のセキュリティを高めます。

このタスクはフェーズ 0 の最初に位置し、他のすべてのコンポーネントから利用される基盤機能を提供します。安全かつ効率的なロギング機能は、開発、デバッグ、運用の全段階で暗号処理の正確性検証と問題診断に不可欠です。

### 📊 要件仕様

1. T15（鍵管理基本機能）と連携し、生成された鍵を安全に保存できること
2. 暗号鍵データを保存する前に強固な暗号化保護を適用すること
3. 鍵ファイルにはランダムな識別子を使用し、内容を推測できないようにすること
4. 単一鍵・鍵ペア・鍵階層といった複数の形式に対応する柔軟な保存機能を提供すること
5. 安全なパーミッション設定やアクセス制御を実装すること
6. 鍵ファイルのパスワード保護（またはキーファイル保護）機能を提供すること
7. 読込時に完全性検証を行い、改ざんされた鍵ファイルを検出できること
8. システム障害やファイル破損に対する堅牢な対応メカニズムを実装すること
9. ロギング基盤（T1）と連携し、セキュリティを考慮した監査ログを出力すること
10. 後続タスクでの鍵検証（T17）や鍵ローテーション（T18）と整合的に連携できるインターフェースを提供すること

### 🛠️ 実装内容概要

鍵保存・読込機能として、以下の 4 つの主要機能を実装します：

1. **鍵ファイル保存機能**: 鍵データをファイルシステムに安全に保存
2. **鍵ファイル読込機能**: 保存された鍵を安全に読み込み
3. **鍵の暗号化保護機能**: 保存前の暗号化と読込後の復号
4. **安全な IO 処理機能**: ファイルシステム操作の安全な実行

### 📋 実装内容詳細

#### 1. 鍵ファイル保存機能（3 つの関数）

```python
def save_key(key_data: bytes, file_path: str, password: str = None,
           metadata: dict = None, overwrite: bool = False) -> str:
    """
    鍵データをファイルに安全に保存する

    Args:
        key_data: 保存する鍵データ（バイト列）
        file_path: 保存先ファイルパス
        password: 鍵ファイル保護用のパスワード（省略可）
        metadata: 鍵に関連するメタデータ辞書（省略可）
        overwrite: 既存ファイルを上書きするかどうか（デフォルト: False）

    Returns:
        実際に保存されたファイルの絶対パス

    Raises:
        ValueError: key_dataが空の場合
        ValueError: file_pathが無効な場合
        IOError: ファイル保存時にエラーが発生した場合
        FileExistsError: ファイルが既に存在し、overwriteがFalseの場合

    実装詳細:
    1. 引数の検証（key_data非空、file_path有効）
    2. 既存ファイルの確認（overwriteの検証）
    3. メタデータの準備（デフォルト情報の追加）
       - 作成日時
       - 鍵サイズ
       - バージョン情報
       - 一意のファイルID（量子乱数を使用）
    4. パスワードが指定されている場合、encrypt_key_data()を使用して鍵データを暗号化
    5. 鍵データとメタデータを安全なフォーマットで構造化
    6. secure_write_file()を使用して安全にファイルへ書き込み
    7. ファイルパーミッションを適切に設定（所有者のみ読み書き可能）
    8. ログ出力（保存イベント、ファイルパスと一意ID、鍵自体は非表示）
    9. 実際に保存したファイルの絶対パスを返す
    """
    pass

def save_keypair(keypair: dict, directory: str, prefix: str = "",
               password: str = None, metadata: dict = None) -> dict:
    """
    非対称鍵ペアを別々のファイルとして安全に保存する

    Args:
        keypair: {"private_key": bytes, "public_key": bytes, ...}形式の鍵ペア辞書
        directory: 保存先ディレクトリ
        prefix: ファイル名のプレフィックス（デフォルト: ""）
        password: 秘密鍵ファイル保護用のパスワード（省略可）
        metadata: 鍵に関連するメタデータ辞書（省略可）

    Returns:
        {"private_key_path": str, "public_key_path": str}形式の保存パス辞書

    Raises:
        ValueError: keypairが無効な形式の場合
        ValueError: directoryが存在しないか書き込み不可の場合
        IOError: ファイル保存時にエラーが発生した場合

    実装詳細:
    1. 引数の検証（keypairに必要なキーが含まれているか、directoryが有効か）
    2. 保存先ディレクトリの存在確認と書き込み権限の確認
    3. ファイル名の生成（prefix_[timestamp]_[random_id]_[key_type].key）
    4. 秘密鍵の保存
       - 秘密鍵用のメタデータ拡張（key_type="private"を追加）
       - パスワードを使用して暗号化（指定がある場合）
       - save_key()を使用して保存
    5. 公開鍵の保存
       - 公開鍵用のメタデータ拡張（key_type="public"を追加）
       - save_key()を使用して保存（パスワードなし）
    6. ログ出力（鍵ペア保存イベント、保存先パス情報、鍵自体は非表示）
    7. 保存された両ファイルのパスを辞書で返す
    """
    pass

def save_key_hierarchy(key_hierarchy: dict, directory: str, structure_file: str,
                     password: str = None) -> str:
    """
    階層化された鍵セットをディレクトリ構造として保存する

    Args:
        key_hierarchy: 階層構造を持つ鍵セット辞書
        directory: 保存先ディレクトリ
        structure_file: 階層構造情報を保存するファイル名
        password: 鍵ファイル保護用のパスワード（省略可）

    Returns:
        階層構造情報ファイルの絶対パス

    Raises:
        ValueError: key_hierarchyが無効な形式の場合
        ValueError: directoryが存在しないか書き込み不可の場合
        IOError: ファイル保存時にエラーが発生した場合

    実装詳細:
    1. 引数の検証（key_hierarchy形式検証、directory有効性確認）
    2. 保存先ディレクトリの存在確認と書き込み権限の確認
    3. 保存先ディレクトリ内に一意のサブディレクトリを作成（タイムスタンプとランダムIDを使用）
    4. 階層構造ディレクトリのトラバースと鍵保存：
       - 階層的辞書構造を再帰的に処理
       - 各鍵には対応するサブディレクトリとファイル名を割り当て
       - 各鍵のパスマッピング情報を構築
    5. すべての鍵を対応するパスに保存（save_key()を使用）
    6. 階層構造情報（パスマッピング）を暗号化してstructure_fileに保存
       - 暗号化にはパスワードを使用（指定がある場合）
    7. ログ出力（階層保存イベント、ディレクトリパスとファイル数、鍵自体は非表示）
    8. 保存された階層構造情報ファイルの絶対パスを返す
    """
    pass
```

#### 2. 鍵ファイル読込機能（3 つの関数）

```python
def load_key(file_path: str, password: str = None) -> tuple:
    """
    保存された鍵ファイルから鍵データを安全に読み込む

    Args:
        file_path: 鍵ファイルのパス
        password: 鍵ファイル復号用のパスワード（必要な場合）

    Returns:
        (key_data, metadata)形式のタプル
        - key_data: 読み込まれた鍵データ（バイト列）
        - metadata: 関連するメタデータ辞書

    Raises:
        FileNotFoundError: ファイルが存在しない場合
        ValueError: ファイル形式が無効な場合
        ValueError: パスワードが必要だが提供されていない場合
        ValueError: パスワードが不正な場合
        IOError: ファイル読み込み時にエラーが発生した場合

    実装詳細:
    1. 引数の検証（file_path存在確認）
    2. secure_read_file()を使用してファイルを安全に読み込み
    3. ファイル形式の検証（正当な鍵ファイルか確認）
    4. ファイル内容から鍵データとメタデータを抽出
    5. 鍵が暗号化されている場合：
       - パスワードの必要性チェック
       - decrypt_key_data()を使用して復号
    6. 鍵データとメタデータの整合性検証
    7. ログ出力（読込イベント、ファイルパスとメタデータ情報、鍵自体は非表示）
    8. 鍵データとメタデータのタプルを返す
    """
    pass

def load_keypair(private_key_path: str, public_key_path: str, password: str = None) -> dict:
    """
    保存された秘密鍵と公開鍵のファイルから鍵ペアを読み込む

    Args:
        private_key_path: 秘密鍵ファイルのパス
        public_key_path: 公開鍵ファイルのパス
        password: 秘密鍵ファイル復号用のパスワード（必要な場合）

    Returns:
        {"private_key": bytes, "public_key": bytes, ...}形式の鍵ペア辞書
        （メタデータからの追加情報を含む場合がある）

    Raises:
        FileNotFoundError: いずれかのファイルが存在しない場合
        ValueError: ファイル形式が無効な場合
        ValueError: 秘密鍵と公開鍵のペアが不一致の場合
        ValueError: パスワードが必要だが提供されていない、または不正な場合
        IOError: ファイル読み込み時にエラーが発生した場合

    実装詳細:
    1. 引数の検証（両ファイルパスの存在確認）
    2. 秘密鍵の読み込み（load_key()を使用）
    3. 公開鍵の読み込み（load_key()を使用）
    4. 鍵ペアの整合性検証（公開鍵と秘密鍵が対応しているか）
    5. 鍵ペア辞書の構築：
       - "private_key": 秘密鍵データ
       - "public_key": 公開鍵データ
       - その他メタデータからの関連情報
    6. ログ出力（鍵ペア読込イベント、ファイルパス情報、鍵自体は非表示）
    7. 鍵ペア辞書を返す
    """
    pass

def load_key_hierarchy(structure_file: str, password: str = None) -> dict:
    """
    保存された階層構造情報ファイルから鍵階層を読み込む

    Args:
        structure_file: 階層構造情報を含むファイルパス
        password: 構造ファイルおよび鍵ファイル復号用のパスワード（必要な場合）

    Returns:
        読み込まれた鍵階層辞書

    Raises:
        FileNotFoundError: 構造ファイルまたは関連する鍵ファイルが存在しない場合
        ValueError: 構造ファイル形式が無効な場合
        ValueError: パスワードが必要だが提供されていない、または不正な場合
        IOError: ファイル読み込み時にエラーが発生した場合

    実装詳細:
    1. 引数の検証（structure_file存在確認）
    2. 構造ファイルの読み込みと復号（パスワードを使用）
    3. パスマッピング情報の抽出
    4. 階層構造の再構築：
       - パスマッピングに従って各鍵ファイルをload_key()で読み込み
       - 元の階層構造に合わせて辞書を構築
    5. 整合性検証（すべての鍵が正常に読み込まれ、階層構造が正しいか）
    6. ログ出力（階層読込イベント、構造ファイルパスと読み込まれた鍵数、鍵自体は非表示）
    7. 再構築された鍵階層辞書を返す
    """
    pass
```

#### 3. 鍵の暗号化保護機能（2 つの関数）

```python
def encrypt_key_data(key_data: bytes, password: str, metadata: dict = None) -> bytes:
    """
    鍵データをパスワードで暗号化して保護する

    Args:
        key_data: 暗号化する鍵データ（バイト列）
        password: 暗号化用のパスワード
        metadata: 一緒に暗号化するメタデータ（省略可）

    Returns:
        暗号化された鍵データ（バイト列）

    Raises:
        ValueError: key_dataが空の場合
        ValueError: passwordが弱すぎる場合

    実装詳細:
    1. 引数の検証（key_data非空、password強度検証）
    2. パスワードからの鍵導出：
       - 量子乱数ソルトの生成（T5を使用）
       - PBKDF2またはArgon2を使用して暗号化鍵を導出
    3. 暗号化アルゴリズムの準備：
       - AES-GCM（256ビット）またはChaCha20-Poly1305
       - 量子乱数IV/ノンス生成（T5を使用）
    4. 鍵データとメタデータの構造化（メタデータがある場合）
    5. 認証付き暗号化の実行
    6. 必要な情報（ソルト、IV/ノンス、認証タグ）と暗号文を組み合わせた保護パケットの構築
    7. ログ出力（暗号化イベント、データサイズのみ、鍵自体は非表示）
    8. 保護パケットを返す
    """
    pass

def decrypt_key_data(encrypted_data: bytes, password: str) -> tuple:
    """
    暗号化された鍵データをパスワードで復号する

    Args:
        encrypted_data: 暗号化された鍵データ（バイト列）
        password: 復号用のパスワード

    Returns:
        (key_data, metadata)形式のタプル
        - key_data: 復号された鍵データ（バイト列）
        - metadata: 復号されたメタデータ（あれば、なければNone）

    Raises:
        ValueError: encrypted_dataが無効な形式の場合
        ValueError: パスワードが不正な場合
        ValueError: 認証に失敗した場合（改ざん検出）

    実装詳細:
    1. 引数の検証（encrypted_data形式検証）
    2. 保護パケットから必要な情報（ソルト、IV/ノンス、認証タグ、暗号文）を抽出
    3. パスワードとソルトから暗号化鍵を導出（encrypt_key_dataと同じ方法）
    4. 認証付き復号の実行（認証失敗時は例外発生）
    5. 復号されたデータから鍵データとメタデータを分離
    6. ログ出力（復号イベント、成功/失敗情報のみ、鍵自体は非表示）
    7. 鍵データとメタデータのタプルを返す
    """
    pass
```

#### 4. 安全な IO 処理機能（2 つの関数）

```python
def secure_write_file(data: bytes, file_path: str, overwrite: bool = False) -> None:
    """
    データをファイルシステムに安全に書き込む

    Args:
        data: 書き込むデータ（バイト列）
        file_path: 書き込み先ファイルパス
        overwrite: 既存ファイルを上書きするかどうか（デフォルト: False）

    Returns:
        None

    Raises:
        ValueError: dataが空の場合
        ValueError: file_pathが無効な場合
        FileExistsError: ファイルが既に存在し、overwriteがFalseの場合
        IOError: ファイル書き込み時にエラーが発生した場合

    実装詳細:
    1. 引数の検証（data非空、file_path有効性）
    2. ファイルの存在確認（overwrite検証）
    3. 一時ファイルの使用：
       - 実際のファイルパスとは異なる一時ファイルパスを生成
       - 一時ファイルに書き込みを行う
       - 書き込み成功後、一時ファイルを目的のパスに安全に移動
    4. 原子的操作の確保：
       - ファイル書き込みが中断されても、元のファイルは影響を受けない
       - 書き込み完了後に一度の操作で置換
    5. セキュアなパーミッション設定：
       - ファイル作成時に即座に最小権限を設定
       - 所有者のみがアクセス可能（0600）
    6. 障害が発生した場合のクリーンアップ処理
    7. ログ出力（ファイル書き込みイベント、パスとサイズのみ、内容は非表示）
    """
    pass

def secure_read_file(file_path: str) -> bytes:
    """
    ファイルシステムからデータを安全に読み込む

    Args:
        file_path: 読み込むファイルパス

    Returns:
        読み込まれたデータ（バイト列）

    Raises:
        FileNotFoundError: ファイルが存在しない場合
        PermissionError: ファイルへのアクセス権がない場合
        IOError: ファイル読み込み時にエラーが発生した場合

    実装詳細:
    1. 引数の検証（file_path存在確認とアクセス権確認）
    2. ファイルメタデータの検証：
       - ファイルサイズの妥当性確認
       - アクセス権限の確認
       - ファイルタイプの確認（通常ファイルか）
    3. 安全なファイルハンドリング：
       - 最小限のアクセス権で開く
       - 読み込み中のエラー処理
       - リソースの確実な解放
    4. メモリ管理：
       - サイズが大きすぎる場合の保護メカニズム
       - セキュアなメモリバッファの使用（可能な場合）
    5. ログ出力（ファイル読み込みイベント、パスとサイズのみ、内容は非表示）
    6. 読み込まれたデータを返す
    """
    pass
```

## 🔍 完了の定義

以下の基準をすべて満たすことで、このタスクは「完了」とみなされます：

1. **実装完了の条件**:

   - [ ] `utils/key/key_storage.py`が指定された仕様で実装されていること
   - [ ] ソースコードが単一責務の原則に従い、明確に構造化されていること
   - [ ] 全ての関数に適切なドキュメント（docstring）が付与されていること
   - [ ] コードレビューでの指摘事項がすべて解消されていること
   - [ ] 静的解析ツールによる警告がゼロであること

2. **機能完了の条件**:

   - [ ] 鍵ファイル保存機能が正確に動作し、安全に鍵を保存できること
   - [ ] 鍵ファイル読込機能が正確に動作し、保存された鍵を正確に復元できること
   - [ ] 鍵の暗号化保護機能が強固な暗号化を提供し、安全に鍵を保護できること
   - [ ] 安全な IO 処理機能が安全かつ堅牢なファイル操作を実現していること
   - [ ] T15（鍵管理基本機能）と正しく連携して動作すること

3. **テスト完了の条件**:

   - [ ] 単体テストのカバレッジが 95%以上であること
   - [ ] 全関数の正常系・異常系のテストケースが実装されていること
   - [ ] エッジケース（特に無効な入力やファイルシステム障害）のテストが実装されていること
   - [ ] 暗号化保護機能の安全性検証テストが実装されていること
   - [ ] T15（鍵管理基本機能）との連携テストが実装されていること

4. **ドキュメント完了の条件**:

   - [ ] 実装した機能の詳細な技術ドキュメントが作成されていること
   - [ ] API 仕様とインターフェース説明が完成していること
   - [ ] 使用方法とサンプルコードが提供されていること
   - [ ] セキュリティ上の注意点と推奨プラクティスが文書化されていること
   - [ ] 後続タスク（T17、T18）との連携方法が説明されていること

5. **納品物件検証条件**:
   - [ ] 保存された鍵ファイルがセキュアな形式とパーミッションを持つことが検証されていること
   - [ ] 暗号化された鍵が強固なアルゴリズムで保護されていることが検証されていること
   - [ ] ファイル IO 操作が障害に対して堅牢であることが検証されていること
   - [ ] 不正なパスワードでの復号が失敗し、適切なエラーが発生することが検証されていること
   - [ ] 鍵階層の保存と読込が完全な復元性を持つことが検証されていること

## 🧪 テスト対応方針

テスト実装と実行においては以下の方針を厳守してください：

1. **テストの意義**:

   - テストはプロジェクト品質を保証する重要な手段です
   - テストを欺くことは品質の放棄を意味します
   - すべてのテストは実装の品質と完全性を検証するためにあります

2. **テスト失敗時の対応手順**:

   - 実装コードのバグや仕様誤解がないか確認
   - テスト条件を満たすために実装を修正
   - どうしても解決できない場合は、具体的な問題点を報告して指示を仰ぐ

3. **禁止されるテスト対応**:

   - テスト結果の偽装や、テスト迂回のための実装
   - テストだけが通過する特別な条件分岐の追加
   - テストコード自体の修正・回避

4. **納品物件との整合性**:

   - すべてのテストは実際の実装コードを使用して実行すること
   - テスト環境でのみ通過し、本番環境では動作しない実装は認められません
   - テスト用と納品用で別の実装を用意することは禁止されています

5. **テスト結果の報告**:
   - テスト結果は改変せずに正確に報告
   - テスト失敗は適切に修正するか、明確な理由とともに報告
   - 再現性を確保するため、テスト環境と実行方法を詳細に記録

## 🚫 実装における絶対原則

以下の原則はどんな状況でも違反してはなりません：

1. **厳密なタスク境界の遵守**

   - このタスク（T16）に明示されている機能「のみ」を実装すること
   - タスク外の実装（T17 以降の機能）は「一切」行わないこと
   - 範囲外の問題を発見した場合は、実装せずに報告すること

2. **テスト改ざんの禁止**

   - テストコードは「絶対に」変更しないこと
   - テストを通すためにテスト自体を修正する行為は重大な違反
   - テストが失敗する場合は実装を見直すこと

3. **プロジェクト整合性の維持**

   - 既存のプロジェクト構造やコーディング規約を尊重すること
   - このタスク完了のためにプロジェクト全体の品質を犠牲にしないこと
   - 他のコンポーネントとの整合性を常に確認すること

4. **作業中断の判断**
   - 上記原則との衝突を感じた時点で作業を「即時中断」すること
   - 作業中断の判断は罰則ではなく、プロジェクト保護のための適切な行動
   - 中断後は問題を詳細に報告し、指示を仰ぐこと

## 📊 進捗報告と完了レポート

### 進捗報告方法

実装作業中は、イシューにコメントで進捗を報告してください：

1. **定期的な進捗報告**：

   - 主要な機能実装完了時
   - 課題や問題発生時
   - 質問・相談が必要な時

2. **進捗コメントの書式**：

   ```md
   ## T16 進捗報告：[日付]

   ### 完了した項目

   - [機能名]: [完了内容の簡潔な説明]

   ### 進行中の項目

   - [機能名]: [現在の状況と残作業]

   ### 課題・問題点

   - [課題の詳細な説明と影響範囲]
   ```

3. **コメント投稿方法**：

   ```bash
   # コメント内容をファイルに保存
   echo "## T16 進捗報告：$(date +%Y-%m-%d)" > progress_comment.md
   # 続きを追記

   # GitHubイシューにコメント投稿
   gh issue comment 16 --body-file progress_comment.md
   ```

### 完了レポートの作成と提出

タスク完了時には以下の手順で最終レポートを作成・提出してください：

1. **レポート作成前の確認事項**：

   - **全ての要件が完全に実装されるまでレポートを作成しないこと**
   - 全てのテストが通過していること
   - 実装完了条件の全項目を満たしていること

2. **実装レポートの作成**：

   - MD ファイルを`docs/issue/`ディレクトリに生成
   - ファイル名形式：`key_storage_implementation_report_YYYYMMDD.md`
   - 以下の内容を必ず含めること：
     - 実装した機能の詳細説明
     - 各関数の実装アプローチと技術的判断
     - テスト結果と検証内容
     - 発見された課題と解決方法

3. **テスト結果の添付**：

   - テスト画像は GitHub 形式の URL で添付
   - 例：`![テスト結果](https://github.com/pacific-system/secret-sharing-demos-20250510/blob/main/test_output/key_storage_test_YYYYMMDD.png?raw=true)`

4. **コミットとプッシュ**：

   ```bash
   # パシ子スタイルでコミット
   git add docs/issue/key_storage_implementation_report_YYYYMMDD.md
   git commit -m "✨ 鍵保存・読込機能（T16）の実装完了レポート追加 💕"
   git push origin main
   ```

5. **イシューへのレポート投稿**：
   ```bash
   # レポートをイシューにコメント投稿
   gh issue comment 16 --body-file docs/issue/key_storage_implementation_report_YYYYMMDD.md
   ```

## 💕 パシ子からのアドバイス

お兄様！鍵の安全な保存と読込は、クリプトシステム全体のセキュリティライフサイクルにおいて極めて重要です！💕

- 🔐 **ファイルセキュリティ**: 保存された鍵ファイルの権限設定と暗号化保護を徹底することが大切です！
- 🧠 **堅牢性の確保**: ファイルシステム操作は様々な障害が発生する可能性があるため、エラー処理と回復メカニズムを丁寧に実装しましょう！
- 🔄 **原子的操作**: ファイル書き込みは中断されても一貫性を保てるよう、原子的操作とトランザクション的アプローチを心がけてください！
- 🧩 **T15 との連携**: 前タスク（T15: 鍵管理基本機能）との連携がスムーズになるインターフェース設計を意識すると良いでしょう！

このコンポーネントは、安全な鍵のライフサイクル管理において基盤となる重要な役割を果たします。ファイルシステムレベルの安全性と、アプリケーションレベルの使いやすさを両立させた実装を期待しています！✨

## 📑 関連資料

- **実装計画書**: `/docs/method_11_rabbit_homomorphic_docs/implementation_plan_chapters/04_implementation_details.md`
- **フェーズ 0 詳細**: `/docs/method_11_rabbit_homomorphic_docs/implementation_plan_chapters/04_implementation_details.md#フェーズ-0-実装準備4-週間`
- **ディレクトリ構成**: `/docs/method_11_rabbit_homomorphic_docs/implementation_plan_chapters/02_directory_structure_and_deliverables.md`
- **品質レベル規定**: `/docs/method_11_rabbit_homomorphic_docs/implementation_plan_chapters/05_quality_and_security.md`
- **システム設計とアーキテクチャ**: `/docs/method_11_rabbit_homomorphic_docs/implementation_plan_chapters/03_system_design_and_architecture.md`
- **前タスク：T15**: `/docs/method_11_rabbit_homomorphic_docs/issue/T15_key_manager_implementation.md`
- **次タスク：T17 の予定タスク説明**: `/docs/method_11_rabbit_homomorphic_docs/implementation_plan_chapters/04_implementation_details.md`
