# 復号化モジュール実装ガイド

## 復号化モジュールの目的

このモジュールは暗号化されたファイルから、特定のシェア ID セットとパスワードを用いて単一の JSON 文書を復元します。多段 MAP 方式の特徴を活かし、パスワードによって異なる文書が復号される仕組みです。

## 重要なセキュリティ要件

### 1. 直線的処理の厳格な実装

復号処理において最も重要な要件は「直線的処理」です：

- **条件分岐の禁止**: どのような状況でも入力値による条件分岐を行わない
- **定数時間処理**: 全ての処理が入力値に関わらず同じ時間で実行される
- **タイミング攻撃耐性**: 処理時間から入力情報が推測できないようにする

### 2. 多段 MAP 方式の正確な実装

1. **第 1 段階（シェア ID による限定）**:

   - 入力されたシェア ID セットで候補シェアを限定
   - 該当しないシェア ID のシェアは完全に除外

2. **第 2 段階（パスワードによるマッピング）**:
   - パスワードと塩値から KDF でマップキーを生成
   - 各シェア ID に決定論的にマッピング値を生成
   - マッピング値でソート後、閾値分のシェアを選択

## 主要関数の実装ガイド

### 1. 多段 MAP の実装

```python
def stage1_map(share_ids):
    """シェアIDによる第1段階MAP生成

    Args:
        share_ids: ユーザー入力のシェアIDセット

    Returns:
        シェアID候補セット
    """
    # シェアIDセットをセットとして返す（単純フィルタとして機能）
    return set(share_ids)

def stage2_map(password, candidate_ids, salt):
    """パスワードによる第2段階MAP生成

    Args:
        password: ユーザー入力のパスワード
        candidate_ids: 第1段階で限定されたシェアIDのセット
        salt: 暗号化時に生成された塩値

    Returns:
        シェアIDからマッピング値へのマップ辞書
    """
    # パスワードからKDFを用いてキーを導出
    # 各シェアIDに対するマッピング値をHMACで決定論的に生成
    # {share_id: mapping_value} 形式の辞書を返す
```

### 2. シェア選択と復元

```python
def select_shares(all_shares, share_ids, password, salt, threshold):
    """多段MAPを用いたシェア選択

    Args:
        all_shares: 全シェアリスト
        share_ids: ユーザー入力のシェアIDセット
        password: ユーザー入力のパスワード
        salt: 暗号化時に生成された塩値
        threshold: 閾値（必要シェア数）

    Returns:
        選択されたシェアのリスト
    """
    # 第1段階：シェアID空間の限定
    # 第2段階：パスワードによるマッピング
    # マッピング値でソート
    # 閾値分のシェアを選択（必ず同じ数を処理）
```

### 3. シャミア秘密分散法による復元

```python
def lagrange_interpolation(shares, p):
    """ラグランジュ補間によるシークレット復元

    Args:
        shares: (x, y)形式のシェアリスト
        p: 有限体の素数

    Returns:
        復元された秘密値
    """
    # ラグランジュ補間によるシークレット復元を実装
    # 有限体GF(p)上での計算に注意
```

### 4. 復号関数

```python
def decrypt(encrypted_file, share_ids, password):
    """暗号化ファイルの復号

    Args:
        encrypted_file: 暗号化されたファイル構造
        share_ids: ユーザー入力のシェアIDセット
        password: ユーザー入力のパスワード

    Returns:
        復元されたJSON文書またはデコードに失敗した場合は生データ
    """
    # メタデータ取得
    # 多段MAPを用いたシェア選択
    # 選択されたシェアを用いてチャンク別に秘密を復元
    # 復元されたデータに多段デコードを適用
    # JSONとして解析
```

### 5. 多段デコードと復元処理

```python
def try_decrypt(all_shares, share_ids, password, salt, threshold):
    """シェアを復号（A/B判定なしの直線的処理）

    Args:
        all_shares: 全シェアリスト
        share_ids: ユーザー入力のシェアIDセット
        password: ユーザー入力のパスワード
        salt: 暗号化時に生成された塩値
        threshold: 閾値（必要シェア数）

    Returns:
        復元されたバイトデータ
    """
    # 多段MAPの適用
    # チャンク別にシェアを整理
    # 各チャンクの復元（条件分岐なしの直線的処理）
    # 復元データの結合

def decode_data(data):
    """多段デコード処理

    Args:
        data: 復元されたバイトデータ

    Returns:
        デコードされたJSON文書または例外発生時のデータ
    """
    # Base64デコード
    # Latin-1からUTF-8へのエンコード変換
    # JSON解析
```

## 実装上の制約と注意点

### 1. 条件分岐の禁止と定数時間処理の実装

以下のパターンは条件分岐によるサイドチャネル攻撃を防止するために必須です。すべての条件分岐を含むコードパターンは**禁止**されます。

```python
# ⛔ 禁止: 条件分岐を使った選択
result = value_a if condition else value_b

# ✅ 推奨: ビット演算を用いた定数時間選択
mask = -(condition & 1)  # True -> -1 (all bits 1), False -> 0
result = (value_a & mask) | (value_b & ~mask)

# ⛔ 禁止: 早期リターンによる処理
for share in shares:
    if is_valid(share):
        return share

# ✅ 推奨: 全要素を処理しつつ条件を満たすものを記録
selected = None
for i, share in enumerate(shares):
    is_valid_share = is_valid(share)
    is_first_valid = is_valid_share and (selected is None)
    # ビット演算で条件分岐せずに選択
```

### 2. エラーハンドリング

- **失敗の特定を避ける**: 復号に失敗したか成功したかを外部から判別させない
- **例外処理の統一**: 例外を投げる場合も定数時間で処理
- **エラー情報の最小化**: エラーメッセージによる情報漏洩を防止

### 3. パフォーマンスとメモリ使用

- **チャンク単位の処理**: メモリ効率を高めるため、チャンク単位で処理
- **予測可能なメモリアロケーション**: メモリ使用パターンが入力によって大きく変わらないよう設計
- **カタストロフィックバックトラッキング対策**: 正規表現処理などでバックトラッキングによる処理時間増大を防止

## 復号成功・失敗の判定

復号結果の判定における重要なポイントは、成功・失敗の判定自体がタイミング攻撃につながる可能性があることです。

- **同一処理フローの維持**: 結果の正当性にかかわらず同じ処理を実行
- **条件分岐なしの結果返却**: 成功・失敗の判断基準を内部で持たない
- **エラー伝播の最小化**: 後続処理で JSON 解析失敗などが発生しても情報を漏洩させない

復号プロセスは常に同じステップを実行し、結果が正しい JSON かどうかの判断はこのモジュール外で行います。
