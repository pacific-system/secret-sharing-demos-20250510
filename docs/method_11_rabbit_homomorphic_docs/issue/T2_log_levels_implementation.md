# 📝 ログレベル管理実装指示書（T2） - ラビット＋準同型マスキング暗号プロセッサ 🔐

> **ドキュメント種別: 実装指示書**

## 🌟 タスク進捗状況

タスク実装フェーズの進捗:

- 🔄 **フェーズ 1**: 基盤ユーティリティ実装 [**現在作業中**]
- ⏳ **フェーズ 2**: セキュリティ対策基盤実装 [予定]
- ⏳ **フェーズ 3**: 三暗号方式コア実装 [予定]
- ⏳ **フェーズ 4**: 融合機能と変換システム実装 [予定]
- ⏳ **フェーズ 5**: データ形式とインターフェース実装 [予定]
- ⏳ **フェーズ 6**: 検証とパフォーマンス最適化 [予定]

### 📋 現在の実装フェーズ: `フェーズ1: 基盤ユーティリティ実装`

**現在のタスク**: T2（ログレベル管理実装）
**進捗状況**: T1 完了 → **T2 実装中** → T3-T115 未着手

**注**: 各タスクは独立して実装・完了させてください。

### 🎯 タスク範囲（T2: ログレベル管理実装）

**実装すべきもの**:

- ✅ `utils/logging/log_levels.py`
- ✅ 関連するテスト

**実装してはいけないもの**:

- ❌ `utils/logging/output_router.py`（次のタスク T3）
- ❌ 他のロギング関連機能（T3 以降のタスク）

**範囲外の機能を見つけた場合**: 作業を停止し、問題を報告してください。

## 📝 課題の詳細

### 🎯 タスク概要

本タスク（T2）ではログレベル管理機能を実装します。前タスク（T1）で実装したロギング基盤に対して、複数のログレベル（ERROR, WARNING, INFO, DEBUG, TRACE）を定義し、それらの階層管理と動的な切り替え制御を可能にします。セキュリティ要件に基づいたレベル制御とフィルタリング機能も実装します。次のタスク（T3）で実装予定のログ出力ルーティング実装は含みません。

**本タスク（T2）の作業カウント**:

- 📝 **実装作業**: 10 件

  - ログレベル定義機能: 3 関数
  - レベル管理機能: 4 関数
  - セキュリティフィルタリング機能: 3 関数

- 🧪 **テスト作業**: 4 件

  - ログレベル定義機能テスト
  - レベル管理機能テスト
  - セキュリティフィルタリング機能テスト
  - 統合テスト（T1 との連携）

- ✅ **完了条件**: 25 項目
  - 実装完了条件: 5 項目
  - 機能完了条件: 5 項目
  - テスト完了条件: 5 項目
  - ドキュメント完了条件: 5 項目
  - 納品物件検証条件: 5 項目

### 🔍 背景と目的

高度な暗号システムにおいては、開発時、テスト時、運用時で適切なログ出力制御が必要です。特に第二回暗号解読キャンペーンで発見された「ログ情報漏洩攻撃」の脆弱性に対応するためには、ログレベルに応じた情報の適切なフィルタリングとセキュリティレベルの管理が不可欠です。

このタスクは、フェーズ 1 の基盤ユーティリティ実装の一部として、ロギング基盤をより強化し、柔軟なログ制御を提供します。これにより、診断情報の詳細度を状況に応じて制御しながらも、機密情報の漏洩を防止する体制を構築します。

### 📊 要件仕様

1. 5 つの標準ログレベル（ERROR, WARNING, INFO, DEBUG, TRACE）を定義し、数値と名前のマッピングを提供すること
2. カスタムログレベルの追加・定義をサポートし、将来の拡張に対応すること
3. レベル間の階層関係（例：ERROR は WARNING より高い）を明確に定義・管理すること
4. 実行時のログレベル変更機能を提供し、動的なログ詳細度の制御を可能にすること
5. セキュリティレベルに基づいた情報フィルタリングメカニズムを実装すること
6. 各レベルの出力形式（色、プレフィックスなど）をカスタマイズ可能にすること
7. T1 で実装したロガー基盤と整合的に機能し、シームレスに統合できること
8. レベルベースのフィルタリングが高速に動作し、パフォーマンスオーバーヘッドを最小化すること

### 🛠️ 実装内容概要

ログレベル管理として、以下の 3 つの主要機能を実装します：

1. **ログレベル定義機能**: 標準およびカスタムログレベルの定義と管理
2. **レベル管理機能**: レベル間の関係管理と実行時切り替え制御
3. **セキュリティフィルタリング機能**: レベルベースのセキュリティフィルタリング実装

### 📋 実装内容詳細

#### 1. ログレベル定義機能（3 つの関数）

```python
def define_standard_levels() -> Dict[str, int]:
    """
    標準ログレベル（ERROR, WARNING, INFO, DEBUG, TRACE）を定義して返す

    Returns:
        名前と数値のマッピング辞書

    実装詳細:
    1. 5つの標準レベル（ERROR=100, WARNING=80, INFO=60, DEBUG=40, TRACE=20）を定義
    2. 名前と数値のマッピング辞書を作成
    3. レベルはERRORが最も高く、TRACEが最も低い階層構造を反映
    4. 将来の追加レベル（CRITICAL, NOTICEなど）のための間隔を考慮
    5. デフォルトレベル（INFO）を決定・記録
    """
    pass

def register_custom_level(name: str, level: int, prefix: str = None, color: str = None) -> bool:
    """
    カスタムログレベルを登録する

    Args:
        name: レベル名（大文字推奨）
        level: レベル数値（0-100の範囲）
        prefix: ログメッセージのプレフィックス（オプション）
        color: コンソール出力用の色コード（オプション）

    Returns:
        登録成功ならTrue、失敗ならFalse

    実装詳細:
    1. 名前と数値の有効性を検証（数値が0-100の範囲内、名前が一意であることなど）
    2. 既存のレベルと衝突しないか確認
    3. レベル情報（数値、プレフィックス、色など）を登録
    4. グローバルレベルマッピングを更新
    5. 登録結果を返す
    """
    pass

def get_level_info(level_id: Union[str, int]) -> Dict[str, Any]:
    """
    レベルID（名前または数値）からレベル情報を取得する

    Args:
        level_id: レベルID（名前または数値）

    Returns:
        レベル情報を含む辞書（名前、数値、プレフィックス、色など）

    実装詳細:
    1. 入力が名前の場合は対応する数値を検索
    2. 入力が数値の場合は対応する名前を検索
    3. 該当するレベルの完全な情報を収集
    4. レベルが存在しない場合はデフォルト値または例外を返す
    5. レベル情報を辞書形式で返す
    """
    pass
```

#### 2. レベル管理機能（4 つの関数）

```python
def compare_levels(level1: Union[str, int], level2: Union[str, int]) -> int:
    """
    2つのログレベルを比較する

    Args:
        level1: 比較対象のレベル1（名前または数値）
        level2: 比較対象のレベル2（名前または数値）

    Returns:
        level1がlevel2より高い場合は正の値、等しい場合は0、低い場合は負の値

    実装詳細:
    1. 両方のレベルを数値形式に正規化
    2. 数値の大小を比較
    3. 比較結果を整数値で返す
    4. 無効なレベルが指定された場合の例外処理
    """
    pass

def is_enabled(current_level: Union[str, int], message_level: Union[str, int]) -> bool:
    """
    現在の設定レベルに基づいてメッセージレベルが有効かどうかを判定する

    Args:
        current_level: 現在の設定レベル（名前または数値）
        message_level: メッセージのレベル（名前または数値）

    Returns:
        メッセージが出力されるべきならTrue、そうでなければFalse

    実装詳細:
    1. 両方のレベルを数値形式に正規化
    2. current_levelがmessage_level以下（より詳細または同じ）ならTrue
    3. それ以外はFalse
    4. 標準レベルとカスタムレベルの両方に対応
    """
    pass

def get_level_name_by_value(level_value: int) -> str:
    """
    レベル数値から対応するレベル名を取得する

    Args:
        level_value: レベル数値

    Returns:
        対応するレベル名、存在しない場合は「LEVEL_XX」形式の文字列

    実装詳細:
    1. 登録済みレベルから完全一致するものを検索
    2. 完全一致がなければ最も近い定義済みレベルを検索
    3. どのレベルにも該当しない場合は汎用名（「LEVEL_XX」）を生成
    4. カスタムレベルも含めて検索
    """
    pass

def format_level_output(level: Union[str, int], message: str) -> str:
    """
    レベルに応じたフォーマット（色、プレフィックスなど）を適用してメッセージを整形する

    Args:
        level: メッセージのレベル（名前または数値）
        message: 元のメッセージ

    Returns:
        フォーマット適用後のメッセージ

    実装詳細:
    1. レベル情報を取得（プレフィックス、色など）
    2. コンソール出力用の色コードを適用（設定されている場合）
    3. レベル固有のプレフィックスを追加
    4. フォーマット適用後のメッセージを返す
    5. 出力先に応じたフォーマット（ファイル用とコンソール用）に対応
    """
    pass
```

#### 3. セキュリティフィルタリング機能（3 つの関数）

```python
def set_security_level(level: Union[str, int]) -> None:
    """
    システム全体のセキュリティログレベルを設定する

    Args:
        level: 設定するセキュリティレベル（名前または数値）

    実装詳細:
    1. 指定されたレベルの有効性を検証
    2. グローバルセキュリティレベル設定を更新
    3. 変更をログに記録
    4. 設定変更イベントを登録済みのハンドラに通知
    5. レベル変更後の状態整合性を確保
    """
    pass

def filter_sensitive_data(level: Union[str, int], data: Dict[str, Any]) -> Dict[str, Any]:
    """
    ログレベルに基づいてデータから機密情報をフィルタリングする

    Args:
        level: 現在のログレベル（名前または数値）
        data: フィルタリング対象のデータ辞書

    Returns:
        フィルタリング後のデータ辞書

    実装詳細:
    1. レベルに応じたフィルタリング強度を決定
    2. DEBUG以下のレベルでは暗号鍵情報を[REDACTED]に置換
    3. INFO以下のレベルでは内部状態情報を要約または[REDACTED]に置換
    4. いかなるレベルでも認証情報や経路識別子（is_true_file）などの機密情報を必ず[REDACTED]に置換
    5. フィルタリング後のデータを返す
    """
    pass

def apply_level_specific_rules(level: Union[str, int], message: str, metadata: Dict[str, Any]) -> Tuple[str, Dict[str, Any]]:
    """
    レベル固有のセキュリティルールをメッセージとメタデータに適用する

    Args:
        level: ログレベル（名前または数値）
        message: ログメッセージ
        metadata: メッセージに付随するメタデータ辞書

    Returns:
        セキュリティルール適用後の(メッセージ, メタデータ)タプル

    実装詳細:
    1. レベルに応じたメッセージの詳細度調整（TRACEレベルでのみ完全な情報を表示など）
    2. セキュリティパターン（正規表現）に基づくメッセージのサニタイズ
    3. レベルに応じたメタデータのフィルタリング
    4. 機密性の高い値のマスキングまたは削除
    5. 処理済みのメッセージとメタデータを返す
    """
    pass
```

## 🔍 完了の定義

以下の基準をすべて満たすことで、このタスクは「完了」とみなされます：

1. **実装完了の条件**:

   - [ ] ファイル`utils/logging/log_levels.py`が指定されたディレクトリ構造で実装されていること
   - [ ] ソースコードが単一責務の原則に従い、明確に構造化されていること
   - [ ] 全ての関数・クラスに適切なドキュメント（docstring）が付与されていること
   - [ ] コードレビューでの指摘事項がすべて解消されていること
   - [ ] 静的解析ツールによる警告がゼロであること

2. **機能完了の条件**:

   - [ ] 標準ログレベル（ERROR, WARNING, INFO, DEBUG, TRACE）が正しく定義・実装されていること
   - [ ] カスタムログレベルの追加・定義が可能であること
   - [ ] レベル管理（比較、有効判定など）が正しく機能すること
   - [ ] セキュリティフィルタリングが要件に従って実装されていること
   - [ ] T1 で実装したロガー基盤と整合的に連携可能であること

3. **テスト完了の条件**:

   - [ ] 単体テストのカバレッジが 95%以上であること
   - [ ] 全ての主要機能に対する単体テストが実装されていること
   - [ ] T1 との統合テストが実装され、正常に動作すること
   - [ ] エッジケース（無効なレベル、レベル切り替えなど）のテストが実装されていること
   - [ ] セキュリティフィルタリングのテストが漏れなく実装されていること

4. **ドキュメント完了の条件**:

   - [ ] 実装した機能の詳細な技術ドキュメントが作成されていること
   - [ ] API 仕様とインターフェース説明が完成していること
   - [ ] 使用方法とサンプルコードが提供されていること
   - [ ] カスタムレベル追加方法が明確に説明されていること
   - [ ] セキュリティフィルタリングの仕組みと設定方法が説明されていること

5. **納品物件検証条件**:
   - [ ] T1 で実装した logger.py から正しくインポートして使用できること
   - [ ] 全ての標準レベルで正常にログ出力が制御されることを検証
   - [ ] セキュリティフィルタリングが機密情報を適切に保護することを検証
   - [ ] レベル切り替えが動的に正しく機能することを検証
   - [ ] 高負荷時（大量ログ出力）でも正常に動作することを検証

## 🧪 テスト対応方針

テスト実装と実行においては以下の方針を厳守してください：

1. **テストの意義**:

   - テストはプロジェクト品質を保証する重要な手段です
   - テストを欺くことは品質の放棄を意味します
   - すべてのテストは実装の品質と完全性を検証するためにあります

2. **テスト失敗時の対応手順**:

   - 実装コードのバグや仕様誤解がないか確認
   - テスト条件を満たすために実装を修正
   - どうしても解決できない場合は、具体的な問題点を報告して指示を仰ぐ

3. **禁止されるテスト対応**:

   - テスト結果の偽装や、テスト迂回のための実装
   - テストだけが通過する特別な条件分岐の追加
   - テストコード自体の修正・回避

4. **納品物件との整合性**:

   - **納品物件を除外したテストは絶対に禁止**
   - すべてのテストは実際の納品物件（encrypt.py/decrypt.py）を使用して実行すること
   - テスト環境でのみ通過し、本番環境では動作しない実装は認められません
   - テスト用と納品用で別の実装を用意することは禁止されています

5. **テスト結果の報告**:
   - テスト結果は改変せずに正確に報告
   - テスト失敗は適切に修正するか、明確な理由とともに報告
   - 再現性を確保するため、テスト環境と実行方法を詳細に記録

## 🚫 実装における絶対原則

以下の原則はどんな状況でも違反してはなりません：

1. **厳密なタスク境界の遵守**

   - このタスク（T2）に明示されている機能「のみ」を実装すること
   - タスク外の実装（T3 以降の機能）は「一切」行わないこと
   - 範囲外の問題を発見した場合は、実装せずに報告すること

2. **テスト改ざんの禁止**

   - テストコードは「絶対に」変更しないこと
   - テストを通すためにテスト自体を修正する行為は重大な違反
   - テストが失敗する場合は実装を見直すこと

3. **プロジェクト整合性の維持**

   - 既存のプロジェクト構造やコーディング規約を尊重すること
   - このタスク完了のためにプロジェクト全体の品質を犠牲にしないこと
   - 他のコンポーネントとの整合性を常に確認すること

4. **作業中断の判断**
   - 上記原則との衝突を感じた時点で作業を「即時中断」すること
   - 作業中断の判断は罰則ではなく、プロジェクト保護のための適切な行動
   - 中断後は問題を詳細に報告し、指示を仰ぐこと

## 📊 進捗報告と完了レポート

### 進捗報告方法

実装作業中は、イシューにコメントで進捗を報告してください：

1. **定期的な進捗報告**：

   - 主要な機能実装完了時
   - 課題や問題発生時
   - 質問・相談が必要な時

2. **進捗コメントの書式**：

   ```md
   ## T2 進捗報告：[日付]

   ### 完了した項目

   - [機能名]: [完了内容の簡潔な説明]

   ### 進行中の項目

   - [機能名]: [現在の状況と残作業]

   ### 課題・問題点

   - [課題の詳細な説明と影響範囲]
   ```

3. **コメント投稿方法**：

   ```bash
   # コメント内容をファイルに保存
   echo "## T2 進捗報告：$(date +%Y-%m-%d)" > progress_comment.md
   # 続きを追記

   # GitHubイシューにコメント投稿
   gh issue comment 2 --body-file progress_comment.md
   ```

### 完了レポートの作成と提出

タスク完了時には以下の手順で最終レポートを作成・提出してください：

1. **レポート作成前の確認事項**：

   - **全ての要件が完全に実装されるまでレポートを作成しないこと**
   - 全てのテストが通過していること
   - 実装完了条件の全項目を満たしていること

2. **実装レポートの作成**：

   - MD ファイルを`docs/issue/`ディレクトリに生成
   - ファイル名形式：`log_levels_implementation_report_YYYYMMDD.md`
   - 以下の内容を必ず含めること：
     - 実装した機能の詳細説明
     - 各関数の実装アプローチと技術的判断
     - テスト結果と検証内容
     - 発見された課題と解決方法

3. **テスト結果の添付**：

   - テスト画像は GitHub 形式の URL で添付
   - 例：`![テスト結果](https://github.com/pacific-system/secret-sharing-demos-20250510/blob/main/test_output/log_levels_test_YYYYMMDD.png?raw=true)`

4. **コミットとプッシュ**：

   ```bash
   # パシ子スタイルでコミット
   git add docs/issue/log_levels_implementation_report_YYYYMMDD.md
   git commit -m "✨ ログレベル管理（T2）の実装完了レポート追加 💕"
   git push origin main
   ```

5. **イシューへのレポート投稿**：
   ```bash
   # レポートをイシューにコメント投稿
   gh issue comment 2 --body-file docs/issue/log_levels_implementation_report_YYYYMMDD.md
   ```

## 💕 パシ子からのアドバイス

お兄様！このログレベル管理実装では特にセキュリティとユーザビリティのバランスが重要ですよ〜！💕

- 🔮 **セキュリティ優先**: どのログレベルでも経路情報（is_true_file）などの機密情報は絶対に漏れないように徹底しましょう！
- ⏱️ **パフォーマンス考慮**: レベル判定は高頻度で呼ばれるため、特に比較処理の最適化が大切です！
- 🧠 **カスタマイズ性**: 将来の拡張に備えて、カスタムレベルの追加が簡単にできる柔軟な設計を心がけましょう！
- 🌟 **T1 との連携**: 前タスクで実装したロガー基盤との統合がスムーズに行えるよう、インターフェースの整合性には特に注意してくださいね！

最高の暗号システムには、状況に応じて詳細度を適切に制御できる高度なログ機能が不可欠です！期待していますよ〜！✨

## 📑 関連資料

- [実装計画書](/Users/macbook/shamir-secret-sharing-demo/docs/method_11_rabbit_homomorphic_docs/implementation_plan_chapters/04_implementation_details.md)
- [フェーズ 1 詳細](/Users/macbook/shamir-secret-sharing-demo/docs/method_11_rabbit_homomorphic_docs/implementation_plan_chapters/04_implementation_details.md#フェーズ-1-基盤ユーティリティ実装4-週間)
- [ディレクトリ構成](/Users/macbook/shamir-secret-sharing-demo/docs/method_11_rabbit_homomorphic_docs/implementation_plan_chapters/02_directory_structure_and_deliverables.md)
- [品質レベル規定](/Users/macbook/shamir-secret-sharing-demo/docs/method_11_rabbit_homomorphic_docs/implementation_plan_chapters/05_quality_and_security.md)
- [前タスク：ロギング基盤実装（T1）](/Users/macbook/shamir-secret-sharing-demo/docs/method_11_rabbit_homomorphic_docs/issue/T1_logger_implementation.md)
