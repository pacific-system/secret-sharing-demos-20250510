# 更新モジュール実装ガイド

## 更新モジュールの目的

このモジュールは既存の暗号化ファイルに対して、特定のシェア ID セットとパスワードに対応する JSON 文書のみを更新します。更新処理は原子的に行われ、他の文書のシェアやメタデータに影響を与えません。

## 主要な機能と要件

### 1. 更新プロセスの安全性確保

- **原子的更新**: 更新が完了するまで元のファイルが損なわれない
- **他文書の保護**: 更新対象でない文書部分（シェア）に影響を与えない
- **コンカレンシーハンドリング**: 複数プロセスによる同時更新を安全に処理

### 2. 一時作業領域の管理

- **一時ファイルの確保**: 更新用の一時ファイルを別途生成し、UUID 付与で一意性確保
- **ロックファイルの管理**: 実行中プロセスを明示し、操作の衝突を防止
- **孤立リソースの検出と削除**: 完了・タイムアウトしたプロセスの一時ファイルを安全に削除

## 主要関数の実装ガイド

### 1. 更新関数の全体構造

```python
def update(encrypted_file, json_doc, password, share_ids):
    """
    暗号化ファイルの特定文書部分を更新

    Args:
        encrypted_file: 既存の暗号化ファイル構造
        json_doc: 新しいJSON文書
        password: 文書に対応するパスワード
        share_ids: 文書に対応するシェアIDセット

    Returns:
        更新された暗号化ファイル構造
    """
    # 一時ファイルとロックファイルの生成
    # 古い一時ファイルのクリーンアップ
    # 新しいシェア生成
    # 対象シェアIDの範囲内のシェアのみを更新
    # 検証と適用
    # 一時ファイルとロックの解放
```

### 2. 一時ファイル管理

```python
def create_temp_resources(operation="update"):
    """
    更新用の一時リソースを作成

    Args:
        operation: 操作種別("update"など)

    Returns:
        (process_uuid, temp_file_path, lock_file_path)のタプル
    """
    # プロセス固有UUIDの生成
    # 一時ファイルとロックファイルのパス生成
    # ロックファイル作成（PIDとタイムスタンプを記録）

def cleanup_stale_temp_files(directory, timeout_seconds=3600):
    """
    期限切れ/孤立した一時ファイルを削除

    Args:
        directory: 一時ファイルが格納されているディレクトリ
        timeout_seconds: プロセスがタイムアウトとみなされる秒数
    """
    # 現在時刻の取得
    # ロックファイルを検索
    # プロセスIDの存在確認
    # タイムスタンプ確認
    # 条件を満たす場合、関連ファイルを削除

def safe_remove_file(file_path):
    """
    ファイルを安全に削除（例外をキャッチして処理継続）

    Args:
        file_path: 削除するファイルのパス
    """
    # ファイルの存在確認
    # 安全な削除処理（例外をキャッチ）
```

### 3. シェア生成と更新

```python
def generate_new_shares(json_doc, threshold, share_ids, p):
    """
    新しいJSON文書からシェアを生成

    Args:
        json_doc: 新しいJSON文書
        threshold: 閾値
        share_ids: 更新対象のシェアIDセット
        p: 有限体の素数

    Returns:
        生成されたシェアのリスト
    """
    # JSON文書のエンコード処理
    # チャンクに分割
    # 各チャンクをシェア化
    # シェアのリストを返却

def update_shares(encrypted_file, new_shares, share_ids):
    """
    暗号化ファイル内の特定シェアを更新

    Args:
        encrypted_file: 既存の暗号化ファイル構造
        new_shares: 新しいシェアのリスト
        share_ids: 更新対象のシェアIDセット

    Returns:
        更新された暗号化ファイル構造
    """
    # 対象シェアIDの範囲内のシェアのみを更新
    # その他のシェアはそのまま保持
    # メタデータの更新（total_chunksなど）
```

### 4. 例外処理と原子性確保

```python
def safe_update(encrypted_file, json_doc, password, share_ids):
    """
    例外処理と原子性を確保した更新処理

    Args:
        encrypted_file: 既存の暗号化ファイル構造
        json_doc: 新しいJSON文書
        password: 文書に対応するパスワード
        share_ids: 文書に対応するシェアIDセット

    Returns:
        更新された暗号化ファイル構造または例外
    """
    # 一時リソースの確保
    # try-exceptブロックで更新処理
    # 例外発生時も一時ファイルとロックを確実に解放
    # 成功時のみ更新を適用
```

## 実装上の制約と注意点

### 1. 並行実行の安全性

- **PID チェック**: プロセス ID の存在確認によるロックの有効性検証
- **タイムスタンプベースのタイムアウト**: 長時間実行プロセスの検出と処理
- **ロックファイル形式の標準化**: JSON を用いたロック情報の構造化保存

```python
# ロックファイルの内容例
{
    'pid': 現在のプロセスID,
    'timestamp': 現在のタイムスタンプ,
    'operation': '操作種別（update等）'
}
```

### 2. エラー回復メカニズム

- **トランザクション的アプローチ**: 全ての更新が成功するか、全く変更が適用されないか
- **検証ステップ**: 変更適用前に新シェアが正しく復号可能か検証
- **ロールバック機能**: 問題が発生した場合に変更を取り消す処理

### 3. 一時ファイルの管理ベストプラクティス

- **一意な名前空間**: プロセス UUID を用いた一時ファイル名の一意性確保
- **場所の固定**: アプリケーション固有の一時ディレクトリを使用
- **有効期限ポリシー**: 一定時間経過後の自動クリーンアップ
- **権限設定**: 安全なアクセス権設定による保護

### 4. リソースリークの防止

- **try-finally パターン**: 例外発生時もリソースを確実に解放
- **明示的なクリーンアップ**: 処理成功時も明示的に一時リソースを解放
- **定期的なスキャン**: アプリケーション起動時などに孤立リソースをチェック

## 更新プロセスの全体フロー

```
一時作業領域の確保
↓
古い一時ファイルのクリーンアップ
↓
新シェアの生成
↓
一時ファイルに中間状態を保存
↓
対象シェアIDの範囲内のシェアのみを更新
↓
メタデータの更新
↓
更新された暗号化ファイルの生成
↓
一時ファイルとロックファイルの削除
```

## パフォーマンスとスケーラビリティ

更新処理のパフォーマンスとスケーラビリティを確保するための指針：

1. **インクリメンタル処理**: 大きなファイルでもメモリ効率よく処理
2. **シェア選択の最適化**: 更新対象シェアの効率的な選択アルゴリズム
3. **ロックの粒度**: 必要最小限の範囲のみロック
4. **バックグラウンド処理**: 長時間実行が予想される場合の非同期処理
