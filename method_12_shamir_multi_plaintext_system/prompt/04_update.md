# 更新モジュール実装ガイド

## 更新モジュールの目的

このモジュールは既存の高度に暗号化されたバイナリファイルに対して、特定のシェア ID セットとパスワードに対応する JSON 文書のみを更新します。更新処理は原子的に行われ、他の文書のシェアやメタデータに影響を与えません。

**重要**: 一度の更新操作で処理できるのは一つの文書のみです。複数の文書を同時に更新することは一切許可されていません。

## 主要な機能と要件

### 1. 更新プロセスの安全性確保

- **原子的更新**: 更新が完了するまで元のファイルが損なわれない
- **他文書の保護**: 更新対象でない文書部分（シェア）に影響を与えない
- **コンカレンシーハンドリング**: 複数プロセスによる同時更新を安全に処理
- **完全性検証**: 暗号化ファイルの完全性を常に検証し維持

### 2. 一時作業領域の管理

- **一時ファイルの確保**: 更新用の一時ファイルを別途生成し、UUID 付与で一意性確保
- **ロックファイルの管理**: 実行中プロセスを明示し、操作の衝突を防止
- **孤立リソースの検出と削除**: 完了・タイムアウトしたプロセスの一時ファイルを安全に削除
- **暗号化保護**: 一時ファイル自体も暗号化して保護

### 3. UUID の継承と検証

- **UUID の保持**: 更新後も元のファイルの UUID を維持
- **バックアップファイルの識別**: バックアップファイルには元の UUID に加えてタイムスタンプを付与
- **一時ファイルの一意性**: 一時ファイルには処理固有の UUID を付与

## 主要関数の実装ガイド

### 1. 更新関数の全体構造

```python
def update(encrypted_data, json_doc, password, share_ids):
    """
    暗号化バイナリファイルの特定文書部分を更新

    Args:
        encrypted_data (bytes): 既存の暗号化バイナリデータ
        json_doc (dict): 新しいJSON文書
        password (str): 文書に対応するパスワード
        share_ids (list): 文書に対応するシェアIDセット

    Returns:
        bytes: 更新された暗号化バイナリデータ（元のUUIDを維持）
    """
    # 1. 暗号化ファイルの復号と解析（UUIDを取得）
    # 2. 一時ファイルとロックファイルの生成（プロセス固有のUUID付与）
    # 3. 古い一時ファイルのクリーンアップ
    # 4. 新しいシェア生成
    # 5. 対象シェアIDの範囲内のシェアのみを更新
    # 6. 変更の検証
    # 7. 更新データを再暗号化（元のUUIDを維持）
    # 8. 一時ファイルとロックの解放
```

### 2. 一時ファイル管理

```python
def create_temp_resources(file_uuid, operation="update"):
    """
    更新用の一時リソースを作成

    Args:
        file_uuid (str): 元の暗号化ファイルのUUID
        operation (str): 操作種別("update"など)

    Returns:
        tuple: (process_uuid, temp_file_path, lock_file_path)のタプル
    """
    # プロセス固有UUIDの生成
    # 元ファイルUUIDとプロセスUUIDを含む一時ファイル名の生成
    # ロックファイルのパス生成
    # ロックファイル作成（PIDとタイムスタンプを記録）

def cleanup_stale_temp_files(directory, timeout_seconds=3600):
    """
    期限切れ/孤立した一時ファイルを削除

    Args:
        directory (str): 一時ファイルが格納されているディレクトリ
        timeout_seconds (int): プロセスがタイムアウトとみなされる秒数
    """
    # 現在時刻の取得
    # ロックファイルを検索
    # プロセスIDの存在確認
    # タイムスタンプ確認
    # 条件を満たす場合、関連ファイルを削除

def safe_remove_file(file_path):
    """
    ファイルを安全に削除（例外をキャッチして処理継続）

    Args:
        file_path (str): 削除するファイルのパス
    """
    # ファイルの存在確認
    # 安全な削除処理（例外をキャッチ）
```

### 3. バイナリファイル処理と更新

```python
def decrypt_and_extract(encrypted_data, password):
    """
    暗号化バイナリファイルを復号してメタデータとシェアを抽出

    Args:
        encrypted_data (bytes): 暗号化バイナリデータ
        password (str): 復号用パスワード

    Returns:
        tuple: (メタデータ, シェアデータ, ファイルUUID, ファイルヘッダ情報)
    """
    # ファイルヘッダを解析（UUIDを含む）
    # パスワードから鍵を導出
    # 認証と復号
    # データの抽出と返却

def generate_new_shares(json_doc, threshold, share_ids, prime):
    """
    新しいJSON文書からシェアを生成

    Args:
        json_doc (dict): 新しいJSON文書
        threshold (int): 閾値
        share_ids (list): 更新対象のシェアIDセット
        prime (int): 有限体の素数

    Returns:
        list: 生成されたシェアのリスト
    """
    # JSON文書のエンコード処理
    # チャンクに分割
    # 各チャンクをシェア化
    # シェアのリストを返却

def update_shares(all_shares, new_shares, share_ids):
    """
    シェアデータ内の特定シェアを更新

    Args:
        all_shares (list): 既存の全シェアリスト
        new_shares (list): 新しいシェアのリスト
        share_ids (list): 更新対象のシェアIDセット

    Returns:
        list: 更新された全シェアリスト
    """
    # 対象シェアIDの範囲内のシェアのみを更新
    # その他のシェアはそのまま保持
    # 更新されたシェアリストを返却

def encrypt_updated_data(metadata, updated_shares, file_uuid, file_header, password):
    """
    更新されたデータを暗号化

    Args:
        metadata (dict): メタデータ
        updated_shares (list): 更新されたシェアリスト
        file_uuid (str): 保持すべき元ファイルのUUID
        file_header (dict): 元ファイルのヘッダ情報
        password (str): 暗号化パスワード

    Returns:
        bytes: 暗号化されたバイナリデータ
    """
    # データの構造化
    # 元のUUIDを維持
    # パスワードから鍵を導出
    # 認証付き暗号化の適用
    # ヘッダ情報の追加
    # 暗号化データの返却
```

### 4. 例外処理と原子性確保

```python
def safe_update(encrypted_data, json_doc, password, share_ids):
    """
    例外処理と原子性を確保した更新処理

    Args:
        encrypted_data (bytes): 既存の暗号化バイナリデータ
        json_doc (dict): 新しいJSON文書
        password (str): 文書に対応するパスワード
        share_ids (list): 文書に対応するシェアIDセット

    Returns:
        bytes: 更新された暗号化バイナリデータ
    """
    # ファイルUUIDの取得
    # 一時リソースの確保（プロセス固有UUID付与）
    # try-exceptブロックで更新処理
    # 例外発生時も一時ファイルとロックを確実に解放
    # 成功時のみ更新を適用

def update_file(input_path, output_path, json_doc, password, share_ids, backup=True):
    """
    ファイルに対する更新処理

    Args:
        input_path (str): 入力ファイルパス
        output_path (str): 出力ファイルパス
        json_doc (dict): 新しいJSON文書
        password (str): 文書に対応するパスワード
        share_ids (list): 文書に対応するシェアIDセット
        backup (bool): 既存ファイルのバックアップを作成するか

    Returns:
        bool: 成功した場合はTrue
    """
    # 入力ファイル読み込み
    # ファイルUUIDの取得
    # 更新処理の実行
    # 原子的なファイル書き込み
    # バックアップ処理（元UUID＋タイムスタンプ形式）
```

## 実装上の制約と注意点

### 1. 並行実行の安全性

- **PID チェック**: プロセス ID の存在確認によるロックの有効性検証
- **タイムスタンプベースのタイムアウト**: 長時間実行プロセスの検出と処理
- **ロックファイル形式の標準化**: バイナリ形式のロック情報を構造化保存
- **ファイルロック**: OS レベルのファイルロック機構も併用

### 2. セキュリティ強化

- **一時ファイルの暗号化**: 更新中の一時データも強力に暗号化
- **メモリの消去**: 機密データ処理後のメモリを明示的に消去
- **認証タグの検証**: バイナリファイルの完全性を常に検証

### 3. エラー回復メカニズム

- **トランザクション的アプローチ**: 全ての更新が成功するか、全く変更が適用されないか
- **検証ステップ**: 変更適用前に新シェアが正しく復号可能か検証
- **ロールバック機能**: 問題が発生した場合に変更を取り消す処理
- **バックアップの自動保持**: 元ファイルのバックアップを確実に取得

### 4. 一時ファイルの管理ベストプラクティス

- **一意な名前空間**: プロセス UUID を用いた一時ファイル名の一意性確保
- **場所の固定**: アプリケーション固有の一時ディレクトリを使用
- **有効期限ポリシー**: 一定時間経過後の自動クリーンアップ
- **権限設定**: 安全なアクセス権設定による保護

### 5. リソースリークの防止

- **try-finally パターン**: 例外発生時もリソースを確実に解放
- **明示的なクリーンアップ**: 処理成功時も明示的に一時リソースを解放
- **定期的なスキャン**: アプリケーション起動時などに孤立リソースをチェック

### 6. UUID の取り扱い

- **UUID の検証**: 入力ファイルの UUID を必ず検証
- **UUID の保持**: 更新処理後も元の UUID を維持（変更しない）
- **命名規則の統一**: 一時ファイル名に含める UUID の形式を標準化
- **衝突回避**: UUID のランダム性を確保し、衝突確率を最小化

## 更新プロセスの全体フロー

```
暗号化ファイルの復号と解析（UUID取得）
↓
一時作業領域の確保（プロセス固有UUID付与）
↓
古い一時ファイルのクリーンアップ
↓
新シェアの生成
↓
一時ファイルに中間状態を保存（暗号化）
↓
対象シェアIDの範囲内のシェアのみを更新
↓
メタデータの更新（元のUUID維持）
↓
更新データの再暗号化
↓
暗号化ファイルの書き込み（原子的操作）
↓
一時ファイルとロックファイルの安全な削除
```

## パフォーマンスとスケーラビリティ

更新処理のパフォーマンスとスケーラビリティを確保するための指針：

1. **インクリメンタル処理**: 大きなファイルでもメモリ効率よく処理
2. **シェア選択の最適化**: 更新対象シェアの効率的な選択アルゴリズム
3. **ロックの粒度**: 必要最小限の範囲のみロック
4. **バックグラウンド処理**: 長時間実行が予想される場合の非同期処理
5. **選択的再暗号化**: 変更された部分のみを再暗号化して効率化

```

```
