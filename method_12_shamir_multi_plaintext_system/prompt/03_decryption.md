# 復号化モジュール実装ガイド

## 復号化モジュールの目的

このモジュールは高度に暗号化されたバイナリファイルから、特定のシェア ID セットとパスワードを用いて単一の JSON 文書を復元します。多段 MAP 方式の特徴を活かし、パスワードによって異なる文書が復号される仕組みです。

## 重要なセキュリティ要件

### 1. 直線的処理の厳格な実装

復号処理において最も重要な要件は「直線的処理」です：

- **条件分岐の禁止**: どのような状況でも入力値による条件分岐を行わない
- **定数時間処理**: 全ての処理が入力値に関わらず同じ時間で実行される
- **タイミング攻撃耐性**: 処理時間から入力情報が推測できないようにする

### 2. 多段 MAP 方式の正確な実装

1. **第 1 段階（シェア ID による限定）**:

   - 入力されたシェア ID セットで候補シェアを限定
   - 該当しないシェア ID のシェアは完全に除外

2. **第 2 段階（パスワードによるマッピング）**:
   - パスワードと塩値から KDF でマップキーを生成
   - 各シェア ID に決定論的にマッピング値を生成
   - マッピング値でソート後、閾値分のシェアを選択

### 3. 暗号化バイナリファイルの処理

- **二重復号**: ファイル全体の暗号化を解除した後、内部データを処理
- **ファイル構造解析**: バイナリフォーマットを適切に解析して各セクションを抽出
- **認証検証**: 認証タグを検証してファイルの完全性を確保
- **UUID 検証**: ファイルに含まれる UUID を確認し、一意性を検証

## 主要関数の実装ガイド

### 1. バイナリファイルの復号と解析

```python
def decrypt_encrypted_file(encrypted_data, password):
    """
    暗号化されたバイナリファイルを復号

    Args:
        encrypted_data (bytes): 暗号化されたバイナリデータ
        password (str): 復号用パスワード

    Returns:
        tuple: (メタデータ, シェアデータ, ファイルUUID) または復号失敗時はNone
    """
    # 1. ファイルヘッダーを解析（UUID含む）
    # 2. パスワードからマスターキーを導出
    # 3. 認証付き暗号の検証と復号
    # 4. 復号されたデータからメタデータとシェアデータを抽出
```

### 2. 多段 MAP の実装

```python
def stage1_map(share_ids):
    """シェアIDによる第1段階MAP生成

    Args:
        share_ids: ユーザー入力のシェアIDセット

    Returns:
        シェアID候補セット
    """
    # シェアIDセットをセットとして返す（単純フィルタとして機能）
    return set(share_ids)

def stage2_map(password, candidate_ids, salt):
    """パスワードによる第2段階MAP生成

    Args:
        password: ユーザー入力のパスワード
        candidate_ids: 第1段階で限定されたシェアIDのセット
        salt: 暗号化時に生成された塩値

    Returns:
        シェアIDからマッピング値へのマップ辞書
    """
    # パスワードからKDFを用いてキーを導出
    # 各シェアIDに対するマッピング値をHMACで決定論的に生成
    # {share_id: mapping_value} 形式の辞書を返す
```

### 3. シェア選択と復元

```python
def select_shares(all_shares, share_ids, password, salt, threshold):
    """多段MAPを用いたシェア選択

    Args:
        all_shares: 全シェアリスト
        share_ids: ユーザー入力のシェアIDセット
        password: ユーザー入力のパスワード
        salt: 暗号化時に生成された塩値
        threshold: 閾値（必要シェア数）

    Returns:
        選択されたシェアのリスト
    """
    # 第1段階：シェアID空間の限定
    # 第2段階：パスワードによるマッピング
    # マッピング値でソート
    # 閾値分のシェアを選択（必ず同じ数を処理）
```

### 4. シャミア秘密分散法による復元

```python
def lagrange_interpolation(shares, p):
    """ラグランジュ補間によるシークレット復元

    Args:
        shares: (x, y)形式のシェアリスト
        p: 有限体の素数

    Returns:
        復元された秘密値
    """
    # ラグランジュ補間によるシークレット復元を実装
    # 有限体GF(p)上での計算に注意
```

### 5. 復号関数

```python
def decrypt(encrypted_data, share_ids, password):
    """暗号化ファイルの復号

    Args:
        encrypted_data (bytes): 暗号化されたバイナリデータ
        share_ids (list): ユーザー入力のシェアIDセット
        password (str): ユーザー入力のパスワード

    Returns:
        tuple: (dict, str) 復元されたJSON文書とファイルUUID、またはデコードに失敗した場合は(None, None)
    """
    # 1. 暗号化ファイルを復号してメタデータ、シェアデータ、UUIDを取得
    # 2. 多段MAPを用いたシェア選択
    # 3. 選択されたシェアを用いてチャンク別に秘密を復元
    # 4. 復元されたデータに多段デコードを適用
    # 5. JSONとして解析
    # 6. JSON文書とUUIDをタプルで返却
```

### 6. 多段デコードと復元処理

```python
def try_decrypt(all_shares, share_ids, password, salt, threshold, prime):
    """シェアを復号（A/B判定なしの直線的処理）

    Args:
        all_shares: 全シェアリスト
        share_ids: ユーザー入力のシェアIDセット
        password: ユーザー入力のパスワード
        salt: 暗号化時に生成された塩値
        threshold: 閾値（必要シェア数）
        prime: 有限体の素数

    Returns:
        bytes: 復元されたバイトデータ
    """
    # 多段MAPの適用
    # チャンク別にシェアを整理
    # 各チャンクの復元（条件分岐なしの直線的処理）
    # 復元データの結合

def decode_data(data):
    """多段デコード処理

    Args:
        data (bytes): 復元されたバイトデータ

    Returns:
        dict or None: デコードされたJSON文書または例外発生時はNone
    """
    # 1. 解凍（圧縮されている場合）
    # 2. Base64デコード
    # 3. Latin-1からUTF-8へのエンコード変換
    # 4. JSON解析
```

## 実装上の制約と注意点

### 1. 条件分岐の禁止と定数時間処理の実装

以下のパターンは条件分岐によるサイドチャネル攻撃を防止するために必須です。すべての条件分岐を含むコードパターンは**禁止**されます。

```python
# ⛔ 禁止: 条件分岐を使った選択
result = value_a if condition else value_b

# ✅ 推奨: ビット演算を用いた定数時間選択
mask = -(condition & 1)  # True -> -1 (all bits 1), False -> 0
result = (value_a & mask) | (value_b & ~mask)

# ⛔ 禁止: 早期リターンによる処理
for share in shares:
    if is_valid(share):
        return share

# ✅ 推奨: 全要素を処理しつつ条件を満たすものを記録
selected = None
for i, share in enumerate(shares):
    is_valid_share = is_valid(share)
    is_first_valid = is_valid_share and (selected is None)
    # ビット演算で条件分岐せずに選択
```

### 2. カナリア値の検証

カナリア値の検証は復号が正しく行われたことを確認するのに役立ちますが、検証自体が情報漏洩につながらないよう注意が必要です。

```python
def verify_canary(decrypted_data, expected_canary_pattern):
    """
    カナリア値を定数時間で検証

    Args:
        decrypted_data (bytes): 復号されたデータ
        expected_canary_pattern (bytes): 期待されるカナリアパターン

    Returns:
        bool: 検証結果（常に固定時間で実行）
    """
    # パターンの抽出
    # 定数時間での比較を実行
    # 結果を返却（タイミング攻撃を防ぐ）
```

### 3. エラーハンドリング

- **失敗の特定を避ける**: 復号に失敗したか成功したかを外部から判別させない
- **例外処理の統一**: 例外を投げる場合も定数時間で処理
- **エラー情報の最小化**: エラーメッセージによる情報漏洩を防止

### 4. パフォーマンスとメモリ使用

- **チャンク単位の処理**: メモリ効率を高めるため、チャンク単位で処理
- **予測可能なメモリアロケーション**: メモリ使用パターンが入力によって大きく変わらないよう設計
- **カタストロフィックバックトラッキング対策**: 正規表現処理などでバックトラッキングによる処理時間増大を防止

### 5. UUID の処理

- **自動命名**: 復号結果ファイルの保存時には元の暗号化ファイルの UUID を使用
- **UUID の検証**: ファイルの一意性を確認するため UUID を検証
- **衝突回避**: 同じ UUID のファイルが存在する場合は上書きを防止

## 復号成功・失敗の判定

復号結果の判定における重要なポイントは、成功・失敗の判定自体がタイミング攻撃につながる可能性があることです。

- **同一処理フローの維持**: 結果の正当性にかかわらず同じ処理を実行
- **条件分岐なしの結果返却**: 成功・失敗の判断基準を内部で持たない
- **エラー伝播の最小化**: 後続処理で JSON 解析失敗などが発生しても情報を漏洩させない

復号プロセスは常に同じステップを実行し、結果が正しい JSON かどうかの判断はこのモジュール外で行います。
